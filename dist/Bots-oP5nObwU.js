var mb = Object.defineProperty;
var _b = (s, e, t) => e in s ? mb(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var Bt = (s, e, t) => (_b(s, typeof e != "symbol" ? e + "" : e, t), t);
function si() {
}
function Ve(s, e) {
  for (const t in e)
    s[t] = e[t];
  return (
    /** @type {T & S} */
    s
  );
}
function bb(s) {
  return !!s && (typeof s == "object" || typeof s == "function") && typeof /** @type {any} */
  s.then == "function";
}
function cm(s) {
  return s();
}
function $d() {
  return /* @__PURE__ */ Object.create(null);
}
function Bs(s) {
  s.forEach(cm);
}
function Dl(s) {
  return typeof s == "function";
}
function pt(s, e) {
  return s != s ? e == e : s !== e || s && typeof s == "object" || typeof s == "function";
}
function yb(s) {
  return Object.keys(s).length === 0;
}
function Go(s, ...e) {
  if (s == null) {
    for (const n of e)
      n(void 0);
    return si;
  }
  const t = s.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
function vb(s) {
  let e;
  return Go(s, (t) => e = t)(), e;
}
function $e(s, e, t) {
  s.$$.on_destroy.push(Go(e, t));
}
function At(s, e, t, n) {
  if (s) {
    const i = lm(s, e, t, n);
    return s[0](i);
  }
}
function lm(s, e, t, n) {
  return s[1] && n ? Ve(t.ctx.slice(), s[1](n(e))) : t.ctx;
}
function gt(s, e, t, n) {
  if (s[2] && n) {
    const i = s[2](n(t));
    if (e.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const r = [], a = Math.max(e.dirty.length, i.length);
      for (let o = 0; o < a; o += 1)
        r[o] = e.dirty[o] | i[o];
      return r;
    }
    return e.dirty | i;
  }
  return e.dirty;
}
function mt(s, e, t, n, i, r) {
  if (i) {
    const a = lm(e, t, n, r);
    s.p(a, i);
  }
}
function _t(s) {
  if (s.ctx.length > 32) {
    const e = [], t = s.ctx.length / 32;
    for (let n = 0; n < t; n++)
      e[n] = -1;
    return e;
  }
  return -1;
}
function Kt(s) {
  const e = {};
  for (const t in s)
    t[0] !== "$" && (e[t] = s[t]);
  return e;
}
function at(s, e) {
  const t = {};
  e = new Set(e);
  for (const n in s)
    !e.has(n) && n[0] !== "$" && (t[n] = s[n]);
  return t;
}
function ep(s, e, t) {
  return s.set(t), e;
}
function _l(s) {
  return s && Dl(s.destroy) ? s.destroy : si;
}
function bl(s, e) {
  s.appendChild(e);
}
function Eb(s, e, t) {
  const n = xb(s);
  if (!n.getElementById(e)) {
    const i = Rr("style");
    i.id = e, i.textContent = t, Sb(n, i);
  }
}
function xb(s) {
  if (!s)
    return document;
  const e = s.getRootNode ? s.getRootNode() : s.ownerDocument;
  return e && /** @type {ShadowRoot} */
  e.host ? (
    /** @type {ShadowRoot} */
    e
  ) : s.ownerDocument;
}
function Sb(s, e) {
  return bl(
    /** @type {Document} */
    s.head || s,
    e
  ), e.sheet;
}
function st(s, e, t) {
  s.insertBefore(e, t || null);
}
function rt(s) {
  s.parentNode && s.parentNode.removeChild(s);
}
function Rr(s) {
  return document.createElement(s);
}
function um(s) {
  return document.createTextNode(s);
}
function Pt() {
  return um(" ");
}
function yi() {
  return um("");
}
function Hi(s, e, t) {
  t == null ? s.removeAttribute(e) : s.getAttribute(e) !== t && s.setAttribute(e, t);
}
const Cb = ["width", "height"];
function Mb(s, e) {
  const t = Object.getOwnPropertyDescriptors(s.__proto__);
  for (const n in e)
    e[n] == null ? s.removeAttribute(n) : n === "style" ? s.style.cssText = e[n] : n === "__value" ? s.value = s[n] = e[n] : t[n] && t[n].set && Cb.indexOf(n) === -1 ? s[n] = e[n] : Hi(s, n, e[n]);
}
function Ib(s, e) {
  Object.keys(e).forEach((t) => {
    wb(s, t, e[t]);
  });
}
function wb(s, e, t) {
  const n = e.toLowerCase();
  n in s ? s[n] = typeof s[n] == "boolean" && t === "" ? !0 : t : e in s ? s[e] = typeof s[e] == "boolean" && t === "" ? !0 : t : Hi(s, e, t);
}
function yl(s) {
  return /-/.test(s) ? Ib : Mb;
}
function Tb(s) {
  return Array.from(s.childNodes);
}
function Bb(s, e, { bubbles: t = !1, cancelable: n = !1 } = {}) {
  return new CustomEvent(s, { detail: e, bubbles: t, cancelable: n });
}
function Rb(s) {
  const e = {};
  return s.childNodes.forEach(
    /** @param {Element} node */
    (t) => {
      e[t.slot || "default"] = !0;
    }
  ), e;
}
let So;
function lr(s) {
  So = s;
}
function vi() {
  if (!So)
    throw new Error("Function called outside component initialization");
  return So;
}
function Qr(s) {
  vi().$$.on_mount.push(s);
}
function Wt(s) {
  vi().$$.on_destroy.push(s);
}
function Db() {
  const s = vi();
  return (e, t, { cancelable: n = !1 } = {}) => {
    const i = s.$$.callbacks[e];
    if (i) {
      const r = Bb(
        /** @type {string} */
        e,
        t,
        { cancelable: n }
      );
      return i.slice().forEach((a) => {
        a.call(s, r);
      }), !r.defaultPrevented;
    }
    return !0;
  };
}
function Jn(s, e) {
  return vi().$$.context.set(s, e), e;
}
function Wn(s) {
  return vi().$$.context.get(s);
}
const la = [], Mt = [];
let pa = [];
const Vh = [], hm = /* @__PURE__ */ Promise.resolve();
let Wh = !1;
function fm() {
  Wh || (Wh = !0, hm.then(Y));
}
function Ll() {
  return fm(), hm;
}
function qh(s) {
  pa.push(s);
}
function Qi(s) {
  Vh.push(s);
}
const Ru = /* @__PURE__ */ new Set();
let Os = 0;
function Y() {
  if (Os !== 0)
    return;
  const s = So;
  do {
    try {
      for (; Os < la.length; ) {
        const e = la[Os];
        Os++, lr(e), Lb(e.$$);
      }
    } catch (e) {
      throw la.length = 0, Os = 0, e;
    }
    for (lr(null), la.length = 0, Os = 0; Mt.length; )
      Mt.pop()();
    for (let e = 0; e < pa.length; e += 1) {
      const t = pa[e];
      Ru.has(t) || (Ru.add(t), t());
    }
    pa.length = 0;
  } while (la.length);
  for (; Vh.length; )
    Vh.pop()();
  Wh = !1, Ru.clear(), lr(s);
}
function Lb(s) {
  if (s.fragment !== null) {
    s.update(), Bs(s.before_update);
    const e = s.dirty;
    s.dirty = [-1], s.fragment && s.fragment.p(s.ctx, e), s.after_update.forEach(qh);
  }
}
function Pb(s) {
  const e = [], t = [];
  pa.forEach((n) => s.indexOf(n) === -1 ? e.push(n) : t.push(n)), t.forEach((n) => n()), pa = e;
}
const ol = /* @__PURE__ */ new Set();
let ds;
function ai() {
  ds = {
    r: 0,
    c: [],
    p: ds
    // parent group
  };
}
function oi() {
  ds.r || Bs(ds.c), ds = ds.p;
}
function ae(s, e) {
  s && s.i && (ol.delete(s), s.i(e));
}
function ue(s, e, t, n) {
  if (s && s.o) {
    if (ol.has(s))
      return;
    ol.add(s), ds.c.push(() => {
      ol.delete(s), n && (t && s.d(1), n());
    }), s.o(e);
  } else
    n && n();
}
function Ub(s, e) {
  const t = e.token = {};
  function n(i, r, a, o) {
    if (e.token !== t)
      return;
    e.resolved = o;
    let c = e.ctx;
    a !== void 0 && (c = c.slice(), c[a] = o);
    const l = i && (e.current = i)(c);
    let u = !1;
    e.block && (e.blocks ? e.blocks.forEach((h, f) => {
      f !== r && h && (ai(), ue(h, 1, 1, () => {
        e.blocks[f] === h && (e.blocks[f] = null);
      }), oi());
    }) : e.block.d(1), l.c(), ae(l, 1), l.m(e.mount(), e.anchor), u = !0), e.block = l, e.blocks && (e.blocks[r] = l), u && Y();
  }
  if (bb(s)) {
    const i = vi();
    if (s.then(
      (r) => {
        lr(i), n(e.then, 1, e.value, r), lr(null);
      },
      (r) => {
        if (lr(i), n(e.catch, 2, e.error, r), lr(null), !e.hasCatch)
          throw r;
      }
    ), e.current !== e.pending)
      return n(e.pending, 0), !0;
  } else {
    if (e.current !== e.then)
      return n(e.then, 1, e.value, s), !0;
    e.resolved = /** @type {T} */
    s;
  }
}
function Fb(s, e, t) {
  const n = e.slice(), { resolved: i } = s;
  s.current === s.then && (n[s.value] = i), s.current === s.catch && (n[s.error] = i), s.block.p(n, t);
}
function Qt(s, e) {
  const t = {}, n = {}, i = { $$scope: 1 };
  let r = s.length;
  for (; r--; ) {
    const a = s[r], o = e[r];
    if (o) {
      for (const c in a)
        c in o || (n[c] = 1);
      for (const c in o)
        i[c] || (t[c] = o[c], i[c] = 1);
      s[r] = o;
    } else
      for (const c in a)
        i[c] = 1;
  }
  for (const a in n)
    a in t || (t[a] = void 0);
  return t;
}
function qt(s) {
  return typeof s == "object" && s !== null ? s : {};
}
function Gi(s, e, t) {
  const n = s.$$.props[e];
  n !== void 0 && (s.$$.bound[n] = t, t(s.$$.ctx[n]));
}
function ze(s) {
  s && s.c();
}
function Oe(s, e, t) {
  const { fragment: n, after_update: i } = s.$$;
  n && n.m(e, t), qh(() => {
    const r = s.$$.on_mount.map(cm).filter(Dl);
    s.$$.on_destroy ? s.$$.on_destroy.push(...r) : Bs(r), s.$$.on_mount = [];
  }), i.forEach(qh);
}
function Qe(s, e) {
  const t = s.$$;
  t.fragment !== null && (Pb(t.after_update), Bs(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
function kb(s, e) {
  s.$$.dirty[0] === -1 && (la.push(s), fm(), s.$$.dirty.fill(0)), s.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Et(s, e, t, n, i, r, a = null, o = [-1]) {
  const c = So;
  lr(s);
  const l = s.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: r,
    update: si,
    not_equal: i,
    bound: $d(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (c ? c.$$.context : [])),
    // everything else
    callbacks: $d(),
    dirty: o,
    skip_bound: !1,
    root: e.target || c.$$.root
  };
  a && a(l.root);
  let u = !1;
  if (l.ctx = t ? t(s, e.props || {}, (h, f, ...d) => {
    const A = d.length ? d[0] : f;
    return l.ctx && i(l.ctx[h], l.ctx[h] = A) && (!l.skip_bound && l.bound[h] && l.bound[h](A), u && kb(s, h)), f;
  }) : [], l.update(), u = !0, Bs(l.before_update), l.fragment = n ? n(l.ctx) : !1, e.target) {
    if (e.hydrate) {
      const h = Tb(e.target);
      l.fragment && l.fragment.l(h), h.forEach(rt);
    } else
      l.fragment && l.fragment.c();
    e.intro && ae(s.$$.fragment), Oe(s, e.target, e.anchor), Y();
  }
  lr(c);
}
let dm;
typeof HTMLElement == "function" && (dm = class extends HTMLElement {
  constructor(e, t, n) {
    super();
    /** The Svelte component constructor */
    Bt(this, "$$ctor");
    /** Slots */
    Bt(this, "$$s");
    /** The Svelte component instance */
    Bt(this, "$$c");
    /** Whether or not the custom element is connected */
    Bt(this, "$$cn", !1);
    /** Component props data */
    Bt(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    Bt(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    Bt(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    Bt(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    Bt(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = e, this.$$s = t, n && this.attachShadow({ mode: "open" });
  }
  addEventListener(e, t, n) {
    if (this.$$l[e] = this.$$l[e] || [], this.$$l[e].push(t), this.$$c) {
      const i = this.$$c.$on(e, t);
      this.$$l_u.set(t, i);
    }
    super.addEventListener(e, t, n);
  }
  removeEventListener(e, t, n) {
    if (super.removeEventListener(e, t, n), this.$$c) {
      const i = this.$$l_u.get(t);
      i && (i(), this.$$l_u.delete(t));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let e = function(r) {
        return () => {
          let a;
          return {
            c: function() {
              a = Rr("slot"), r !== "default" && Hi(a, "name", r);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(l, u) {
              st(l, a, u);
            },
            d: function(l) {
              l && rt(a);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn)
        return;
      const t = {}, n = Rb(this);
      for (const r of this.$$s)
        r in n && (t[r] = [e(r)]);
      for (const r of this.attributes) {
        const a = this.$$g_p(r.name);
        a in this.$$d || (this.$$d[a] = cl(a, r.value, this.$$p_d, "toProp"));
      }
      for (const r in this.$$p_d)
        !(r in this.$$d) && this[r] !== void 0 && (this.$$d[r] = this[r], delete this[r]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: t,
          $$scope: {
            ctx: []
          }
        }
      });
      const i = () => {
        this.$$r = !0;
        for (const r in this.$$p_d)
          if (this.$$d[r] = this.$$c.$$.ctx[this.$$c.$$.props[r]], this.$$p_d[r].reflect) {
            const a = cl(
              r,
              this.$$d[r],
              this.$$p_d,
              "toAttribute"
            );
            a == null ? this.removeAttribute(this.$$p_d[r].attribute || r) : this.setAttribute(this.$$p_d[r].attribute || r, a);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(i), i();
      for (const r in this.$$l)
        for (const a of this.$$l[r]) {
          const o = this.$$c.$on(r, a);
          this.$$l_u.set(a, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(e, t, n) {
    var i;
    this.$$r || (e = this.$$g_p(e), this.$$d[e] = cl(e, n, this.$$p_d, "toProp"), (i = this.$$c) == null || i.$set({ [e]: this.$$d[e] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      this.$$cn || (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(e) {
    return Object.keys(this.$$p_d).find(
      (t) => this.$$p_d[t].attribute === e || !this.$$p_d[t].attribute && t.toLowerCase() === e
    ) || e;
  }
});
function cl(s, e, t, n) {
  var r;
  const i = (r = t[s]) == null ? void 0 : r.type;
  if (e = i === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !t[s])
    return e;
  if (n === "toAttribute")
    switch (i) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (i) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function xt(s, e, t, n, i, r) {
  let a = class extends dm {
    constructor() {
      super(s, t, i), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Object.keys(e).map(
        (o) => (e[o].attribute || o).toLowerCase()
      );
    }
  };
  return Object.keys(e).forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        return this.$$c && o in this.$$c ? this.$$c[o] : this.$$d[o];
      },
      set(c) {
        var l;
        c = cl(o, c, e), this.$$d[o] = c, (l = this.$$c) == null || l.$set({ [o]: c });
      }
    });
  }), n.forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        var c;
        return (c = this.$$c) == null ? void 0 : c[o];
      }
    });
  }), r && (a = r(a)), s.element = /** @type {any} */
  a, a;
}
class St {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Bt(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Bt(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Qe(this, 1), this.$destroy = si;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, t) {
    if (!Dl(t))
      return si;
    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n.push(t), () => {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !yb(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const Nb = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Nb);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Ma = "159", os = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, cs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, pm = 0, Xh = 1, Am = 2, Ob = 3, Qb = 0, Qf = 1, Pl = 2, Oi = 3, mi = 0, Fn = 1, Mn = 2, Gb = 2, fr = 0, ys = 1, Yh = 2, jh = 3, Jh = 4, gm = 5, Br = 100, mm = 101, _m = 102, Kh = 103, Zh = 104, bm = 200, ym = 201, vm = 202, Em = 203, vl = 204, El = 205, xm = 206, Sm = 207, Cm = 208, Mm = 209, Im = 210, wm = 211, Tm = 212, Bm = 213, Rm = 214, Dm = 0, Lm = 1, Pm = 2, Co = 3, Um = 4, Fm = 5, km = 6, Nm = 7, zo = 0, Om = 1, Qm = 2, dr = 0, Gm = 1, zm = 2, Hm = 3, Gf = 4, Vm = 5, $h = "attached", Wm = "detached", Ul = 300, Xi = 301, Fr = 302, _a = 303, Mo = 304, Ia = 306, Ar = 1e3, Ln = 1001, ba = 1002, tn = 1003, Io = 1004, zb = 1004, Aa = 1005, Hb = 1005, wt = 1006, Fl = 1007, Vb = 1007, _i = 1008, Wb = 1008, fn = 1009, qm = 1010, Xm = 1011, kl = 1012, zf = 1013, ur = 1014, pn = 1015, Pn = 1016, Hf = 1017, Vf = 1018, Dr = 1020, Ym = 1021, dn = 1023, jm = 1024, Jm = 1025, Lr = 1026, xs = 1027, ps = 1028, Wf = 1029, As = 1030, qf = 1031, Xf = 1033, Ao = 33776, ll = 33777, ul = 33778, go = 33779, xl = 35840, ef = 35841, Sl = 35842, tf = 35843, Nl = 36196, Cl = 37492, Ml = 37496, Il = 37808, nf = 37809, rf = 37810, sf = 37811, wo = 37812, af = 37813, of = 37814, cf = 37815, lf = 37816, uf = 37817, hf = 37818, ff = 37819, df = 37820, pf = 37821, mo = 36492, Af = 36494, gf = 36495, Km = 36283, mf = 36284, _f = 36285, bf = 36286, Zm = 2200, $m = 2201, e0 = 2202, ya = 2300, Ss = 2301, hl = 2302, gs = 2400, ms = 2401, To = 2402, Ol = 2500, Yf = 2501, t0 = 0, jf = 1, wl = 2, va = 3e3, Wi = 3001, n0 = 3200, Ql = 3201, Gr = 0, i0 = 1, jn = "", Ot = "srgb", rn = "srgb-linear", Ho = "display-p3", wa = "display-p3-linear", Bo = "linear", zt = "srgb", Ro = "rec709", Do = "p3", qb = 0, ls = 7680, Xb = 7681, Yb = 7682, jb = 7683, Jb = 34055, Kb = 34056, Zb = 5386, $b = 512, ey = 513, ty = 514, ny = 515, iy = 516, ry = 517, sy = 518, yf = 519, r0 = 512, s0 = 513, a0 = 514, Jf = 515, o0 = 516, c0 = 517, l0 = 518, u0 = 519, Lo = 35044, vf = 35048, ay = 35040, oy = 35045, cy = 35049, ly = 35041, uy = 35046, hy = 35050, fy = 35042, dy = "100", Ef = "300 es", Tl = 1035, Di = 2e3, Ea = 2001;
class Yi {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, a = i.length; r < a; r++)
        i[r].call(this, e);
      e.target = null;
    }
  }
}
const Qn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let tp = 1234567;
const vs = Math.PI / 180, xa = 180 / Math.PI;
function di() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Qn[s & 255] + Qn[s >> 8 & 255] + Qn[s >> 16 & 255] + Qn[s >> 24 & 255] + "-" + Qn[e & 255] + Qn[e >> 8 & 255] + "-" + Qn[e >> 16 & 15 | 64] + Qn[e >> 24 & 255] + "-" + Qn[t & 63 | 128] + Qn[t >> 8 & 255] + "-" + Qn[t >> 16 & 255] + Qn[t >> 24 & 255] + Qn[n & 255] + Qn[n >> 8 & 255] + Qn[n >> 16 & 255] + Qn[n >> 24 & 255]).toLowerCase();
}
function cn(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Kf(s, e) {
  return (s % e + e) % e;
}
function py(s, e, t, n, i) {
  return n + (s - e) * (i - n) / (t - e);
}
function Ay(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function _o(s, e, t) {
  return (1 - t) * s + t * e;
}
function gy(s, e, t, n) {
  return _o(s, e, 1 - Math.exp(-t * n));
}
function my(s, e = 1) {
  return e - Math.abs(Kf(s, e * 2) - e);
}
function _y(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function by(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function yy(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function vy(s, e) {
  return s + Math.random() * (e - s);
}
function Ey(s) {
  return s * (0.5 - Math.random());
}
function xy(s) {
  s !== void 0 && (tp = s);
  let e = tp += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Sy(s) {
  return s * vs;
}
function Cy(s) {
  return s * xa;
}
function xf(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function My(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Bl(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function Iy(s, e, t, n, i) {
  const r = Math.cos, a = Math.sin, o = r(t / 2), c = a(t / 2), l = r((e + n) / 2), u = a((e + n) / 2), h = r((e - n) / 2), f = a((e - n) / 2), d = r((n - e) / 2), A = a((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(o * u, c * h, c * f, o * l);
      break;
    case "YZY":
      s.set(c * f, o * u, c * h, o * l);
      break;
    case "ZXZ":
      s.set(c * h, c * f, o * u, o * l);
      break;
    case "XZX":
      s.set(o * u, c * A, c * d, o * l);
      break;
    case "YXY":
      s.set(c * d, o * u, c * A, o * l);
      break;
    case "ZYZ":
      s.set(c * A, c * d, o * u, o * l);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function ri(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function dt(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Cs = {
  DEG2RAD: vs,
  RAD2DEG: xa,
  generateUUID: di,
  clamp: cn,
  euclideanModulo: Kf,
  mapLinear: py,
  inverseLerp: Ay,
  lerp: _o,
  damp: gy,
  pingpong: my,
  smoothstep: _y,
  smootherstep: by,
  randInt: yy,
  randFloat: vy,
  randFloatSpread: Ey,
  seededRandom: xy,
  degToRad: Sy,
  radToDeg: Cy,
  isPowerOfTwo: xf,
  ceilPowerOfTwo: My,
  floorPowerOfTwo: Bl,
  setQuaternionFromProperEuler: Iy,
  normalize: dt,
  denormalize: ri
};
class xe {
  constructor(e = 0, t = 0) {
    xe.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(cn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ft {
  constructor(e, t, n, i, r, a, o, c, l) {
    ft.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, a, o, c, l);
  }
  set(e, t, n, i, r, a, o, c, l) {
    const u = this.elements;
    return u[0] = e, u[1] = i, u[2] = o, u[3] = t, u[4] = r, u[5] = c, u[6] = n, u[7] = a, u[8] = l, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, a = n[0], o = n[3], c = n[6], l = n[1], u = n[4], h = n[7], f = n[2], d = n[5], A = n[8], m = i[0], p = i[3], g = i[6], _ = i[1], b = i[4], y = i[7], v = i[2], x = i[5], S = i[8];
    return r[0] = a * m + o * _ + c * v, r[3] = a * p + o * b + c * x, r[6] = a * g + o * y + c * S, r[1] = l * m + u * _ + h * v, r[4] = l * p + u * b + h * x, r[7] = l * g + u * y + h * S, r[2] = f * m + d * _ + A * v, r[5] = f * p + d * b + A * x, r[8] = f * g + d * y + A * S, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], u = e[8];
    return t * a * u - t * o * l - n * r * u + n * o * c + i * r * l - i * a * c;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], u = e[8], h = u * a - o * l, f = o * c - u * r, d = l * r - a * c, A = t * h + n * f + i * d;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / A;
    return e[0] = h * m, e[1] = (i * l - u * n) * m, e[2] = (o * n - i * a) * m, e[3] = f * m, e[4] = (u * t - i * c) * m, e[5] = (i * r - o * t) * m, e[6] = d * m, e[7] = (n * c - l * t) * m, e[8] = (a * t - n * r) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, r, a, o) {
    const c = Math.cos(r), l = Math.sin(r);
    return this.set(
      n * c,
      n * l,
      -n * (c * a + l * o) + a + e,
      -i * l,
      i * c,
      -i * (-l * a + c * o) + o + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Du.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Du.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Du.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Du = /* @__PURE__ */ new ft();
function h0(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535)
      return !0;
  return !1;
}
const wy = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ua(s, e) {
  return new wy[s](e);
}
function Po(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function f0() {
  const s = Po("canvas");
  return s.style.display = "block", s;
}
const np = {};
function bo(s) {
  s in np || (np[s] = !0, console.warn(s));
}
const ip = /* @__PURE__ */ new ft().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), rp = /* @__PURE__ */ new ft().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), oc = {
  [rn]: {
    transfer: Bo,
    primaries: Ro,
    toReference: (s) => s,
    fromReference: (s) => s
  },
  [Ot]: {
    transfer: zt,
    primaries: Ro,
    toReference: (s) => s.convertSRGBToLinear(),
    fromReference: (s) => s.convertLinearToSRGB()
  },
  [wa]: {
    transfer: Bo,
    primaries: Do,
    toReference: (s) => s.applyMatrix3(rp),
    fromReference: (s) => s.applyMatrix3(ip)
  },
  [Ho]: {
    transfer: zt,
    primaries: Do,
    toReference: (s) => s.convertSRGBToLinear().applyMatrix3(rp),
    fromReference: (s) => s.applyMatrix3(ip).convertLinearToSRGB()
  }
}, Ty = /* @__PURE__ */ new Set([rn, wa]), Tt = {
  enabled: !0,
  _workingColorSpace: rn,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(s) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !s;
  },
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(s) {
    if (!Ty.has(s))
      throw new Error(`Unsupported working color space, "${s}".`);
    this._workingColorSpace = s;
  },
  convert: function(s, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return s;
    const n = oc[e].toReference, i = oc[t].fromReference;
    return i(n(s));
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this._workingColorSpace);
  },
  getPrimaries: function(s) {
    return oc[s].primaries;
  },
  getTransfer: function(s) {
    return s === jn ? Bo : oc[s].transfer;
  }
};
function ga(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function Lu(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Qs;
class Zf {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Qs === void 0 && (Qs = Po("canvas")), Qs.width = e.width, Qs.height = e.height;
      const n = Qs.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Qs;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Po("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
      for (let a = 0; a < r.length; a++)
        r[a] = ga(r[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(ga(t[n] / 255) * 255) : t[n] = ga(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let By = 0;
class _s {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: By++ }), this.uuid = di(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let a = 0, o = i.length; a < o; a++)
          i[a].isDataTexture ? r.push(Pu(i[a].image)) : r.push(Pu(i[a]));
      } else
        r = Pu(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Pu(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Zf.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Ry = 0;
class Jt extends Yi {
  constructor(e = Jt.DEFAULT_IMAGE, t = Jt.DEFAULT_MAPPING, n = Ln, i = Ln, r = wt, a = _i, o = dn, c = fn, l = Jt.DEFAULT_ANISOTROPY, u = jn) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Ry++ }), this.uuid = di(), this.name = "", this.source = new _s(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new xe(0, 0), this.repeat = new xe(1, 1), this.center = new xe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ft(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof u == "string" ? this.colorSpace = u : (bo("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = u === Wi ? Ot : jn), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Ul)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Ar:
          e.x = e.x - Math.floor(e.x);
          break;
        case Ln:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ba:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ar:
          e.y = e.y - Math.floor(e.y);
          break;
        case Ln:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ba:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return bo("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Ot ? Wi : va;
  }
  set encoding(e) {
    bo("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Wi ? Ot : jn;
  }
}
Jt.DEFAULT_IMAGE = null;
Jt.DEFAULT_MAPPING = Ul;
Jt.DEFAULT_ANISOTROPY = 1;
class Dt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    Dt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = this.w, a = e.elements;
    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const c = e.elements, l = c[0], u = c[4], h = c[8], f = c[1], d = c[5], A = c[9], m = c[2], p = c[6], g = c[10];
    if (Math.abs(u - f) < 0.01 && Math.abs(h - m) < 0.01 && Math.abs(A - p) < 0.01) {
      if (Math.abs(u + f) < 0.1 && Math.abs(h + m) < 0.1 && Math.abs(A + p) < 0.1 && Math.abs(l + d + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const b = (l + 1) / 2, y = (d + 1) / 2, v = (g + 1) / 2, x = (u + f) / 4, S = (h + m) / 4, I = (A + p) / 4;
      return b > y && b > v ? b < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(b), i = x / n, r = S / n) : y > v ? y < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(y), n = x / i, r = I / i) : v < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(v), n = S / r, i = I / r), this.set(n, i, r, t), this;
    }
    let _ = Math.sqrt((p - A) * (p - A) + (h - m) * (h - m) + (f - u) * (f - u));
    return Math.abs(_) < 1e-3 && (_ = 1), this.x = (p - A) / _, this.y = (h - m) / _, this.z = (f - u) / _, this.w = Math.acos((l + d + g - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class d0 extends Yi {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Dt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Dt(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 && (bo("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Wi ? Ot : jn), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: wt,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), this.texture = new Jt(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new _s(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class pi extends d0 {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class Gl extends Jt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = tn, this.minFilter = tn, this.wrapR = Ln, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Dy extends pi {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new Gl(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class zl extends Jt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = tn, this.minFilter = tn, this.wrapR = Ln, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Ly extends pi {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new zl(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class Py extends pi {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let a = 0; a < n; a++)
      this.texture[a] = r.clone(), this.texture[a].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, r = this.texture.length; i < r; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Rt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, r, a, o) {
    let c = n[i + 0], l = n[i + 1], u = n[i + 2], h = n[i + 3];
    const f = r[a + 0], d = r[a + 1], A = r[a + 2], m = r[a + 3];
    if (o === 0) {
      e[t + 0] = c, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
      return;
    }
    if (o === 1) {
      e[t + 0] = f, e[t + 1] = d, e[t + 2] = A, e[t + 3] = m;
      return;
    }
    if (h !== m || c !== f || l !== d || u !== A) {
      let p = 1 - o;
      const g = c * f + l * d + u * A + h * m, _ = g >= 0 ? 1 : -1, b = 1 - g * g;
      if (b > Number.EPSILON) {
        const v = Math.sqrt(b), x = Math.atan2(v, g * _);
        p = Math.sin(p * x) / v, o = Math.sin(o * x) / v;
      }
      const y = o * _;
      if (c = c * p + f * y, l = l * p + d * y, u = u * p + A * y, h = h * p + m * y, p === 1 - o) {
        const v = 1 / Math.sqrt(c * c + l * l + u * u + h * h);
        c *= v, l *= v, u *= v, h *= v;
      }
    }
    e[t] = c, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, a) {
    const o = n[i], c = n[i + 1], l = n[i + 2], u = n[i + 3], h = r[a], f = r[a + 1], d = r[a + 2], A = r[a + 3];
    return e[t] = o * A + u * h + c * d - l * f, e[t + 1] = c * A + u * f + l * h - o * d, e[t + 2] = l * A + u * d + o * f - c * h, e[t + 3] = u * A - o * h - c * f - l * d, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const n = e._x, i = e._y, r = e._z, a = e._order, o = Math.cos, c = Math.sin, l = o(n / 2), u = o(i / 2), h = o(r / 2), f = c(n / 2), d = c(i / 2), A = c(r / 2);
    switch (a) {
      case "XYZ":
        this._x = f * u * h + l * d * A, this._y = l * d * h - f * u * A, this._z = l * u * A + f * d * h, this._w = l * u * h - f * d * A;
        break;
      case "YXZ":
        this._x = f * u * h + l * d * A, this._y = l * d * h - f * u * A, this._z = l * u * A - f * d * h, this._w = l * u * h + f * d * A;
        break;
      case "ZXY":
        this._x = f * u * h - l * d * A, this._y = l * d * h + f * u * A, this._z = l * u * A + f * d * h, this._w = l * u * h - f * d * A;
        break;
      case "ZYX":
        this._x = f * u * h - l * d * A, this._y = l * d * h + f * u * A, this._z = l * u * A - f * d * h, this._w = l * u * h + f * d * A;
        break;
      case "YZX":
        this._x = f * u * h + l * d * A, this._y = l * d * h + f * u * A, this._z = l * u * A - f * d * h, this._w = l * u * h - f * d * A;
        break;
      case "XZY":
        this._x = f * u * h - l * d * A, this._y = l * d * h - f * u * A, this._z = l * u * A + f * d * h, this._w = l * u * h + f * d * A;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], r = t[8], a = t[1], o = t[5], c = t[9], l = t[2], u = t[6], h = t[10], f = n + o + h;
    if (f > 0) {
      const d = 0.5 / Math.sqrt(f + 1);
      this._w = 0.25 / d, this._x = (u - c) * d, this._y = (r - l) * d, this._z = (a - i) * d;
    } else if (n > o && n > h) {
      const d = 2 * Math.sqrt(1 + n - o - h);
      this._w = (u - c) / d, this._x = 0.25 * d, this._y = (i + a) / d, this._z = (r + l) / d;
    } else if (o > h) {
      const d = 2 * Math.sqrt(1 + o - n - h);
      this._w = (r - l) / d, this._x = (i + a) / d, this._y = 0.25 * d, this._z = (c + u) / d;
    } else {
      const d = 2 * Math.sqrt(1 + h - n - o);
      this._w = (a - i) / d, this._x = (r + l) / d, this._y = (c + u) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(cn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0)
      return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, r = e._z, a = e._w, o = t._x, c = t._y, l = t._z, u = t._w;
    return this._x = n * u + a * o + i * l - r * c, this._y = i * u + a * c + r * o - n * l, this._z = r * u + a * l + n * c - i * o, this._w = a * u - n * o - i * c - r * l, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const n = this._x, i = this._y, r = this._z, a = this._w;
    let o = a * e._w + n * e._x + i * e._y + r * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
      return this._w = a, this._x = n, this._y = i, this._z = r, this;
    const c = 1 - o * o;
    if (c <= Number.EPSILON) {
      const d = 1 - t;
      return this._w = d * a + t * this._w, this._x = d * n + t * this._x, this._y = d * i + t * this._y, this._z = d * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l = Math.sqrt(c), u = Math.atan2(l, o), h = Math.sin((1 - t) * u) / l, f = Math.sin(t * u) / l;
    return this._w = a * h + this._w * f, this._x = n * h + this._x * f, this._y = i * h + this._y * f, this._z = r * h + this._z * f, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class P {
  constructor(e = 0, t = 0, n = 0) {
    P.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(sp.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(sp.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, r = e.x, a = e.y, o = e.z, c = e.w, l = 2 * (a * i - o * n), u = 2 * (o * t - r * i), h = 2 * (r * n - a * t);
    return this.x = t + c * l + a * h - o * u, this.y = n + c * u + o * l - r * h, this.z = i + c * h + r * u - a * l, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, r = e.z, a = t.x, o = t.y, c = t.z;
    return this.x = i * c - r * o, this.y = r * a - n * c, this.z = n * o - i * a, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Uu.copy(this).projectOnVector(e), this.sub(Uu);
  }
  reflect(e) {
    return this.sub(Uu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(cn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Uu = /* @__PURE__ */ new P(), sp = /* @__PURE__ */ new Rt();
class bn {
  constructor(e = new P(1 / 0, 1 / 0, 1 / 0), t = new P(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(wi.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(wi.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = wi.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = r.count; a < o; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, wi) : wi.fromBufferAttribute(r, a), wi.applyMatrix4(e.matrixWorld), this.expandByPoint(wi);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), cc.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), cc.copy(n.boundingBox)), cc.applyMatrix4(e.matrixWorld), this.union(cc);
    }
    const i = e.children;
    for (let r = 0, a = i.length; r < a; r++)
      this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, wi), wi.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Va), lc.subVectors(this.max, Va), Gs.subVectors(e.a, Va), zs.subVectors(e.b, Va), Hs.subVectors(e.c, Va), br.subVectors(zs, Gs), yr.subVectors(Hs, zs), Xr.subVectors(Gs, Hs);
    let t = [
      0,
      -br.z,
      br.y,
      0,
      -yr.z,
      yr.y,
      0,
      -Xr.z,
      Xr.y,
      br.z,
      0,
      -br.x,
      yr.z,
      0,
      -yr.x,
      Xr.z,
      0,
      -Xr.x,
      -br.y,
      br.x,
      0,
      -yr.y,
      yr.x,
      0,
      -Xr.y,
      Xr.x,
      0
    ];
    return !Fu(t, Gs, zs, Hs, lc) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Fu(t, Gs, zs, Hs, lc)) ? !1 : (uc.crossVectors(br, yr), t = [uc.x, uc.y, uc.z], Fu(t, Gs, zs, Hs, lc));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, wi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(wi).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Zi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Zi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Zi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Zi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Zi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Zi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Zi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Zi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Zi), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Zi = [
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P(),
  /* @__PURE__ */ new P()
], wi = /* @__PURE__ */ new P(), cc = /* @__PURE__ */ new bn(), Gs = /* @__PURE__ */ new P(), zs = /* @__PURE__ */ new P(), Hs = /* @__PURE__ */ new P(), br = /* @__PURE__ */ new P(), yr = /* @__PURE__ */ new P(), Xr = /* @__PURE__ */ new P(), Va = /* @__PURE__ */ new P(), lc = /* @__PURE__ */ new P(), uc = /* @__PURE__ */ new P(), Yr = /* @__PURE__ */ new P();
function Fu(s, e, t, n, i) {
  for (let r = 0, a = s.length - 3; r <= a; r += 3) {
    Yr.fromArray(s, r);
    const o = i.x * Math.abs(Yr.x) + i.y * Math.abs(Yr.y) + i.z * Math.abs(Yr.z), c = e.dot(Yr), l = t.dot(Yr), u = n.dot(Yr);
    if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > o)
      return !1;
  }
  return !0;
}
const Uy = /* @__PURE__ */ new bn(), Wa = /* @__PURE__ */ new P(), ku = /* @__PURE__ */ new P();
class yn {
  constructor(e = new P(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Uy.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, a = e.length; r < a; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Wa.subVectors(e, this.center);
    const t = Wa.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Wa, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (ku.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Wa.copy(e.center).add(ku)), this.expandByPoint(Wa.copy(e.center).sub(ku))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $i = /* @__PURE__ */ new P(), Nu = /* @__PURE__ */ new P(), hc = /* @__PURE__ */ new P(), vr = /* @__PURE__ */ new P(), Ou = /* @__PURE__ */ new P(), fc = /* @__PURE__ */ new P(), Qu = /* @__PURE__ */ new P();
class Rs {
  constructor(e = new P(), t = new P(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $i)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = $i.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : ($i.copy(this.origin).addScaledVector(this.direction, t), $i.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    Nu.copy(e).add(t).multiplyScalar(0.5), hc.copy(t).sub(e).normalize(), vr.copy(this.origin).sub(Nu);
    const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(hc), o = vr.dot(this.direction), c = -vr.dot(hc), l = vr.lengthSq(), u = Math.abs(1 - a * a);
    let h, f, d, A;
    if (u > 0)
      if (h = a * c - o, f = a * o - c, A = r * u, h >= 0)
        if (f >= -A)
          if (f <= A) {
            const m = 1 / u;
            h *= m, f *= m, d = h * (h + a * f + 2 * o) + f * (a * h + f + 2 * c) + l;
          } else
            f = r, h = Math.max(0, -(a * f + o)), d = -h * h + f * (f + 2 * c) + l;
        else
          f = -r, h = Math.max(0, -(a * f + o)), d = -h * h + f * (f + 2 * c) + l;
      else
        f <= -A ? (h = Math.max(0, -(-a * r + o)), f = h > 0 ? -r : Math.min(Math.max(-r, -c), r), d = -h * h + f * (f + 2 * c) + l) : f <= A ? (h = 0, f = Math.min(Math.max(-r, -c), r), d = f * (f + 2 * c) + l) : (h = Math.max(0, -(a * r + o)), f = h > 0 ? r : Math.min(Math.max(-r, -c), r), d = -h * h + f * (f + 2 * c) + l);
    else
      f = a > 0 ? -r : r, h = Math.max(0, -(a * f + o)), d = -h * h + f * (f + 2 * c) + l;
    return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(Nu).addScaledVector(hc, f), d;
  }
  intersectSphere(e, t) {
    $i.subVectors(e.center, this.origin);
    const n = $i.dot(this.direction), i = $i.dot($i) - n * n, r = e.radius * e.radius;
    if (i > r)
      return null;
    const a = Math.sqrt(r - i), o = n - a, c = n + a;
    return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, a, o, c;
    const l = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, f = this.origin;
    return l >= 0 ? (n = (e.min.x - f.x) * l, i = (e.max.x - f.x) * l) : (n = (e.max.x - f.x) * l, i = (e.min.x - f.x) * l), u >= 0 ? (r = (e.min.y - f.y) * u, a = (e.max.y - f.y) * u) : (r = (e.max.y - f.y) * u, a = (e.min.y - f.y) * u), n > a || r > i || ((r > n || isNaN(n)) && (n = r), (a < i || isNaN(i)) && (i = a), h >= 0 ? (o = (e.min.z - f.z) * h, c = (e.max.z - f.z) * h) : (o = (e.max.z - f.z) * h, c = (e.min.z - f.z) * h), n > c || o > i) || ((o > n || n !== n) && (n = o), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, $i) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    Ou.subVectors(t, e), fc.subVectors(n, e), Qu.crossVectors(Ou, fc);
    let a = this.direction.dot(Qu), o;
    if (a > 0) {
      if (i)
        return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    vr.subVectors(this.origin, e);
    const c = o * this.direction.dot(fc.crossVectors(vr, fc));
    if (c < 0)
      return null;
    const l = o * this.direction.dot(Ou.cross(vr));
    if (l < 0 || c + l > a)
      return null;
    const u = -o * vr.dot(Qu);
    return u < 0 ? null : this.at(u / a, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Je {
  constructor(e, t, n, i, r, a, o, c, l, u, h, f, d, A, m, p) {
    Je.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, a, o, c, l, u, h, f, d, A, m, p);
  }
  set(e, t, n, i, r, a, o, c, l, u, h, f, d, A, m, p) {
    const g = this.elements;
    return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = c, g[2] = l, g[6] = u, g[10] = h, g[14] = f, g[3] = d, g[7] = A, g[11] = m, g[15] = p, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Je().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / Vs.setFromMatrixColumn(e, 0).length(), r = 1 / Vs.setFromMatrixColumn(e, 1).length(), a = 1 / Vs.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z, a = Math.cos(n), o = Math.sin(n), c = Math.cos(i), l = Math.sin(i), u = Math.cos(r), h = Math.sin(r);
    if (e.order === "XYZ") {
      const f = a * u, d = a * h, A = o * u, m = o * h;
      t[0] = c * u, t[4] = -c * h, t[8] = l, t[1] = d + A * l, t[5] = f - m * l, t[9] = -o * c, t[2] = m - f * l, t[6] = A + d * l, t[10] = a * c;
    } else if (e.order === "YXZ") {
      const f = c * u, d = c * h, A = l * u, m = l * h;
      t[0] = f + m * o, t[4] = A * o - d, t[8] = a * l, t[1] = a * h, t[5] = a * u, t[9] = -o, t[2] = d * o - A, t[6] = m + f * o, t[10] = a * c;
    } else if (e.order === "ZXY") {
      const f = c * u, d = c * h, A = l * u, m = l * h;
      t[0] = f - m * o, t[4] = -a * h, t[8] = A + d * o, t[1] = d + A * o, t[5] = a * u, t[9] = m - f * o, t[2] = -a * l, t[6] = o, t[10] = a * c;
    } else if (e.order === "ZYX") {
      const f = a * u, d = a * h, A = o * u, m = o * h;
      t[0] = c * u, t[4] = A * l - d, t[8] = f * l + m, t[1] = c * h, t[5] = m * l + f, t[9] = d * l - A, t[2] = -l, t[6] = o * c, t[10] = a * c;
    } else if (e.order === "YZX") {
      const f = a * c, d = a * l, A = o * c, m = o * l;
      t[0] = c * u, t[4] = m - f * h, t[8] = A * h + d, t[1] = h, t[5] = a * u, t[9] = -o * u, t[2] = -l * u, t[6] = d * h + A, t[10] = f - m * h;
    } else if (e.order === "XZY") {
      const f = a * c, d = a * l, A = o * c, m = o * l;
      t[0] = c * u, t[4] = -h, t[8] = l * u, t[1] = f * h + m, t[5] = a * u, t[9] = d * h - A, t[2] = A * h - d, t[6] = o * u, t[10] = m * h + f;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Fy, e, ky);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return ui.subVectors(e, t), ui.lengthSq() === 0 && (ui.z = 1), ui.normalize(), Er.crossVectors(n, ui), Er.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ui.x += 1e-4 : ui.z += 1e-4, ui.normalize(), Er.crossVectors(n, ui)), Er.normalize(), dc.crossVectors(ui, Er), i[0] = Er.x, i[4] = dc.x, i[8] = ui.x, i[1] = Er.y, i[5] = dc.y, i[9] = ui.y, i[2] = Er.z, i[6] = dc.z, i[10] = ui.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, a = n[0], o = n[4], c = n[8], l = n[12], u = n[1], h = n[5], f = n[9], d = n[13], A = n[2], m = n[6], p = n[10], g = n[14], _ = n[3], b = n[7], y = n[11], v = n[15], x = i[0], S = i[4], I = i[8], E = i[12], M = i[1], T = i[5], D = i[9], F = i[13], C = i[2], R = i[6], O = i[10], V = i[14], q = i[3], z = i[7], X = i[11], w = i[15];
    return r[0] = a * x + o * M + c * C + l * q, r[4] = a * S + o * T + c * R + l * z, r[8] = a * I + o * D + c * O + l * X, r[12] = a * E + o * F + c * V + l * w, r[1] = u * x + h * M + f * C + d * q, r[5] = u * S + h * T + f * R + d * z, r[9] = u * I + h * D + f * O + d * X, r[13] = u * E + h * F + f * V + d * w, r[2] = A * x + m * M + p * C + g * q, r[6] = A * S + m * T + p * R + g * z, r[10] = A * I + m * D + p * O + g * X, r[14] = A * E + m * F + p * V + g * w, r[3] = _ * x + b * M + y * C + v * q, r[7] = _ * S + b * T + y * R + v * z, r[11] = _ * I + b * D + y * O + v * X, r[15] = _ * E + b * F + y * V + v * w, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], a = e[1], o = e[5], c = e[9], l = e[13], u = e[2], h = e[6], f = e[10], d = e[14], A = e[3], m = e[7], p = e[11], g = e[15];
    return A * (+r * c * h - i * l * h - r * o * f + n * l * f + i * o * d - n * c * d) + m * (+t * c * d - t * l * f + r * a * f - i * a * d + i * l * u - r * c * u) + p * (+t * l * h - t * o * d - r * a * h + n * a * d + r * o * u - n * l * u) + g * (-i * o * u - t * c * h + t * o * f + i * a * h - n * a * f + n * c * u);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], u = e[8], h = e[9], f = e[10], d = e[11], A = e[12], m = e[13], p = e[14], g = e[15], _ = h * p * l - m * f * l + m * c * d - o * p * d - h * c * g + o * f * g, b = A * f * l - u * p * l - A * c * d + a * p * d + u * c * g - a * f * g, y = u * m * l - A * h * l + A * o * d - a * m * d - u * o * g + a * h * g, v = A * h * c - u * m * c - A * o * f + a * m * f + u * o * p - a * h * p, x = t * _ + n * b + i * y + r * v;
    if (x === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / x;
    return e[0] = _ * S, e[1] = (m * f * r - h * p * r - m * i * d + n * p * d + h * i * g - n * f * g) * S, e[2] = (o * p * r - m * c * r + m * i * l - n * p * l - o * i * g + n * c * g) * S, e[3] = (h * c * r - o * f * r - h * i * l + n * f * l + o * i * d - n * c * d) * S, e[4] = b * S, e[5] = (u * p * r - A * f * r + A * i * d - t * p * d - u * i * g + t * f * g) * S, e[6] = (A * c * r - a * p * r - A * i * l + t * p * l + a * i * g - t * c * g) * S, e[7] = (a * f * r - u * c * r + u * i * l - t * f * l - a * i * d + t * c * d) * S, e[8] = y * S, e[9] = (A * h * r - u * m * r - A * n * d + t * m * d + u * n * g - t * h * g) * S, e[10] = (a * m * r - A * o * r + A * n * l - t * m * l - a * n * g + t * o * g) * S, e[11] = (u * o * r - a * h * r - u * n * l + t * h * l + a * n * d - t * o * d) * S, e[12] = v * S, e[13] = (u * m * i - A * h * i + A * n * f - t * m * f - u * n * p + t * h * p) * S, e[14] = (A * o * i - a * m * i - A * n * c + t * m * c + a * n * p - t * o * p) * S, e[15] = (a * h * i - u * o * i + u * n * c - t * h * c - a * n * f + t * o * f) * S, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = 1 - n, a = e.x, o = e.y, c = e.z, l = r * a, u = r * o;
    return this.set(
      l * a + n,
      l * o - i * c,
      l * c + i * o,
      0,
      l * o + i * c,
      u * o + n,
      u * c - i * a,
      0,
      l * c - i * o,
      u * c + i * a,
      r * c * c + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, r, a) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      a,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, r = t._x, a = t._y, o = t._z, c = t._w, l = r + r, u = a + a, h = o + o, f = r * l, d = r * u, A = r * h, m = a * u, p = a * h, g = o * h, _ = c * l, b = c * u, y = c * h, v = n.x, x = n.y, S = n.z;
    return i[0] = (1 - (m + g)) * v, i[1] = (d + y) * v, i[2] = (A - b) * v, i[3] = 0, i[4] = (d - y) * x, i[5] = (1 - (f + g)) * x, i[6] = (p + _) * x, i[7] = 0, i[8] = (A + b) * S, i[9] = (p - _) * S, i[10] = (1 - (f + m)) * S, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = Vs.set(i[0], i[1], i[2]).length();
    const a = Vs.set(i[4], i[5], i[6]).length(), o = Vs.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Ti.copy(this);
    const l = 1 / r, u = 1 / a, h = 1 / o;
    return Ti.elements[0] *= l, Ti.elements[1] *= l, Ti.elements[2] *= l, Ti.elements[4] *= u, Ti.elements[5] *= u, Ti.elements[6] *= u, Ti.elements[8] *= h, Ti.elements[9] *= h, Ti.elements[10] *= h, t.setFromRotationMatrix(Ti), n.x = r, n.y = a, n.z = o, this;
  }
  makePerspective(e, t, n, i, r, a, o = Di) {
    const c = this.elements, l = 2 * r / (t - e), u = 2 * r / (n - i), h = (t + e) / (t - e), f = (n + i) / (n - i);
    let d, A;
    if (o === Di)
      d = -(a + r) / (a - r), A = -2 * a * r / (a - r);
    else if (o === Ea)
      d = -a / (a - r), A = -a * r / (a - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return c[0] = l, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = u, c[9] = f, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = d, c[14] = A, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, r, a, o = Di) {
    const c = this.elements, l = 1 / (t - e), u = 1 / (n - i), h = 1 / (a - r), f = (t + e) * l, d = (n + i) * u;
    let A, m;
    if (o === Di)
      A = (a + r) * h, m = -2 * h;
    else if (o === Ea)
      A = r * h, m = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -f, c[1] = 0, c[5] = 2 * u, c[9] = 0, c[13] = -d, c[2] = 0, c[6] = 0, c[10] = m, c[14] = -A, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const Vs = /* @__PURE__ */ new P(), Ti = /* @__PURE__ */ new Je(), Fy = /* @__PURE__ */ new P(0, 0, 0), ky = /* @__PURE__ */ new P(1, 1, 1), Er = /* @__PURE__ */ new P(), dc = /* @__PURE__ */ new P(), ui = /* @__PURE__ */ new P(), ap = /* @__PURE__ */ new Je(), op = /* @__PURE__ */ new Rt();
class Ds {
  constructor(e = 0, t = 0, n = 0, i = Ds.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, r = i[0], a = i[4], o = i[8], c = i[1], l = i[5], u = i[9], h = i[2], f = i[6], d = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(cn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(f, l), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-cn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(cn(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, r));
        break;
      case "ZYX":
        this._y = Math.asin(-cn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
        break;
      case "YZX":
        this._z = Math.asin(cn(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(o, d));
        break;
      case "XZY":
        this._z = Math.asin(-cn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(f, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-u, d), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return ap.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ap, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return op.setFromEuler(this), this.setFromQuaternion(op, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ds.DEFAULT_ORDER = "XYZ";
class Hl {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Ny = 0;
const cp = /* @__PURE__ */ new P(), Ws = /* @__PURE__ */ new Rt(), er = /* @__PURE__ */ new Je(), pc = /* @__PURE__ */ new P(), qa = /* @__PURE__ */ new P(), Oy = /* @__PURE__ */ new P(), Qy = /* @__PURE__ */ new Rt(), lp = /* @__PURE__ */ new P(1, 0, 0), up = /* @__PURE__ */ new P(0, 1, 0), hp = /* @__PURE__ */ new P(0, 0, 1), Gy = { type: "added" }, zy = { type: "removed" };
class bt extends Yi {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Ny++ }), this.uuid = di(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = bt.DEFAULT_UP.clone();
    const e = new P(), t = new Ds(), n = new Rt(), i = new P(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Je()
      },
      normalMatrix: {
        value: new ft()
      }
    }), this.matrix = new Je(), this.matrixWorld = new Je(), this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Hl(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ws.setFromAxisAngle(e, t), this.quaternion.multiply(Ws), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ws.setFromAxisAngle(e, t), this.quaternion.premultiply(Ws), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(lp, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(up, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(hp, e);
  }
  translateOnAxis(e, t) {
    return cp.copy(e).applyQuaternion(this.quaternion), this.position.add(cp.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(lp, e);
  }
  translateY(e) {
    return this.translateOnAxis(up, e);
  }
  translateZ(e) {
    return this.translateOnAxis(hp, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(er.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? pc.copy(e) : pc.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), qa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? er.lookAt(qa, pc, this.up) : er.lookAt(pc, qa, this.up), this.quaternion.setFromRotationMatrix(er), i && (er.extractRotation(i.matrixWorld), Ws.setFromRotationMatrix(er), this.quaternion.premultiply(Ws.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Gy)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(zy)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), er.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), er.multiply(e.parent.matrixWorld)), e.applyMatrix4(er), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let r = 0, a = i.length; r < a; r++)
      i[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qa, e, Oy), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(qa, Qy, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let r = 0, a = i.length; r < a; r++) {
        const o = i[r];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((o) => ({
      boxInitialized: o.boxInitialized,
      boxMin: o.box.min.toArray(),
      boxMax: o.box.max.toArray(),
      sphereInitialized: o.sphereInitialized,
      sphereRadius: o.sphere.radius,
      sphereCenter: o.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function r(o, c) {
      return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const c = o.shapes;
        if (Array.isArray(c))
          for (let l = 0, u = c.length; l < u; l++) {
            const h = c[l];
            r(e.shapes, h);
          }
        else
          r(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let c = 0, l = this.material.length; c < l; c++)
          o.push(r(e.materials, this.material[c]));
        i.material = o;
      } else
        i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const c = this.animations[o];
        i.animations.push(r(e.animations, c));
      }
    }
    if (t) {
      const o = a(e.geometries), c = a(e.materials), l = a(e.textures), u = a(e.images), h = a(e.shapes), f = a(e.skeletons), d = a(e.animations), A = a(e.nodes);
      o.length > 0 && (n.geometries = o), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), u.length > 0 && (n.images = u), h.length > 0 && (n.shapes = h), f.length > 0 && (n.skeletons = f), d.length > 0 && (n.animations = d), A.length > 0 && (n.nodes = A);
    }
    return n.object = i, n;
    function a(o) {
      const c = [];
      for (const l in o) {
        const u = o[l];
        delete u.metadata, c.push(u);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
bt.DEFAULT_UP = /* @__PURE__ */ new P(0, 1, 0);
bt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Bi = /* @__PURE__ */ new P(), tr = /* @__PURE__ */ new P(), Gu = /* @__PURE__ */ new P(), nr = /* @__PURE__ */ new P(), qs = /* @__PURE__ */ new P(), Xs = /* @__PURE__ */ new P(), fp = /* @__PURE__ */ new P(), zu = /* @__PURE__ */ new P(), Hu = /* @__PURE__ */ new P(), Vu = /* @__PURE__ */ new P();
let Ac = !1;
class ii {
  constructor(e = new P(), t = new P(), n = new P()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Bi.subVectors(e, t), i.cross(Bi);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, r) {
    Bi.subVectors(i, t), tr.subVectors(n, t), Gu.subVectors(e, t);
    const a = Bi.dot(Bi), o = Bi.dot(tr), c = Bi.dot(Gu), l = tr.dot(tr), u = tr.dot(Gu), h = a * l - o * o;
    if (h === 0)
      return r.set(-2, -1, -1);
    const f = 1 / h, d = (l * c - o * u) * f, A = (a * u - o * c) * f;
    return r.set(1 - d - A, A, d);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, nr), nr.x >= 0 && nr.y >= 0 && nr.x + nr.y <= 1;
  }
  static getUV(e, t, n, i, r, a, o, c) {
    return Ac === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Ac = !0), this.getInterpolation(e, t, n, i, r, a, o, c);
  }
  static getInterpolation(e, t, n, i, r, a, o, c) {
    return this.getBarycoord(e, t, n, i, nr), c.setScalar(0), c.addScaledVector(r, nr.x), c.addScaledVector(a, nr.y), c.addScaledVector(o, nr.z), c;
  }
  static isFrontFacing(e, t, n, i) {
    return Bi.subVectors(n, t), tr.subVectors(e, t), Bi.cross(tr).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Bi.subVectors(this.c, this.b), tr.subVectors(this.a, this.b), Bi.cross(tr).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ii.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ii.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return Ac === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Ac = !0), ii.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  getInterpolation(e, t, n, i, r) {
    return ii.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return ii.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ii.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, r = this.c;
    let a, o;
    qs.subVectors(i, n), Xs.subVectors(r, n), zu.subVectors(e, n);
    const c = qs.dot(zu), l = Xs.dot(zu);
    if (c <= 0 && l <= 0)
      return t.copy(n);
    Hu.subVectors(e, i);
    const u = qs.dot(Hu), h = Xs.dot(Hu);
    if (u >= 0 && h <= u)
      return t.copy(i);
    const f = c * h - u * l;
    if (f <= 0 && c >= 0 && u <= 0)
      return a = c / (c - u), t.copy(n).addScaledVector(qs, a);
    Vu.subVectors(e, r);
    const d = qs.dot(Vu), A = Xs.dot(Vu);
    if (A >= 0 && d <= A)
      return t.copy(r);
    const m = d * l - c * A;
    if (m <= 0 && l >= 0 && A <= 0)
      return o = l / (l - A), t.copy(n).addScaledVector(Xs, o);
    const p = u * A - d * h;
    if (p <= 0 && h - u >= 0 && d - A >= 0)
      return fp.subVectors(r, i), o = (h - u) / (h - u + (d - A)), t.copy(i).addScaledVector(fp, o);
    const g = 1 / (p + m + f);
    return a = m * g, o = f * g, t.copy(n).addScaledVector(qs, a).addScaledVector(Xs, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const p0 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, xr = { h: 0, s: 0, l: 0 }, gc = { h: 0, s: 0, l: 0 };
function Wu(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class Pe {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Ot) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Tt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = Tt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Tt.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = Tt.workingColorSpace) {
    if (e = Kf(e, 1), t = cn(t, 0, 1), n = cn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r;
      this.r = Wu(a, r, e + 1 / 3), this.g = Wu(a, r, e), this.b = Wu(a, r, e - 1 / 3);
    }
    return Tt.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Ot) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const a = i[1], o = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = i[1], a = r.length;
      if (a === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (a === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Ot) {
    const n = p0[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ga(e.r), this.g = ga(e.g), this.b = ga(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Lu(e.r), this.g = Lu(e.g), this.b = Lu(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ot) {
    return Tt.fromWorkingColorSpace(Gn.copy(this), e), Math.round(cn(Gn.r * 255, 0, 255)) * 65536 + Math.round(cn(Gn.g * 255, 0, 255)) * 256 + Math.round(cn(Gn.b * 255, 0, 255));
  }
  getHexString(e = Ot) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Tt.workingColorSpace) {
    Tt.fromWorkingColorSpace(Gn.copy(this), t);
    const n = Gn.r, i = Gn.g, r = Gn.b, a = Math.max(n, i, r), o = Math.min(n, i, r);
    let c, l;
    const u = (o + a) / 2;
    if (o === a)
      c = 0, l = 0;
    else {
      const h = a - o;
      switch (l = u <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
        case n:
          c = (i - r) / h + (i < r ? 6 : 0);
          break;
        case i:
          c = (r - n) / h + 2;
          break;
        case r:
          c = (n - i) / h + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = l, e.l = u, e;
  }
  getRGB(e, t = Tt.workingColorSpace) {
    return Tt.fromWorkingColorSpace(Gn.copy(this), t), e.r = Gn.r, e.g = Gn.g, e.b = Gn.b, e;
  }
  getStyle(e = Ot) {
    Tt.fromWorkingColorSpace(Gn.copy(this), e);
    const t = Gn.r, n = Gn.g, i = Gn.b;
    return e !== Ot ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(xr), this.setHSL(xr.h + e, xr.s + t, xr.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(xr), e.getHSL(gc);
    const n = _o(xr.h, gc.h, t), i = _o(xr.s, gc.s, t), r = _o(xr.l, gc.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Gn = /* @__PURE__ */ new Pe();
Pe.NAMES = p0;
let Hy = 0;
class vn extends Yi {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Hy++ }), this.uuid = di(), this.name = "", this.type = "Material", this.blending = ys, this.side = mi, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = vl, this.blendDst = El, this.blendEquation = Br, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Pe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Co, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = yf, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ls, this.stencilZFail = ls, this.stencilZPass = ls, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== ys && (n.blending = this.blending), this.side !== mi && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== vl && (n.blendSrc = this.blendSrc), this.blendDst !== El && (n.blendDst = this.blendDst), this.blendEquation !== Br && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Co && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== yf && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ls && (n.stencilFail = this.stencilFail), this.stencilZFail !== ls && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== ls && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const a = [];
      for (const o in r) {
        const c = r[o];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (t) {
      const r = i(e.textures), a = i(e.images);
      r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class In extends vn {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Pe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const or = /* @__PURE__ */ Vy();
function Vy() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const l = c - 127;
    l < -27 ? (n[c] = 0, n[c | 256] = 32768, i[c] = 24, i[c | 256] = 24) : l < -14 ? (n[c] = 1024 >> -l - 14, n[c | 256] = 1024 >> -l - 14 | 32768, i[c] = -l - 1, i[c | 256] = -l - 1) : l <= 15 ? (n[c] = l + 15 << 10, n[c | 256] = l + 15 << 10 | 32768, i[c] = 13, i[c | 256] = 13) : l < 128 ? (n[c] = 31744, n[c | 256] = 64512, i[c] = 24, i[c | 256] = 24) : (n[c] = 31744, n[c | 256] = 64512, i[c] = 13, i[c | 256] = 13);
  }
  const r = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let l = c << 13, u = 0;
    for (; !(l & 8388608); )
      l <<= 1, u -= 8388608;
    l &= -8388609, u += 947912704, r[c] = l | u;
  }
  for (let c = 1024; c < 2048; ++c)
    r[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    a[c] = c << 23;
  a[31] = 1199570944, a[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    a[c] = 2147483648 + (c - 32 << 23);
  a[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (o[c] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o
  };
}
function ni(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = cn(s, -65504, 65504), or.floatView[0] = s;
  const e = or.uint32View[0], t = e >> 23 & 511;
  return or.baseTable[t] + ((e & 8388607) >> or.shiftTable[t]);
}
function lo(s) {
  const e = s >> 10;
  return or.uint32View[0] = or.mantissaTable[or.offsetTable[e] + (s & 1023)] + or.exponentTable[e], or.floatView[0];
}
const uo = {
  toHalfFloat: ni,
  fromHalfFloat: lo
}, un = /* @__PURE__ */ new P(), mc = /* @__PURE__ */ new xe();
class ut {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Lo, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = pn, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn('THREE.BufferAttribute: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        mc.fromBufferAttribute(this, t), mc.applyMatrix3(e), this.setXY(t, mc.x, mc.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        un.fromBufferAttribute(this, t), un.applyMatrix3(e), this.setXYZ(t, un.x, un.y, un.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      un.fromBufferAttribute(this, t), un.applyMatrix4(e), this.setXYZ(t, un.x, un.y, un.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      un.fromBufferAttribute(this, t), un.applyNormalMatrix(e), this.setXYZ(t, un.x, un.y, un.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      un.fromBufferAttribute(this, t), un.transformDirection(e), this.setXYZ(t, un.x, un.y, un.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = ri(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = dt(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array), r = dt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Lo && (e.usage = this.usage), e;
  }
}
class Wy extends ut {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class qy extends ut {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class Xy extends ut {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class Yy extends ut {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class $f extends ut {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class jy extends ut {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class ed extends ut {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Jy extends ut {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = lo(this.array[e * this.itemSize]);
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize] = ni(t), this;
  }
  getY(e) {
    let t = lo(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 1] = ni(t), this;
  }
  getZ(e) {
    let t = lo(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 2] = ni(t), this;
  }
  getW(e) {
    let t = lo(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.array[e * this.itemSize + 3] = ni(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array)), this.array[e + 0] = ni(t), this.array[e + 1] = ni(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array)), this.array[e + 0] = ni(t), this.array[e + 1] = ni(n), this.array[e + 2] = ni(i), this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array), r = dt(r, this.array)), this.array[e + 0] = ni(t), this.array[e + 1] = ni(n), this.array[e + 2] = ni(i), this.array[e + 3] = ni(r), this;
  }
}
class je extends ut {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class Ky extends ut {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let Zy = 0;
const Ai = /* @__PURE__ */ new Je(), qu = /* @__PURE__ */ new bt(), Ys = /* @__PURE__ */ new P(), hi = /* @__PURE__ */ new bn(), Xa = /* @__PURE__ */ new bn(), Cn = /* @__PURE__ */ new P();
class ot extends Yi {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Zy++ }), this.uuid = di(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (h0(e) ? ed : $f)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new ft().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ai.makeRotationFromQuaternion(e), this.applyMatrix4(Ai), this;
  }
  rotateX(e) {
    return Ai.makeRotationX(e), this.applyMatrix4(Ai), this;
  }
  rotateY(e) {
    return Ai.makeRotationY(e), this.applyMatrix4(Ai), this;
  }
  rotateZ(e) {
    return Ai.makeRotationZ(e), this.applyMatrix4(Ai), this;
  }
  translate(e, t, n) {
    return Ai.makeTranslation(e, t, n), this.applyMatrix4(Ai), this;
  }
  scale(e, t, n) {
    return Ai.makeScale(e, t, n), this.applyMatrix4(Ai), this;
  }
  lookAt(e) {
    return qu.lookAt(e), qu.updateMatrix(), this.applyMatrix4(qu.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ys).negate(), this.translate(Ys.x, Ys.y, Ys.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new je(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new P(-1 / 0, -1 / 0, -1 / 0),
        new P(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          hi.setFromBufferAttribute(r), this.morphTargetsRelative ? (Cn.addVectors(this.boundingBox.min, hi.min), this.boundingBox.expandByPoint(Cn), Cn.addVectors(this.boundingBox.max, hi.max), this.boundingBox.expandByPoint(Cn)) : (this.boundingBox.expandByPoint(hi.min), this.boundingBox.expandByPoint(hi.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yn());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new P(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (hi.setFromBufferAttribute(e), t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r];
          Xa.setFromBufferAttribute(o), this.morphTargetsRelative ? (Cn.addVectors(hi.min, Xa.min), hi.expandByPoint(Cn), Cn.addVectors(hi.max, Xa.max), hi.expandByPoint(Cn)) : (hi.expandByPoint(Xa.min), hi.expandByPoint(Xa.max));
        }
      hi.getCenter(n);
      let i = 0;
      for (let r = 0, a = e.count; r < a; r++)
        Cn.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Cn));
      if (t)
        for (let r = 0, a = t.length; r < a; r++) {
          const o = t[r], c = this.morphTargetsRelative;
          for (let l = 0, u = o.count; l < u; l++)
            Cn.fromBufferAttribute(o, l), c && (Ys.fromBufferAttribute(e, l), Cn.add(Ys)), i = Math.max(i, n.distanceToSquared(Cn));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, i = t.position.array, r = t.normal.array, a = t.uv.array, o = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ut(new Float32Array(4 * o), 4));
    const c = this.getAttribute("tangent").array, l = [], u = [];
    for (let M = 0; M < o; M++)
      l[M] = new P(), u[M] = new P();
    const h = new P(), f = new P(), d = new P(), A = new xe(), m = new xe(), p = new xe(), g = new P(), _ = new P();
    function b(M, T, D) {
      h.fromArray(i, M * 3), f.fromArray(i, T * 3), d.fromArray(i, D * 3), A.fromArray(a, M * 2), m.fromArray(a, T * 2), p.fromArray(a, D * 2), f.sub(h), d.sub(h), m.sub(A), p.sub(A);
      const F = 1 / (m.x * p.y - p.x * m.y);
      isFinite(F) && (g.copy(f).multiplyScalar(p.y).addScaledVector(d, -m.y).multiplyScalar(F), _.copy(d).multiplyScalar(m.x).addScaledVector(f, -p.x).multiplyScalar(F), l[M].add(g), l[T].add(g), l[D].add(g), u[M].add(_), u[T].add(_), u[D].add(_));
    }
    let y = this.groups;
    y.length === 0 && (y = [{
      start: 0,
      count: n.length
    }]);
    for (let M = 0, T = y.length; M < T; ++M) {
      const D = y[M], F = D.start, C = D.count;
      for (let R = F, O = F + C; R < O; R += 3)
        b(
          n[R + 0],
          n[R + 1],
          n[R + 2]
        );
    }
    const v = new P(), x = new P(), S = new P(), I = new P();
    function E(M) {
      S.fromArray(r, M * 3), I.copy(S);
      const T = l[M];
      v.copy(T), v.sub(S.multiplyScalar(S.dot(T))).normalize(), x.crossVectors(I, T);
      const F = x.dot(u[M]) < 0 ? -1 : 1;
      c[M * 4] = v.x, c[M * 4 + 1] = v.y, c[M * 4 + 2] = v.z, c[M * 4 + 3] = F;
    }
    for (let M = 0, T = y.length; M < T; ++M) {
      const D = y[M], F = D.start, C = D.count;
      for (let R = F, O = F + C; R < O; R += 3)
        E(n[R + 0]), E(n[R + 1]), E(n[R + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ut(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let f = 0, d = n.count; f < d; f++)
          n.setXYZ(f, 0, 0, 0);
      const i = new P(), r = new P(), a = new P(), o = new P(), c = new P(), l = new P(), u = new P(), h = new P();
      if (e)
        for (let f = 0, d = e.count; f < d; f += 3) {
          const A = e.getX(f + 0), m = e.getX(f + 1), p = e.getX(f + 2);
          i.fromBufferAttribute(t, A), r.fromBufferAttribute(t, m), a.fromBufferAttribute(t, p), u.subVectors(a, r), h.subVectors(i, r), u.cross(h), o.fromBufferAttribute(n, A), c.fromBufferAttribute(n, m), l.fromBufferAttribute(n, p), o.add(u), c.add(u), l.add(u), n.setXYZ(A, o.x, o.y, o.z), n.setXYZ(m, c.x, c.y, c.z), n.setXYZ(p, l.x, l.y, l.z);
        }
      else
        for (let f = 0, d = t.count; f < d; f += 3)
          i.fromBufferAttribute(t, f + 0), r.fromBufferAttribute(t, f + 1), a.fromBufferAttribute(t, f + 2), u.subVectors(a, r), h.subVectors(i, r), u.cross(h), n.setXYZ(f + 0, u.x, u.y, u.z), n.setXYZ(f + 1, u.x, u.y, u.z), n.setXYZ(f + 2, u.x, u.y, u.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Cn.fromBufferAttribute(e, t), Cn.normalize(), e.setXYZ(t, Cn.x, Cn.y, Cn.z);
  }
  toNonIndexed() {
    function e(o, c) {
      const l = o.array, u = o.itemSize, h = o.normalized, f = new l.constructor(c.length * u);
      let d = 0, A = 0;
      for (let m = 0, p = c.length; m < p; m++) {
        o.isInterleavedBufferAttribute ? d = c[m] * o.data.stride + o.offset : d = c[m] * u;
        for (let g = 0; g < u; g++)
          f[A++] = l[d++];
      }
      return new ut(f, u, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new ot(), n = this.index.array, i = this.attributes;
    for (const o in i) {
      const c = i[o], l = e(c, n);
      t.setAttribute(o, l);
    }
    const r = this.morphAttributes;
    for (const o in r) {
      const c = [], l = r[o];
      for (let u = 0, h = l.length; u < h; u++) {
        const f = l[u], d = e(f, n);
        c.push(d);
      }
      t.morphAttributes[o] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, c = a.length; o < c; o++) {
      const l = a[o];
      t.addGroup(l.start, l.count, l.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const l in c)
        c[l] !== void 0 && (e[l] = c[l]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const c in n) {
      const l = n[c];
      e.data.attributes[c] = l.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const c in this.morphAttributes) {
      const l = this.morphAttributes[c], u = [];
      for (let h = 0, f = l.length; h < f; h++) {
        const d = l[h];
        u.push(d.toJSON(e.data));
      }
      u.length > 0 && (i[c] = u, r = !0);
    }
    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const l in i) {
      const u = i[l];
      this.setAttribute(l, u.clone(t));
    }
    const r = e.morphAttributes;
    for (const l in r) {
      const u = [], h = r[l];
      for (let f = 0, d = h.length; f < d; f++)
        u.push(h[f].clone(t));
      this.morphAttributes[l] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let l = 0, u = a.length; l < u; l++) {
      const h = a[l];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const dp = /* @__PURE__ */ new Je(), jr = /* @__PURE__ */ new Rs(), _c = /* @__PURE__ */ new yn(), pp = /* @__PURE__ */ new P(), js = /* @__PURE__ */ new P(), Js = /* @__PURE__ */ new P(), Ks = /* @__PURE__ */ new P(), Xu = /* @__PURE__ */ new P(), bc = /* @__PURE__ */ new P(), yc = /* @__PURE__ */ new xe(), vc = /* @__PURE__ */ new xe(), Ec = /* @__PURE__ */ new xe(), Ap = /* @__PURE__ */ new P(), gp = /* @__PURE__ */ new P(), mp = /* @__PURE__ */ new P(), xc = /* @__PURE__ */ new P(), Sc = /* @__PURE__ */ new P();
class Ne extends bt {
  constructor(e = new ot(), t = new In()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (r && o) {
      bc.set(0, 0, 0);
      for (let c = 0, l = r.length; c < l; c++) {
        const u = o[c], h = r[c];
        u !== 0 && (Xu.fromBufferAttribute(h, e), a ? bc.addScaledVector(Xu, u) : bc.addScaledVector(Xu.sub(t), u));
      }
      t.add(bc);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, r = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), _c.copy(n.boundingSphere), _c.applyMatrix4(r), jr.copy(e.ray).recast(e.near), !(_c.containsPoint(jr.origin) === !1 && (jr.intersectSphere(_c, pp) === null || jr.origin.distanceToSquared(pp) > (e.far - e.near) ** 2)) && (dp.copy(r).invert(), jr.copy(e.ray).applyMatrix4(dp), !(n.boundingBox !== null && jr.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, jr)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const r = this.geometry, a = this.material, o = r.index, c = r.attributes.position, l = r.attributes.uv, u = r.attributes.uv1, h = r.attributes.normal, f = r.groups, d = r.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let A = 0, m = f.length; A < m; A++) {
          const p = f[A], g = a[p.materialIndex], _ = Math.max(p.start, d.start), b = Math.min(o.count, Math.min(p.start + p.count, d.start + d.count));
          for (let y = _, v = b; y < v; y += 3) {
            const x = o.getX(y), S = o.getX(y + 1), I = o.getX(y + 2);
            i = Cc(this, g, e, n, l, u, h, x, S, I), i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = p.materialIndex, t.push(i));
          }
        }
      else {
        const A = Math.max(0, d.start), m = Math.min(o.count, d.start + d.count);
        for (let p = A, g = m; p < g; p += 3) {
          const _ = o.getX(p), b = o.getX(p + 1), y = o.getX(p + 2);
          i = Cc(this, a, e, n, l, u, h, _, b, y), i && (i.faceIndex = Math.floor(p / 3), t.push(i));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let A = 0, m = f.length; A < m; A++) {
          const p = f[A], g = a[p.materialIndex], _ = Math.max(p.start, d.start), b = Math.min(c.count, Math.min(p.start + p.count, d.start + d.count));
          for (let y = _, v = b; y < v; y += 3) {
            const x = y, S = y + 1, I = y + 2;
            i = Cc(this, g, e, n, l, u, h, x, S, I), i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = p.materialIndex, t.push(i));
          }
        }
      else {
        const A = Math.max(0, d.start), m = Math.min(c.count, d.start + d.count);
        for (let p = A, g = m; p < g; p += 3) {
          const _ = p, b = p + 1, y = p + 2;
          i = Cc(this, a, e, n, l, u, h, _, b, y), i && (i.faceIndex = Math.floor(p / 3), t.push(i));
        }
      }
  }
}
function $y(s, e, t, n, i, r, a, o) {
  let c;
  if (e.side === Fn ? c = n.intersectTriangle(a, r, i, !0, o) : c = n.intersectTriangle(i, r, a, e.side === mi, o), c === null)
    return null;
  Sc.copy(o), Sc.applyMatrix4(s.matrixWorld);
  const l = t.ray.origin.distanceTo(Sc);
  return l < t.near || l > t.far ? null : {
    distance: l,
    point: Sc.clone(),
    object: s
  };
}
function Cc(s, e, t, n, i, r, a, o, c, l) {
  s.getVertexPosition(o, js), s.getVertexPosition(c, Js), s.getVertexPosition(l, Ks);
  const u = $y(s, e, t, n, js, Js, Ks, xc);
  if (u) {
    i && (yc.fromBufferAttribute(i, o), vc.fromBufferAttribute(i, c), Ec.fromBufferAttribute(i, l), u.uv = ii.getInterpolation(xc, js, Js, Ks, yc, vc, Ec, new xe())), r && (yc.fromBufferAttribute(r, o), vc.fromBufferAttribute(r, c), Ec.fromBufferAttribute(r, l), u.uv1 = ii.getInterpolation(xc, js, Js, Ks, yc, vc, Ec, new xe()), u.uv2 = u.uv1), a && (Ap.fromBufferAttribute(a, o), gp.fromBufferAttribute(a, c), mp.fromBufferAttribute(a, l), u.normal = ii.getInterpolation(xc, js, Js, Ks, Ap, gp, mp, new P()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const h = {
      a: o,
      b: c,
      c: l,
      normal: new P(),
      materialIndex: 0
    };
    ii.getNormal(js, Js, Ks, h.normal), u.face = h;
  }
  return u;
}
class en extends ot {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: a
    };
    const o = this;
    i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
    const c = [], l = [], u = [], h = [];
    let f = 0, d = 0;
    A("z", "y", "x", -1, -1, n, t, e, a, r, 0), A("z", "y", "x", 1, -1, n, t, -e, a, r, 1), A("x", "z", "y", 1, 1, e, n, t, i, a, 2), A("x", "z", "y", 1, -1, e, n, -t, i, a, 3), A("x", "y", "z", 1, -1, e, t, n, i, r, 4), A("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(c), this.setAttribute("position", new je(l, 3)), this.setAttribute("normal", new je(u, 3)), this.setAttribute("uv", new je(h, 2));
    function A(m, p, g, _, b, y, v, x, S, I, E) {
      const M = y / S, T = v / I, D = y / 2, F = v / 2, C = x / 2, R = S + 1, O = I + 1;
      let V = 0, q = 0;
      const z = new P();
      for (let X = 0; X < O; X++) {
        const w = X * T - F;
        for (let N = 0; N < R; N++) {
          const H = N * M - D;
          z[m] = H * _, z[p] = w * b, z[g] = C, l.push(z.x, z.y, z.z), z[m] = 0, z[p] = 0, z[g] = x > 0 ? 1 : -1, u.push(z.x, z.y, z.z), h.push(N / S), h.push(1 - X / I), V += 1;
        }
      }
      for (let X = 0; X < I; X++)
        for (let w = 0; w < S; w++) {
          const N = f + w + R * X, H = f + w + R * (X + 1), j = f + (w + 1) + R * (X + 1), $ = f + (w + 1) + R * X;
          c.push(N, H, $), c.push(H, j, $), q += 6;
        }
      o.addGroup(d, q, E), d += q, f += V;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new en(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Sa(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function Yn(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = Sa(s[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function ev(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function A0(s) {
  return s.getRenderTarget() === null ? s.outputColorSpace : Tt.workingColorSpace;
}
const Vl = { clone: Sa, merge: Yn };
var tv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, nv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Kn extends vn {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = tv, this.fragmentShader = nv, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Sa(e.uniforms), this.uniformsGroups = ev(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture ? t.uniforms[i] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? t.uniforms[i] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: a.toArray()
      } : t.uniforms[i] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Wl extends bt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Je(), this.projectionMatrix = new Je(), this.projectionMatrixInverse = new Je(), this.coordinateSystem = Di;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _n extends Wl {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = xa * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(vs * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return xa * 2 * Math.atan(
      Math.tan(vs * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, r, a) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(vs * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, l = a.fullHeight;
      r += a.offsetX * i / c, t -= a.offsetY * n / l, i *= a.width / c, n *= a.height / l;
    }
    const o = this.filmOffset;
    o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Zs = -90, $s = 1;
class td extends bt {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new _n(Zs, $s, e, t);
    i.layers = this.layers, this.add(i);
    const r = new _n(Zs, $s, e, t);
    r.layers = this.layers, this.add(r);
    const a = new _n(Zs, $s, e, t);
    a.layers = this.layers, this.add(a);
    const o = new _n(Zs, $s, e, t);
    o.layers = this.layers, this.add(o);
    const c = new _n(Zs, $s, e, t);
    c.layers = this.layers, this.add(c);
    const l = new _n(Zs, $s, e, t);
    l.layers = this.layers, this.add(l);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, a, o, c] = t;
    for (const l of t)
      this.remove(l);
    if (e === Di)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === Ea)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const l of t)
      this.add(l), l.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, a, o, c, l, u] = this.children, h = e.getRenderTarget(), f = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), A = e.xr.enabled;
    e.xr.enabled = !1;
    const m = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, a), e.setRenderTarget(n, 2, i), e.render(t, o), e.setRenderTarget(n, 3, i), e.render(t, c), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = m, e.setRenderTarget(n, 5, i), e.render(t, u), e.setRenderTarget(h, f, d), e.xr.enabled = A, n.texture.needsPMREMUpdate = !0;
  }
}
class Ta extends Jt {
  constructor(e, t, n, i, r, a, o, c, l, u) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Xi, super(e, t, n, i, r, a, o, c, l, u), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class nd extends pi {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    t.encoding !== void 0 && (bo("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Wi ? Ot : jn), this.texture = new Ta(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : wt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new en(5, 5, 5), r = new Kn({
      name: "CubemapFromEquirect",
      uniforms: Sa(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Fn,
      blending: fr
    });
    r.uniforms.tEquirect.value = t;
    const a = new Ne(i, r), o = t.minFilter;
    return t.minFilter === _i && (t.minFilter = wt), new td(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const Yu = /* @__PURE__ */ new P(), iv = /* @__PURE__ */ new P(), rv = /* @__PURE__ */ new ft();
class ar {
  constructor(e = new P(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Yu.subVectors(n, t).cross(iv.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(Yu), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || rv.getNormalMatrix(e), i = this.coplanarPoint(Yu).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Jr = /* @__PURE__ */ new yn(), Mc = /* @__PURE__ */ new P();
class Vo {
  constructor(e = new ar(), t = new ar(), n = new ar(), i = new ar(), r = new ar(), a = new ar()) {
    this.planes = [e, t, n, i, r, a];
  }
  set(e, t, n, i, r, a) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Di) {
    const n = this.planes, i = e.elements, r = i[0], a = i[1], o = i[2], c = i[3], l = i[4], u = i[5], h = i[6], f = i[7], d = i[8], A = i[9], m = i[10], p = i[11], g = i[12], _ = i[13], b = i[14], y = i[15];
    if (n[0].setComponents(c - r, f - l, p - d, y - g).normalize(), n[1].setComponents(c + r, f + l, p + d, y + g).normalize(), n[2].setComponents(c + a, f + u, p + A, y + _).normalize(), n[3].setComponents(c - a, f - u, p - A, y - _).normalize(), n[4].setComponents(c - o, f - h, p - m, y - b).normalize(), t === Di)
      n[5].setComponents(c + o, f + h, p + m, y + b).normalize();
    else if (t === Ea)
      n[5].setComponents(o, h, m, b).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Jr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Jr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Jr);
  }
  intersectsSprite(e) {
    return Jr.center.set(0, 0, 0), Jr.radius = 0.7071067811865476, Jr.applyMatrix4(e.matrixWorld), this.intersectsSphere(Jr);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (Mc.x = i.normal.x > 0 ? e.max.x : e.min.x, Mc.y = i.normal.y > 0 ? e.max.y : e.min.y, Mc.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Mc) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function g0() {
  let s = null, e = !1, t = null, n = null;
  function i(r, a) {
    t(r, a), n = s.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function sv(s, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function i(l, u) {
    const h = l.array, f = l.usage, d = h.byteLength, A = s.createBuffer();
    s.bindBuffer(u, A), s.bufferData(u, h, f), l.onUploadCallback();
    let m;
    if (h instanceof Float32Array)
      m = s.FLOAT;
    else if (h instanceof Uint16Array)
      if (l.isFloat16BufferAttribute)
        if (t)
          m = s.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        m = s.UNSIGNED_SHORT;
    else if (h instanceof Int16Array)
      m = s.SHORT;
    else if (h instanceof Uint32Array)
      m = s.UNSIGNED_INT;
    else if (h instanceof Int32Array)
      m = s.INT;
    else if (h instanceof Int8Array)
      m = s.BYTE;
    else if (h instanceof Uint8Array)
      m = s.UNSIGNED_BYTE;
    else if (h instanceof Uint8ClampedArray)
      m = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
    return {
      buffer: A,
      type: m,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function r(l, u, h) {
    const f = u.array, d = u._updateRange, A = u.updateRanges;
    if (s.bindBuffer(h, l), d.count === -1 && A.length === 0 && s.bufferSubData(h, 0, f), A.length !== 0) {
      for (let m = 0, p = A.length; m < p; m++) {
        const g = A[m];
        t ? s.bufferSubData(
          h,
          g.start * f.BYTES_PER_ELEMENT,
          f,
          g.start,
          g.count
        ) : s.bufferSubData(
          h,
          g.start * f.BYTES_PER_ELEMENT,
          f.subarray(g.start, g.start + g.count)
        );
      }
      u.clearUpdateRanges();
    }
    d.count !== -1 && (t ? s.bufferSubData(
      h,
      d.offset * f.BYTES_PER_ELEMENT,
      f,
      d.offset,
      d.count
    ) : s.bufferSubData(
      h,
      d.offset * f.BYTES_PER_ELEMENT,
      f.subarray(d.offset, d.offset + d.count)
    ), d.count = -1), u.onUploadCallback();
  }
  function a(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), n.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const u = n.get(l);
    u && (s.deleteBuffer(u.buffer), n.delete(l));
  }
  function c(l, u) {
    if (l.isGLBufferAttribute) {
      const f = n.get(l);
      (!f || f.version < l.version) && n.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    l.isInterleavedBufferAttribute && (l = l.data);
    const h = n.get(l);
    if (h === void 0)
      n.set(l, i(l, u));
    else if (h.version < l.version) {
      if (h.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      r(h.buffer, l, u), h.version = l.version;
    }
  }
  return {
    get: a,
    remove: o,
    update: c
  };
}
class ji extends ot {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const r = e / 2, a = t / 2, o = Math.floor(n), c = Math.floor(i), l = o + 1, u = c + 1, h = e / o, f = t / c, d = [], A = [], m = [], p = [];
    for (let g = 0; g < u; g++) {
      const _ = g * f - a;
      for (let b = 0; b < l; b++) {
        const y = b * h - r;
        A.push(y, -_, 0), m.push(0, 0, 1), p.push(b / o), p.push(1 - g / c);
      }
    }
    for (let g = 0; g < c; g++)
      for (let _ = 0; _ < o; _++) {
        const b = _ + l * g, y = _ + l * (g + 1), v = _ + 1 + l * (g + 1), x = _ + 1 + l * g;
        d.push(b, y, x), d.push(y, v, x);
      }
    this.setIndex(d), this.setAttribute("position", new je(A, 3)), this.setAttribute("normal", new je(m, 3)), this.setAttribute("uv", new je(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ji(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var av = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, ov = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, cv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, lv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, uv = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, hv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, fv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, dv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, pv = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Av = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, gv = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, mv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, _v = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, bv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, yv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, vv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Ev = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, xv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Sv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Cv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Mv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Iv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, wv = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Tv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Bv = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Rv = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Dv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Lv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Pv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Uv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Fv = "gl_FragColor = linearToOutputTexel( gl_FragColor );", kv = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, Nv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Ov = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Qv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Gv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, zv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Hv = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Vv = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Wv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, qv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Xv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Yv = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, jv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Jv = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Kv = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Zv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, $v = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, eE = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, tE = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, nE = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, iE = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, rE = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, sE = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, aE = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, oE = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, cE = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, lE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, uE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, hE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, fE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, dE = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, pE = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, AE = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, gE = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, mE = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, _E = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, bE = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, yE = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, vE = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, EE = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, xE = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, SE = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, CE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, ME = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, IE = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, wE = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, TE = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, BE = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, RE = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, DE = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, LE = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, PE = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, UE = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, FE = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, kE = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, NE = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, OE = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, QE = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, GE = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, zE = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, HE = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, VE = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, WE = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, qE = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, XE = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, YE = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, jE = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, JE = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, KE = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, ZE = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, $E = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, ex = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, tx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, nx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ix = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, rx = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const sx = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, ax = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ox = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cx = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, lx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ux = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, hx = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, fx = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, dx = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, px = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Ax = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, gx = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, mx = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, _x = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, bx = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, yx = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vx = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ex = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xx = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Sx = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Cx = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Mx = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Ix = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wx = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Tx = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Bx = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Rx = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Dx = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Lx = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Px = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Ux = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Fx = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, kx = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Nx = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, tt = {
  alphahash_fragment: av,
  alphahash_pars_fragment: ov,
  alphamap_fragment: cv,
  alphamap_pars_fragment: lv,
  alphatest_fragment: uv,
  alphatest_pars_fragment: hv,
  aomap_fragment: fv,
  aomap_pars_fragment: dv,
  batching_pars_vertex: pv,
  batching_vertex: Av,
  begin_vertex: gv,
  beginnormal_vertex: mv,
  bsdfs: _v,
  iridescence_fragment: bv,
  bumpmap_pars_fragment: yv,
  clipping_planes_fragment: vv,
  clipping_planes_pars_fragment: Ev,
  clipping_planes_pars_vertex: xv,
  clipping_planes_vertex: Sv,
  color_fragment: Cv,
  color_pars_fragment: Mv,
  color_pars_vertex: Iv,
  color_vertex: wv,
  common: Tv,
  cube_uv_reflection_fragment: Bv,
  defaultnormal_vertex: Rv,
  displacementmap_pars_vertex: Dv,
  displacementmap_vertex: Lv,
  emissivemap_fragment: Pv,
  emissivemap_pars_fragment: Uv,
  colorspace_fragment: Fv,
  colorspace_pars_fragment: kv,
  envmap_fragment: Nv,
  envmap_common_pars_fragment: Ov,
  envmap_pars_fragment: Qv,
  envmap_pars_vertex: Gv,
  envmap_physical_pars_fragment: $v,
  envmap_vertex: zv,
  fog_vertex: Hv,
  fog_pars_vertex: Vv,
  fog_fragment: Wv,
  fog_pars_fragment: qv,
  gradientmap_pars_fragment: Xv,
  lightmap_fragment: Yv,
  lightmap_pars_fragment: jv,
  lights_lambert_fragment: Jv,
  lights_lambert_pars_fragment: Kv,
  lights_pars_begin: Zv,
  lights_toon_fragment: eE,
  lights_toon_pars_fragment: tE,
  lights_phong_fragment: nE,
  lights_phong_pars_fragment: iE,
  lights_physical_fragment: rE,
  lights_physical_pars_fragment: sE,
  lights_fragment_begin: aE,
  lights_fragment_maps: oE,
  lights_fragment_end: cE,
  logdepthbuf_fragment: lE,
  logdepthbuf_pars_fragment: uE,
  logdepthbuf_pars_vertex: hE,
  logdepthbuf_vertex: fE,
  map_fragment: dE,
  map_pars_fragment: pE,
  map_particle_fragment: AE,
  map_particle_pars_fragment: gE,
  metalnessmap_fragment: mE,
  metalnessmap_pars_fragment: _E,
  morphcolor_vertex: bE,
  morphnormal_vertex: yE,
  morphtarget_pars_vertex: vE,
  morphtarget_vertex: EE,
  normal_fragment_begin: xE,
  normal_fragment_maps: SE,
  normal_pars_fragment: CE,
  normal_pars_vertex: ME,
  normal_vertex: IE,
  normalmap_pars_fragment: wE,
  clearcoat_normal_fragment_begin: TE,
  clearcoat_normal_fragment_maps: BE,
  clearcoat_pars_fragment: RE,
  iridescence_pars_fragment: DE,
  opaque_fragment: LE,
  packing: PE,
  premultiplied_alpha_fragment: UE,
  project_vertex: FE,
  dithering_fragment: kE,
  dithering_pars_fragment: NE,
  roughnessmap_fragment: OE,
  roughnessmap_pars_fragment: QE,
  shadowmap_pars_fragment: GE,
  shadowmap_pars_vertex: zE,
  shadowmap_vertex: HE,
  shadowmask_pars_fragment: VE,
  skinbase_vertex: WE,
  skinning_pars_vertex: qE,
  skinning_vertex: XE,
  skinnormal_vertex: YE,
  specularmap_fragment: jE,
  specularmap_pars_fragment: JE,
  tonemapping_fragment: KE,
  tonemapping_pars_fragment: ZE,
  transmission_fragment: $E,
  transmission_pars_fragment: ex,
  uv_pars_fragment: tx,
  uv_pars_vertex: nx,
  uv_vertex: ix,
  worldpos_vertex: rx,
  background_vert: sx,
  background_frag: ax,
  backgroundCube_vert: ox,
  backgroundCube_frag: cx,
  cube_vert: lx,
  cube_frag: ux,
  depth_vert: hx,
  depth_frag: fx,
  distanceRGBA_vert: dx,
  distanceRGBA_frag: px,
  equirect_vert: Ax,
  equirect_frag: gx,
  linedashed_vert: mx,
  linedashed_frag: _x,
  meshbasic_vert: bx,
  meshbasic_frag: yx,
  meshlambert_vert: vx,
  meshlambert_frag: Ex,
  meshmatcap_vert: xx,
  meshmatcap_frag: Sx,
  meshnormal_vert: Cx,
  meshnormal_frag: Mx,
  meshphong_vert: Ix,
  meshphong_frag: wx,
  meshphysical_vert: Tx,
  meshphysical_frag: Bx,
  meshtoon_vert: Rx,
  meshtoon_frag: Dx,
  points_vert: Lx,
  points_frag: Px,
  shadow_vert: Ux,
  shadow_frag: Fx,
  sprite_vert: kx,
  sprite_frag: Nx
}, He = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Pe(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ft() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ft() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new ft() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new ft() },
    normalScale: { value: /* @__PURE__ */ new xe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new ft() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new ft() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Pe(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Pe(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ft() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ft() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Pe(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new xe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ft() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ft() },
    alphaTest: { value: 0 }
  }
}, Ri = {
  basic: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.specularmap,
      He.envmap,
      He.aomap,
      He.lightmap,
      He.fog
    ]),
    vertexShader: tt.meshbasic_vert,
    fragmentShader: tt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.specularmap,
      He.envmap,
      He.aomap,
      He.lightmap,
      He.emissivemap,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      He.fog,
      He.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pe(0) }
      }
    ]),
    vertexShader: tt.meshlambert_vert,
    fragmentShader: tt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.specularmap,
      He.envmap,
      He.aomap,
      He.lightmap,
      He.emissivemap,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      He.fog,
      He.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pe(0) },
        specular: { value: /* @__PURE__ */ new Pe(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: tt.meshphong_vert,
    fragmentShader: tt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.envmap,
      He.aomap,
      He.lightmap,
      He.emissivemap,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      He.roughnessmap,
      He.metalnessmap,
      He.fog,
      He.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pe(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: tt.meshphysical_vert,
    fragmentShader: tt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.aomap,
      He.lightmap,
      He.emissivemap,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      He.gradientmap,
      He.fog,
      He.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pe(0) }
      }
    ]),
    vertexShader: tt.meshtoon_vert,
    fragmentShader: tt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      He.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: tt.meshmatcap_vert,
    fragmentShader: tt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Yn([
      He.points,
      He.fog
    ]),
    vertexShader: tt.points_vert,
    fragmentShader: tt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: tt.linedashed_vert,
    fragmentShader: tt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.displacementmap
    ]),
    vertexShader: tt.depth_vert,
    fragmentShader: tt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.bumpmap,
      He.normalmap,
      He.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: tt.meshnormal_vert,
    fragmentShader: tt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Yn([
      He.sprite,
      He.fog
    ]),
    vertexShader: tt.sprite_vert,
    fragmentShader: tt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ft() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: tt.background_vert,
    fragmentShader: tt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: tt.backgroundCube_vert,
    fragmentShader: tt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: tt.cube_vert,
    fragmentShader: tt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: tt.equirect_vert,
    fragmentShader: tt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Yn([
      He.common,
      He.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new P() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: tt.distanceRGBA_vert,
    fragmentShader: tt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Yn([
      He.lights,
      He.fog,
      {
        color: { value: /* @__PURE__ */ new Pe(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: tt.shadow_vert,
    fragmentShader: tt.shadow_frag
  }
};
Ri.physical = {
  uniforms: /* @__PURE__ */ Yn([
    Ri.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new ft() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new ft() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new xe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new ft() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new ft() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new ft() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Pe(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new ft() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new ft() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new ft() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new xe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new ft() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Pe(0) },
      specularColor: { value: /* @__PURE__ */ new Pe(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new ft() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new ft() },
      anisotropyVector: { value: /* @__PURE__ */ new xe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new ft() }
    }
  ]),
  vertexShader: tt.meshphysical_vert,
  fragmentShader: tt.meshphysical_frag
};
const Ic = { r: 0, b: 0, g: 0 };
function Ox(s, e, t, n, i, r, a) {
  const o = new Pe(0);
  let c = r === !0 ? 0 : 1, l, u, h = null, f = 0, d = null;
  function A(p, g) {
    let _ = !1, b = g.isScene === !0 ? g.background : null;
    b && b.isTexture && (b = (g.backgroundBlurriness > 0 ? t : e).get(b)), b === null ? m(o, c) : b && b.isColor && (m(b, 1), _ = !0);
    const y = s.xr.getEnvironmentBlendMode();
    y === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : y === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || _) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), b && (b.isCubeTexture || b.mapping === Ia) ? (u === void 0 && (u = new Ne(
      new en(1, 1, 1),
      new Kn({
        name: "BackgroundCubeMaterial",
        uniforms: Sa(Ri.backgroundCube.uniforms),
        vertexShader: Ri.backgroundCube.vertexShader,
        fragmentShader: Ri.backgroundCube.fragmentShader,
        side: Fn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(v, x, S) {
      this.matrixWorld.copyPosition(S.matrixWorld);
    }, Object.defineProperty(u.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(u)), u.material.uniforms.envMap.value = b, u.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, u.material.toneMapped = Tt.getTransfer(b.colorSpace) !== zt, (h !== b || f !== b.version || d !== s.toneMapping) && (u.material.needsUpdate = !0, h = b, f = b.version, d = s.toneMapping), u.layers.enableAll(), p.unshift(u, u.geometry, u.material, 0, 0, null)) : b && b.isTexture && (l === void 0 && (l = new Ne(
      new ji(2, 2),
      new Kn({
        name: "BackgroundMaterial",
        uniforms: Sa(Ri.background.uniforms),
        vertexShader: Ri.background.vertexShader,
        fragmentShader: Ri.background.fragmentShader,
        side: mi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(l)), l.material.uniforms.t2D.value = b, l.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, l.material.toneMapped = Tt.getTransfer(b.colorSpace) !== zt, b.matrixAutoUpdate === !0 && b.updateMatrix(), l.material.uniforms.uvTransform.value.copy(b.matrix), (h !== b || f !== b.version || d !== s.toneMapping) && (l.material.needsUpdate = !0, h = b, f = b.version, d = s.toneMapping), l.layers.enableAll(), p.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function m(p, g) {
    p.getRGB(Ic, A0(s)), n.buffers.color.setClear(Ic.r, Ic.g, Ic.b, g, a);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(p, g = 1) {
      o.set(p), c = g, m(o, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(p) {
      c = p, m(o, c);
    },
    render: A
  };
}
function Qx(s, e, t, n) {
  const i = s.getParameter(s.MAX_VERTEX_ATTRIBS), r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = n.isWebGL2 || r !== null, o = {}, c = p(null);
  let l = c, u = !1;
  function h(C, R, O, V, q) {
    let z = !1;
    if (a) {
      const X = m(V, O, R);
      l !== X && (l = X, d(l.object)), z = g(C, V, O, q), z && _(C, V, O, q);
    } else {
      const X = R.wireframe === !0;
      (l.geometry !== V.id || l.program !== O.id || l.wireframe !== X) && (l.geometry = V.id, l.program = O.id, l.wireframe = X, z = !0);
    }
    q !== null && t.update(q, s.ELEMENT_ARRAY_BUFFER), (z || u) && (u = !1, I(C, R, O, V), q !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(q).buffer));
  }
  function f() {
    return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function d(C) {
    return n.isWebGL2 ? s.bindVertexArray(C) : r.bindVertexArrayOES(C);
  }
  function A(C) {
    return n.isWebGL2 ? s.deleteVertexArray(C) : r.deleteVertexArrayOES(C);
  }
  function m(C, R, O) {
    const V = O.wireframe === !0;
    let q = o[C.id];
    q === void 0 && (q = {}, o[C.id] = q);
    let z = q[R.id];
    z === void 0 && (z = {}, q[R.id] = z);
    let X = z[V];
    return X === void 0 && (X = p(f()), z[V] = X), X;
  }
  function p(C) {
    const R = [], O = [], V = [];
    for (let q = 0; q < i; q++)
      R[q] = 0, O[q] = 0, V[q] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: R,
      enabledAttributes: O,
      attributeDivisors: V,
      object: C,
      attributes: {},
      index: null
    };
  }
  function g(C, R, O, V) {
    const q = l.attributes, z = R.attributes;
    let X = 0;
    const w = O.getAttributes();
    for (const N in w)
      if (w[N].location >= 0) {
        const j = q[N];
        let $ = z[N];
        if ($ === void 0 && (N === "instanceMatrix" && C.instanceMatrix && ($ = C.instanceMatrix), N === "instanceColor" && C.instanceColor && ($ = C.instanceColor)), j === void 0 || j.attribute !== $ || $ && j.data !== $.data)
          return !0;
        X++;
      }
    return l.attributesNum !== X || l.index !== V;
  }
  function _(C, R, O, V) {
    const q = {}, z = R.attributes;
    let X = 0;
    const w = O.getAttributes();
    for (const N in w)
      if (w[N].location >= 0) {
        let j = z[N];
        j === void 0 && (N === "instanceMatrix" && C.instanceMatrix && (j = C.instanceMatrix), N === "instanceColor" && C.instanceColor && (j = C.instanceColor));
        const $ = {};
        $.attribute = j, j && j.data && ($.data = j.data), q[N] = $, X++;
      }
    l.attributes = q, l.attributesNum = X, l.index = V;
  }
  function b() {
    const C = l.newAttributes;
    for (let R = 0, O = C.length; R < O; R++)
      C[R] = 0;
  }
  function y(C) {
    v(C, 0);
  }
  function v(C, R) {
    const O = l.newAttributes, V = l.enabledAttributes, q = l.attributeDivisors;
    O[C] = 1, V[C] === 0 && (s.enableVertexAttribArray(C), V[C] = 1), q[C] !== R && ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](C, R), q[C] = R);
  }
  function x() {
    const C = l.newAttributes, R = l.enabledAttributes;
    for (let O = 0, V = R.length; O < V; O++)
      R[O] !== C[O] && (s.disableVertexAttribArray(O), R[O] = 0);
  }
  function S(C, R, O, V, q, z, X) {
    X === !0 ? s.vertexAttribIPointer(C, R, O, q, z) : s.vertexAttribPointer(C, R, O, V, q, z);
  }
  function I(C, R, O, V) {
    if (n.isWebGL2 === !1 && (C.isInstancedMesh || V.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    b();
    const q = V.attributes, z = O.getAttributes(), X = R.defaultAttributeValues;
    for (const w in z) {
      const N = z[w];
      if (N.location >= 0) {
        let H = q[w];
        if (H === void 0 && (w === "instanceMatrix" && C.instanceMatrix && (H = C.instanceMatrix), w === "instanceColor" && C.instanceColor && (H = C.instanceColor)), H !== void 0) {
          const j = H.normalized, $ = H.itemSize, ce = t.get(H);
          if (ce === void 0)
            continue;
          const ee = ce.buffer, le = ce.type, Z = ce.bytesPerElement, he = n.isWebGL2 === !0 && (le === s.INT || le === s.UNSIGNED_INT || H.gpuType === zf);
          if (H.isInterleavedBufferAttribute) {
            const _e = H.data, U = _e.stride, ye = H.offset;
            if (_e.isInstancedInterleavedBuffer) {
              for (let ie = 0; ie < N.locationSize; ie++)
                v(N.location + ie, _e.meshPerAttribute);
              C.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = _e.meshPerAttribute * _e.count);
            } else
              for (let ie = 0; ie < N.locationSize; ie++)
                y(N.location + ie);
            s.bindBuffer(s.ARRAY_BUFFER, ee);
            for (let ie = 0; ie < N.locationSize; ie++)
              S(
                N.location + ie,
                $ / N.locationSize,
                le,
                j,
                U * Z,
                (ye + $ / N.locationSize * ie) * Z,
                he
              );
          } else {
            if (H.isInstancedBufferAttribute) {
              for (let _e = 0; _e < N.locationSize; _e++)
                v(N.location + _e, H.meshPerAttribute);
              C.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let _e = 0; _e < N.locationSize; _e++)
                y(N.location + _e);
            s.bindBuffer(s.ARRAY_BUFFER, ee);
            for (let _e = 0; _e < N.locationSize; _e++)
              S(
                N.location + _e,
                $ / N.locationSize,
                le,
                j,
                $ * Z,
                $ / N.locationSize * _e * Z,
                he
              );
          }
        } else if (X !== void 0) {
          const j = X[w];
          if (j !== void 0)
            switch (j.length) {
              case 2:
                s.vertexAttrib2fv(N.location, j);
                break;
              case 3:
                s.vertexAttrib3fv(N.location, j);
                break;
              case 4:
                s.vertexAttrib4fv(N.location, j);
                break;
              default:
                s.vertexAttrib1fv(N.location, j);
            }
        }
      }
    }
    x();
  }
  function E() {
    D();
    for (const C in o) {
      const R = o[C];
      for (const O in R) {
        const V = R[O];
        for (const q in V)
          A(V[q].object), delete V[q];
        delete R[O];
      }
      delete o[C];
    }
  }
  function M(C) {
    if (o[C.id] === void 0)
      return;
    const R = o[C.id];
    for (const O in R) {
      const V = R[O];
      for (const q in V)
        A(V[q].object), delete V[q];
      delete R[O];
    }
    delete o[C.id];
  }
  function T(C) {
    for (const R in o) {
      const O = o[R];
      if (O[C.id] === void 0)
        continue;
      const V = O[C.id];
      for (const q in V)
        A(V[q].object), delete V[q];
      delete O[C.id];
    }
  }
  function D() {
    F(), u = !0, l !== c && (l = c, d(l.object));
  }
  function F() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: h,
    reset: D,
    resetDefaultState: F,
    dispose: E,
    releaseStatesOfGeometry: M,
    releaseStatesOfProgram: T,
    initAttributes: b,
    enableAttribute: y,
    disableUnusedAttributes: x
  };
}
function Gx(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function a(u) {
    r = u;
  }
  function o(u, h) {
    s.drawArrays(r, u, h), t.update(h, r, 1);
  }
  function c(u, h, f) {
    if (f === 0)
      return;
    let d, A;
    if (i)
      d = s, A = "drawArraysInstanced";
    else if (d = e.get("ANGLE_instanced_arrays"), A = "drawArraysInstancedANGLE", d === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    d[A](r, u, h, f), t.update(h, r, f);
  }
  function l(u, h, f) {
    if (f === 0)
      return;
    const d = e.get("WEBGL_multi_draw");
    if (d === null)
      for (let A = 0; A < f; A++)
        this.render(u[A], h[A]);
    else {
      d.multiDrawArraysWEBGL(r, u, 0, h, 0, f);
      let A = 0;
      for (let m = 0; m < f; m++)
        A += h[m];
      t.update(A, r, 1);
    }
  }
  this.setMode = a, this.render = o, this.renderInstances = c, this.renderMultiDraw = l;
}
function zx(s, e, t) {
  let n;
  function i() {
    if (n !== void 0)
      return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const S = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function r(S) {
    if (S === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      S = "mediump";
    }
    return S === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const c = r(o);
  c !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", c, "instead."), o = c);
  const l = a || e.has("WEBGL_draw_buffers"), u = t.logarithmicDepthBuffer === !0, h = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), f = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), d = s.getParameter(s.MAX_TEXTURE_SIZE), A = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), m = s.getParameter(s.MAX_VERTEX_ATTRIBS), p = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), g = s.getParameter(s.MAX_VARYING_VECTORS), _ = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), b = f > 0, y = a || e.has("OES_texture_float"), v = b && y, x = a ? s.getParameter(s.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: l,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: o,
    logarithmicDepthBuffer: u,
    maxTextures: h,
    maxVertexTextures: f,
    maxTextureSize: d,
    maxCubemapSize: A,
    maxAttributes: m,
    maxVertexUniforms: p,
    maxVaryings: g,
    maxFragmentUniforms: _,
    vertexTextures: b,
    floatFragmentTextures: y,
    floatVertexTextures: v,
    maxSamples: x
  };
}
function Hx(s) {
  const e = this;
  let t = null, n = 0, i = !1, r = !1;
  const a = new ar(), o = new ft(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, f) {
    const d = h.length !== 0 || f || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = f, n = h.length, d;
  }, this.beginShadows = function() {
    r = !0, u(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(h, f) {
    t = u(h, f, 0);
  }, this.setState = function(h, f, d) {
    const A = h.clippingPlanes, m = h.clipIntersection, p = h.clipShadows, g = s.get(h);
    if (!i || A === null || A.length === 0 || r && !p)
      r ? u(null) : l();
    else {
      const _ = r ? 0 : n, b = _ * 4;
      let y = g.clippingState || null;
      c.value = y, y = u(A, f, b, d);
      for (let v = 0; v !== b; ++v)
        y[v] = t[v];
      g.clippingState = y, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += _;
    }
  };
  function l() {
    c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function u(h, f, d, A) {
    const m = h !== null ? h.length : 0;
    let p = null;
    if (m !== 0) {
      if (p = c.value, A !== !0 || p === null) {
        const g = d + m * 4, _ = f.matrixWorldInverse;
        o.getNormalMatrix(_), (p === null || p.length < g) && (p = new Float32Array(g));
        for (let b = 0, y = d; b !== m; ++b, y += 4)
          a.copy(h[b]).applyMatrix4(_, o), a.normal.toArray(p, y), p[y + 3] = a.constant;
      }
      c.value = p, c.needsUpdate = !0;
    }
    return e.numPlanes = m, e.numIntersection = 0, p;
  }
}
function Vx(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(a, o) {
    return o === _a ? a.mapping = Xi : o === Mo && (a.mapping = Fr), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === _a || o === Mo)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return t(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const l = new nd(c.height / 2);
            return l.fromEquirectangularTexture(s, a), e.set(a, l), a.addEventListener("dispose", i), t(l.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function i(a) {
    const o = a.target;
    o.removeEventListener("dispose", i);
    const c = e.get(o);
    c !== void 0 && (e.delete(o), c.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class Ls extends Wl {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, r, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let r = n - e, a = n + e, o = i + t, c = i - t;
    if (this.view !== null && this.view.enabled) {
      const l = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += l * this.view.offsetX, a = r + l * this.view.width, o -= u * this.view.offsetY, c = o - u * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const ha = 4, _p = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], fs = 20, ju = /* @__PURE__ */ new Ls(), bp = /* @__PURE__ */ new Pe();
let Ju = null, Ku = 0, Zu = 0;
const us = (1 + Math.sqrt(5)) / 2, ea = 1 / us, yp = [
  /* @__PURE__ */ new P(1, 1, 1),
  /* @__PURE__ */ new P(-1, 1, 1),
  /* @__PURE__ */ new P(1, 1, -1),
  /* @__PURE__ */ new P(-1, 1, -1),
  /* @__PURE__ */ new P(0, us, ea),
  /* @__PURE__ */ new P(0, us, -ea),
  /* @__PURE__ */ new P(ea, 0, us),
  /* @__PURE__ */ new P(-ea, 0, us),
  /* @__PURE__ */ new P(us, ea, 0),
  /* @__PURE__ */ new P(-us, ea, 0)
];
class Sf {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    Ju = this._renderer.getRenderTarget(), Ku = this._renderer.getActiveCubeFace(), Zu = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = xp(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Ep(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Ju, Ku, Zu), e.scissorTest = !1, wc(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Xi || e.mapping === Fr ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Ju = this._renderer.getRenderTarget(), Ku = this._renderer.getActiveCubeFace(), Zu = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: wt,
      minFilter: wt,
      generateMipmaps: !1,
      type: Pn,
      format: dn,
      colorSpace: rn,
      depthBuffer: !1
    }, i = vp(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = vp(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Wx(r)), this._blurMaterial = qx(r, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Ne(this._lodPlanes[0], e);
    this._renderer.compile(t, ju);
  }
  _sceneToCubeUV(e, t, n, i) {
    const o = new _n(90, 1, t, n), c = [1, -1, 1, 1, 1, 1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, h = u.autoClear, f = u.toneMapping;
    u.getClearColor(bp), u.toneMapping = dr, u.autoClear = !1;
    const d = new In({
      name: "PMREM.Background",
      side: Fn,
      depthWrite: !1,
      depthTest: !1
    }), A = new Ne(new en(), d);
    let m = !1;
    const p = e.background;
    p ? p.isColor && (d.color.copy(p), e.background = null, m = !0) : (d.color.copy(bp), m = !0);
    for (let g = 0; g < 6; g++) {
      const _ = g % 3;
      _ === 0 ? (o.up.set(0, c[g], 0), o.lookAt(l[g], 0, 0)) : _ === 1 ? (o.up.set(0, 0, c[g]), o.lookAt(0, l[g], 0)) : (o.up.set(0, c[g], 0), o.lookAt(0, 0, l[g]));
      const b = this._cubeSize;
      wc(i, _ * b, g > 2 ? b : 0, b, b), u.setRenderTarget(i), m && u.render(A, o), u.render(e, o);
    }
    A.geometry.dispose(), A.material.dispose(), u.toneMapping = f, u.autoClear = h, e.background = p;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === Xi || e.mapping === Fr;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = xp()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ep());
    const r = i ? this._cubemapMaterial : this._equirectMaterial, a = new Ne(this._lodPlanes[0], r), o = r.uniforms;
    o.envMap.value = e;
    const c = this._cubeSize;
    wc(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(a, ju);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const r = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), a = yp[(i - 1) % yp.length];
      this._blur(e, i - 1, i, r, a);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, r) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      t,
      n,
      i,
      "latitudinal",
      r
    ), this._halfBlur(
      a,
      e,
      n,
      n,
      i,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, i, r, a, o) {
    const c = this._renderer, l = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const u = 3, h = new Ne(this._lodPlanes[i], l), f = l.uniforms, d = this._sizeLods[n] - 1, A = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * fs - 1), m = r / A, p = isFinite(r) ? 1 + Math.floor(u * m) : fs;
    p > fs && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${fs}`);
    const g = [];
    let _ = 0;
    for (let S = 0; S < fs; ++S) {
      const I = S / m, E = Math.exp(-I * I / 2);
      g.push(E), S === 0 ? _ += E : S < p && (_ += 2 * E);
    }
    for (let S = 0; S < g.length; S++)
      g[S] = g[S] / _;
    f.envMap.value = e.texture, f.samples.value = p, f.weights.value = g, f.latitudinal.value = a === "latitudinal", o && (f.poleAxis.value = o);
    const { _lodMax: b } = this;
    f.dTheta.value = A, f.mipInt.value = b - n;
    const y = this._sizeLods[i], v = 3 * y * (i > b - ha ? i - b + ha : 0), x = 4 * (this._cubeSize - y);
    wc(t, v, x, 3 * y, 2 * y), c.setRenderTarget(t), c.render(h, ju);
  }
}
function Wx(s) {
  const e = [], t = [], n = [];
  let i = s;
  const r = s - ha + 1 + _p.length;
  for (let a = 0; a < r; a++) {
    const o = Math.pow(2, i);
    t.push(o);
    let c = 1 / o;
    a > s - ha ? c = _p[a - s + ha - 1] : a === 0 && (c = 0), n.push(c);
    const l = 1 / (o - 2), u = -l, h = 1 + l, f = [u, u, h, u, h, h, u, u, h, h, u, h], d = 6, A = 6, m = 3, p = 2, g = 1, _ = new Float32Array(m * A * d), b = new Float32Array(p * A * d), y = new Float32Array(g * A * d);
    for (let x = 0; x < d; x++) {
      const S = x % 3 * 2 / 3 - 1, I = x > 2 ? 0 : -1, E = [
        S,
        I,
        0,
        S + 2 / 3,
        I,
        0,
        S + 2 / 3,
        I + 1,
        0,
        S,
        I,
        0,
        S + 2 / 3,
        I + 1,
        0,
        S,
        I + 1,
        0
      ];
      _.set(E, m * A * x), b.set(f, p * A * x);
      const M = [x, x, x, x, x, x];
      y.set(M, g * A * x);
    }
    const v = new ot();
    v.setAttribute("position", new ut(_, m)), v.setAttribute("uv", new ut(b, p)), v.setAttribute("faceIndex", new ut(y, g)), e.push(v), i > ha && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function vp(s, e, t) {
  const n = new pi(s, e, t);
  return n.texture.mapping = Ia, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function wc(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function qx(s, e, t) {
  const n = new Float32Array(fs), i = new P(0, 1, 0);
  return new Kn({
    name: "SphericalGaussianBlur",
    defines: {
      n: fs,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: id(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: fr,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ep() {
  return new Kn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: id(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: fr,
    depthTest: !1,
    depthWrite: !1
  });
}
function xp() {
  return new Kn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: id(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: fr,
    depthTest: !1,
    depthWrite: !1
  });
}
function id() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function Xx(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(o) {
    if (o && o.isTexture) {
      const c = o.mapping, l = c === _a || c === Mo, u = c === Xi || c === Fr;
      if (l || u)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let h = e.get(o);
          return t === null && (t = new Sf(s)), h = l ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), e.set(o, h), h.texture;
        } else {
          if (e.has(o))
            return e.get(o).texture;
          {
            const h = o.image;
            if (l && h && h.height > 0 || u && h && i(h)) {
              t === null && (t = new Sf(s));
              const f = l ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, f), o.addEventListener("dispose", r), f.texture;
            } else
              return null;
          }
        }
    }
    return o;
  }
  function i(o) {
    let c = 0;
    const l = 6;
    for (let u = 0; u < l; u++)
      o[u] !== void 0 && c++;
    return c === l;
  }
  function r(o) {
    const c = o.target;
    c.removeEventListener("dispose", r);
    const l = e.get(c);
    l !== void 0 && (e.delete(c), l.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: a
  };
}
function Yx(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const i = t(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function jx(s, e, t, n) {
  const i = {}, r = /* @__PURE__ */ new WeakMap();
  function a(h) {
    const f = h.target;
    f.index !== null && e.remove(f.index);
    for (const A in f.attributes)
      e.remove(f.attributes[A]);
    for (const A in f.morphAttributes) {
      const m = f.morphAttributes[A];
      for (let p = 0, g = m.length; p < g; p++)
        e.remove(m[p]);
    }
    f.removeEventListener("dispose", a), delete i[f.id];
    const d = r.get(f);
    d && (e.remove(d), r.delete(f)), n.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--;
  }
  function o(h, f) {
    return i[f.id] === !0 || (f.addEventListener("dispose", a), i[f.id] = !0, t.memory.geometries++), f;
  }
  function c(h) {
    const f = h.attributes;
    for (const A in f)
      e.update(f[A], s.ARRAY_BUFFER);
    const d = h.morphAttributes;
    for (const A in d) {
      const m = d[A];
      for (let p = 0, g = m.length; p < g; p++)
        e.update(m[p], s.ARRAY_BUFFER);
    }
  }
  function l(h) {
    const f = [], d = h.index, A = h.attributes.position;
    let m = 0;
    if (d !== null) {
      const _ = d.array;
      m = d.version;
      for (let b = 0, y = _.length; b < y; b += 3) {
        const v = _[b + 0], x = _[b + 1], S = _[b + 2];
        f.push(v, x, x, S, S, v);
      }
    } else if (A !== void 0) {
      const _ = A.array;
      m = A.version;
      for (let b = 0, y = _.length / 3 - 1; b < y; b += 3) {
        const v = b + 0, x = b + 1, S = b + 2;
        f.push(v, x, x, S, S, v);
      }
    } else
      return;
    const p = new (h0(f) ? ed : $f)(f, 1);
    p.version = m;
    const g = r.get(h);
    g && e.remove(g), r.set(h, p);
  }
  function u(h) {
    const f = r.get(h);
    if (f) {
      const d = h.index;
      d !== null && f.version < d.version && l(h);
    } else
      l(h);
    return r.get(h);
  }
  return {
    get: o,
    update: c,
    getWireframeAttribute: u
  };
}
function Jx(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function a(d) {
    r = d;
  }
  let o, c;
  function l(d) {
    o = d.type, c = d.bytesPerElement;
  }
  function u(d, A) {
    s.drawElements(r, A, o, d * c), t.update(A, r, 1);
  }
  function h(d, A, m) {
    if (m === 0)
      return;
    let p, g;
    if (i)
      p = s, g = "drawElementsInstanced";
    else if (p = e.get("ANGLE_instanced_arrays"), g = "drawElementsInstancedANGLE", p === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    p[g](r, A, o, d * c, m), t.update(A, r, m);
  }
  function f(d, A, m) {
    if (m === 0)
      return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null)
      for (let g = 0; g < m; g++)
        this.render(d[g] / c, A[g]);
    else {
      p.multiDrawElementsWEBGL(r, A, 0, o, d, 0, m);
      let g = 0;
      for (let _ = 0; _ < m; _++)
        g += A[_];
      t.update(g, r, 1);
    }
  }
  this.setMode = a, this.setIndex = l, this.render = u, this.renderInstances = h, this.renderMultiDraw = f;
}
function Kx(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, a, o) {
    switch (t.calls++, a) {
      case s.TRIANGLES:
        t.triangles += o * (r / 3);
        break;
      case s.LINES:
        t.lines += o * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += o * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += o * r;
        break;
      case s.POINTS:
        t.points += o * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function Zx(s, e) {
  return s[0] - e[0];
}
function $x(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function e1(s, e, t) {
  const n = {}, i = new Float32Array(8), r = /* @__PURE__ */ new WeakMap(), a = new Dt(), o = [];
  for (let l = 0; l < 8; l++)
    o[l] = [l, 0];
  function c(l, u, h) {
    const f = l.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const d = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color, A = d !== void 0 ? d.length : 0;
      let m = r.get(u);
      if (m === void 0 || m.count !== A) {
        let C = function() {
          D.dispose(), r.delete(u), u.removeEventListener("dispose", C);
        };
        m !== void 0 && m.texture.dispose();
        const _ = u.morphAttributes.position !== void 0, b = u.morphAttributes.normal !== void 0, y = u.morphAttributes.color !== void 0, v = u.morphAttributes.position || [], x = u.morphAttributes.normal || [], S = u.morphAttributes.color || [];
        let I = 0;
        _ === !0 && (I = 1), b === !0 && (I = 2), y === !0 && (I = 3);
        let E = u.attributes.position.count * I, M = 1;
        E > e.maxTextureSize && (M = Math.ceil(E / e.maxTextureSize), E = e.maxTextureSize);
        const T = new Float32Array(E * M * 4 * A), D = new Gl(T, E, M, A);
        D.type = pn, D.needsUpdate = !0;
        const F = I * 4;
        for (let R = 0; R < A; R++) {
          const O = v[R], V = x[R], q = S[R], z = E * M * 4 * R;
          for (let X = 0; X < O.count; X++) {
            const w = X * F;
            _ === !0 && (a.fromBufferAttribute(O, X), T[z + w + 0] = a.x, T[z + w + 1] = a.y, T[z + w + 2] = a.z, T[z + w + 3] = 0), b === !0 && (a.fromBufferAttribute(V, X), T[z + w + 4] = a.x, T[z + w + 5] = a.y, T[z + w + 6] = a.z, T[z + w + 7] = 0), y === !0 && (a.fromBufferAttribute(q, X), T[z + w + 8] = a.x, T[z + w + 9] = a.y, T[z + w + 10] = a.z, T[z + w + 11] = q.itemSize === 4 ? a.w : 1);
          }
        }
        m = {
          count: A,
          texture: D,
          size: new xe(E, M)
        }, r.set(u, m), u.addEventListener("dispose", C);
      }
      let p = 0;
      for (let _ = 0; _ < f.length; _++)
        p += f[_];
      const g = u.morphTargetsRelative ? 1 : 1 - p;
      h.getUniforms().setValue(s, "morphTargetBaseInfluence", g), h.getUniforms().setValue(s, "morphTargetInfluences", f), h.getUniforms().setValue(s, "morphTargetsTexture", m.texture, t), h.getUniforms().setValue(s, "morphTargetsTextureSize", m.size);
    } else {
      const d = f === void 0 ? 0 : f.length;
      let A = n[u.id];
      if (A === void 0 || A.length !== d) {
        A = [];
        for (let b = 0; b < d; b++)
          A[b] = [b, 0];
        n[u.id] = A;
      }
      for (let b = 0; b < d; b++) {
        const y = A[b];
        y[0] = b, y[1] = f[b];
      }
      A.sort($x);
      for (let b = 0; b < 8; b++)
        b < d && A[b][1] ? (o[b][0] = A[b][0], o[b][1] = A[b][1]) : (o[b][0] = Number.MAX_SAFE_INTEGER, o[b][1] = 0);
      o.sort(Zx);
      const m = u.morphAttributes.position, p = u.morphAttributes.normal;
      let g = 0;
      for (let b = 0; b < 8; b++) {
        const y = o[b], v = y[0], x = y[1];
        v !== Number.MAX_SAFE_INTEGER && x ? (m && u.getAttribute("morphTarget" + b) !== m[v] && u.setAttribute("morphTarget" + b, m[v]), p && u.getAttribute("morphNormal" + b) !== p[v] && u.setAttribute("morphNormal" + b, p[v]), i[b] = x, g += x) : (m && u.hasAttribute("morphTarget" + b) === !0 && u.deleteAttribute("morphTarget" + b), p && u.hasAttribute("morphNormal" + b) === !0 && u.deleteAttribute("morphNormal" + b), i[b] = 0);
      }
      const _ = u.morphTargetsRelative ? 1 : 1 - g;
      h.getUniforms().setValue(s, "morphTargetBaseInfluence", _), h.getUniforms().setValue(s, "morphTargetInfluences", i);
    }
  }
  return {
    update: c
  };
}
function t1(s, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function r(c) {
    const l = n.render.frame, u = c.geometry, h = e.get(c, u);
    if (i.get(h) !== l && (e.update(h), i.set(h, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), i.get(c) !== l && (t.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, s.ARRAY_BUFFER), i.set(c, l))), c.isSkinnedMesh) {
      const f = c.skeleton;
      i.get(f) !== l && (f.update(), i.set(f, l));
    }
    return h;
  }
  function a() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function o(c) {
    const l = c.target;
    l.removeEventListener("dispose", o), t.remove(l.instanceMatrix), l.instanceColor !== null && t.remove(l.instanceColor);
  }
  return {
    update: r,
    dispose: a
  };
}
class rd extends Jt {
  constructor(e, t, n, i, r, a, o, c, l, u) {
    if (u = u !== void 0 ? u : Lr, u !== Lr && u !== xs)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && u === Lr && (n = ur), n === void 0 && u === xs && (n = Dr), super(null, i, r, a, o, c, u, n, l), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : tn, this.minFilter = c !== void 0 ? c : tn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const m0 = /* @__PURE__ */ new Jt(), _0 = /* @__PURE__ */ new rd(1, 1);
_0.compareFunction = Jf;
const b0 = /* @__PURE__ */ new Gl(), y0 = /* @__PURE__ */ new zl(), v0 = /* @__PURE__ */ new Ta(), Sp = [], Cp = [], Mp = new Float32Array(16), Ip = new Float32Array(9), wp = new Float32Array(4);
function Ba(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0)
    return s;
  const i = e * t;
  let r = Sp[i];
  if (r === void 0 && (r = new Float32Array(i), Sp[i] = r), e !== 0) {
    n.toArray(r, 0);
    for (let a = 1, o = 0; a !== e; ++a)
      o += t, s[a].toArray(r, o);
  }
  return r;
}
function En(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0, n = s.length; t < n; t++)
    if (s[t] !== e[t])
      return !1;
  return !0;
}
function xn(s, e) {
  for (let t = 0, n = e.length; t < n; t++)
    s[t] = e[t];
}
function ql(s, e) {
  let t = Cp[e];
  t === void 0 && (t = new Int32Array(e), Cp[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = s.allocateTextureUnit();
  return t;
}
function n1(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function i1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (En(t, e))
      return;
    s.uniform2fv(this.addr, e), xn(t, e);
  }
}
function r1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (En(t, e))
      return;
    s.uniform3fv(this.addr, e), xn(t, e);
  }
}
function s1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (En(t, e))
      return;
    s.uniform4fv(this.addr, e), xn(t, e);
  }
}
function a1(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (En(t, e))
      return;
    s.uniformMatrix2fv(this.addr, !1, e), xn(t, e);
  } else {
    if (En(t, n))
      return;
    wp.set(n), s.uniformMatrix2fv(this.addr, !1, wp), xn(t, n);
  }
}
function o1(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (En(t, e))
      return;
    s.uniformMatrix3fv(this.addr, !1, e), xn(t, e);
  } else {
    if (En(t, n))
      return;
    Ip.set(n), s.uniformMatrix3fv(this.addr, !1, Ip), xn(t, n);
  }
}
function c1(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (En(t, e))
      return;
    s.uniformMatrix4fv(this.addr, !1, e), xn(t, e);
  } else {
    if (En(t, n))
      return;
    Mp.set(n), s.uniformMatrix4fv(this.addr, !1, Mp), xn(t, n);
  }
}
function l1(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function u1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (En(t, e))
      return;
    s.uniform2iv(this.addr, e), xn(t, e);
  }
}
function h1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (En(t, e))
      return;
    s.uniform3iv(this.addr, e), xn(t, e);
  }
}
function f1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (En(t, e))
      return;
    s.uniform4iv(this.addr, e), xn(t, e);
  }
}
function d1(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function p1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (En(t, e))
      return;
    s.uniform2uiv(this.addr, e), xn(t, e);
  }
}
function A1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (En(t, e))
      return;
    s.uniform3uiv(this.addr, e), xn(t, e);
  }
}
function g1(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (En(t, e))
      return;
    s.uniform4uiv(this.addr, e), xn(t, e);
  }
}
function m1(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
  const r = this.type === s.SAMPLER_2D_SHADOW ? _0 : m0;
  t.setTexture2D(e || r, i);
}
function _1(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || y0, i);
}
function b1(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || v0, i);
}
function y1(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || b0, i);
}
function v1(s) {
  switch (s) {
    case 5126:
      return n1;
    case 35664:
      return i1;
    case 35665:
      return r1;
    case 35666:
      return s1;
    case 35674:
      return a1;
    case 35675:
      return o1;
    case 35676:
      return c1;
    case 5124:
    case 35670:
      return l1;
    case 35667:
    case 35671:
      return u1;
    case 35668:
    case 35672:
      return h1;
    case 35669:
    case 35673:
      return f1;
    case 5125:
      return d1;
    case 36294:
      return p1;
    case 36295:
      return A1;
    case 36296:
      return g1;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return m1;
    case 35679:
    case 36299:
    case 36307:
      return _1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return b1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return y1;
  }
}
function E1(s, e) {
  s.uniform1fv(this.addr, e);
}
function x1(s, e) {
  const t = Ba(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function S1(s, e) {
  const t = Ba(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function C1(s, e) {
  const t = Ba(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function M1(s, e) {
  const t = Ba(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function I1(s, e) {
  const t = Ba(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function w1(s, e) {
  const t = Ba(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function T1(s, e) {
  s.uniform1iv(this.addr, e);
}
function B1(s, e) {
  s.uniform2iv(this.addr, e);
}
function R1(s, e) {
  s.uniform3iv(this.addr, e);
}
function D1(s, e) {
  s.uniform4iv(this.addr, e);
}
function L1(s, e) {
  s.uniform1uiv(this.addr, e);
}
function P1(s, e) {
  s.uniform2uiv(this.addr, e);
}
function U1(s, e) {
  s.uniform3uiv(this.addr, e);
}
function F1(s, e) {
  s.uniform4uiv(this.addr, e);
}
function k1(s, e, t) {
  const n = this.cache, i = e.length, r = ql(t, i);
  En(n, r) || (s.uniform1iv(this.addr, r), xn(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture2D(e[a] || m0, r[a]);
}
function N1(s, e, t) {
  const n = this.cache, i = e.length, r = ql(t, i);
  En(n, r) || (s.uniform1iv(this.addr, r), xn(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture3D(e[a] || y0, r[a]);
}
function O1(s, e, t) {
  const n = this.cache, i = e.length, r = ql(t, i);
  En(n, r) || (s.uniform1iv(this.addr, r), xn(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTextureCube(e[a] || v0, r[a]);
}
function Q1(s, e, t) {
  const n = this.cache, i = e.length, r = ql(t, i);
  En(n, r) || (s.uniform1iv(this.addr, r), xn(n, r));
  for (let a = 0; a !== i; ++a)
    t.setTexture2DArray(e[a] || b0, r[a]);
}
function G1(s) {
  switch (s) {
    case 5126:
      return E1;
    case 35664:
      return x1;
    case 35665:
      return S1;
    case 35666:
      return C1;
    case 35674:
      return M1;
    case 35675:
      return I1;
    case 35676:
      return w1;
    case 5124:
    case 35670:
      return T1;
    case 35667:
    case 35671:
      return B1;
    case 35668:
    case 35672:
      return R1;
    case 35669:
    case 35673:
      return D1;
    case 5125:
      return L1;
    case 36294:
      return P1;
    case 36295:
      return U1;
    case 36296:
      return F1;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return k1;
    case 35679:
    case 36299:
    case 36307:
      return N1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return O1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Q1;
  }
}
class z1 {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = v1(t.type);
  }
}
class H1 {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = G1(t.type);
  }
}
class V1 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, a = i.length; r !== a; ++r) {
      const o = i[r];
      o.setValue(e, t[o.id], n);
    }
  }
}
const $u = /(\w+)(\])?(\[|\.)?/g;
function Tp(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function W1(s, e, t) {
  const n = s.name, i = n.length;
  for ($u.lastIndex = 0; ; ) {
    const r = $u.exec(n), a = $u.lastIndex;
    let o = r[1];
    const c = r[2] === "]", l = r[3];
    if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === i) {
      Tp(t, l === void 0 ? new z1(o, s, e) : new H1(o, s, e));
      break;
    } else {
      let h = t.map[o];
      h === void 0 && (h = new V1(o), Tp(t, h)), t = h;
    }
  }
}
class fl {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i), a = e.getUniformLocation(t, r.name);
      W1(r, a, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, a = t.length; r !== a; ++r) {
      const o = t[r], c = n[o.id];
      c.needsUpdate !== !1 && o.setValue(e, c.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Bp(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const q1 = 37297;
let X1 = 0;
function Y1(s, e) {
  const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let a = i; a < r; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function j1(s) {
  const e = Tt.getPrimaries(Tt.workingColorSpace), t = Tt.getPrimaries(s);
  let n;
  switch (e === t ? n = "" : e === Do && t === Ro ? n = "LinearDisplayP3ToLinearSRGB" : e === Ro && t === Do && (n = "LinearSRGBToLinearDisplayP3"), s) {
    case rn:
    case wa:
      return [n, "LinearTransferOETF"];
    case Ot:
    case Ho:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
  }
}
function Rp(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
  if (n && i === "")
    return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const a = parseInt(r[1]);
    return t.toUpperCase() + `

` + i + `

` + Y1(s.getShaderSource(e), a);
  } else
    return i;
}
function J1(s, e) {
  const t = j1(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function K1(s, e) {
  let t;
  switch (e) {
    case Gm:
      t = "Linear";
      break;
    case zm:
      t = "Reinhard";
      break;
    case Hm:
      t = "OptimizedCineon";
      break;
    case Gf:
      t = "ACESFilmic";
      break;
    case Vm:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function Z1(s) {
  return [
    s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(ho).join(`
`);
}
function $1(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function eS(s, e) {
  const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i), a = r.name;
    let o = 1;
    r.type === s.FLOAT_MAT2 && (o = 2), r.type === s.FLOAT_MAT3 && (o = 3), r.type === s.FLOAT_MAT4 && (o = 4), t[a] = {
      type: r.type,
      location: s.getAttribLocation(e, a),
      locationSize: o
    };
  }
  return t;
}
function ho(s) {
  return s !== "";
}
function Dp(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Lp(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const tS = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Cf(s) {
  return s.replace(tS, iS);
}
const nS = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function iS(s, e) {
  let t = tt[e];
  if (t === void 0) {
    const n = nS.get(e);
    if (n !== void 0)
      t = tt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Cf(t);
}
const rS = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Pp(s) {
  return s.replace(rS, sS);
}
function sS(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function Up(s) {
  let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function aS(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === Qf ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === Pl ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Oi && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function oS(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Xi:
      case Fr:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ia:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function cS(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Fr:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function lS(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case zo:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Om:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Qm:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function uS(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function hS(s, e, t, n) {
  const i = s.getContext(), r = t.defines;
  let a = t.vertexShader, o = t.fragmentShader;
  const c = aS(t), l = oS(t), u = cS(t), h = lS(t), f = uS(t), d = t.isWebGL2 ? "" : Z1(t), A = $1(r), m = i.createProgram();
  let p, g, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (p = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    A
  ].filter(ho).join(`
`), p.length > 0 && (p += `
`), g = [
    d,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    A
  ].filter(ho).join(`
`), g.length > 0 && (g += `
`)) : (p = [
    Up(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    A,
    t.batching ? "#define USE_BATCHING" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + u : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ho).join(`
`), g = [
    d,
    Up(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    A,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + l : "",
    t.envMap ? "#define " + u : "",
    t.envMap ? "#define " + h : "",
    f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
    f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
    f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== dr ? "#define TONE_MAPPING" : "",
    t.toneMapping !== dr ? tt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== dr ? K1("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    tt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    J1("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(ho).join(`
`)), a = Cf(a), a = Dp(a, t), a = Lp(a, t), o = Cf(o), o = Dp(o, t), o = Lp(o, t), a = Pp(a), o = Pp(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, p = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + p, g = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === Ef ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Ef ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const b = _ + p + a, y = _ + g + o, v = Bp(i, i.VERTEX_SHADER, b), x = Bp(i, i.FRAGMENT_SHADER, y);
  i.attachShader(m, v), i.attachShader(m, x), t.index0AttributeName !== void 0 ? i.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m);
  function S(T) {
    if (s.debug.checkShaderErrors) {
      const D = i.getProgramInfoLog(m).trim(), F = i.getShaderInfoLog(v).trim(), C = i.getShaderInfoLog(x).trim();
      let R = !0, O = !0;
      if (i.getProgramParameter(m, i.LINK_STATUS) === !1)
        if (R = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(i, m, v, x);
        else {
          const V = Rp(i, v, "vertex"), q = Rp(i, x, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + `

Program Info Log: ` + D + `
` + V + `
` + q
          );
        }
      else
        D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (F === "" || C === "") && (O = !1);
      O && (T.diagnostics = {
        runnable: R,
        programLog: D,
        vertexShader: {
          log: F,
          prefix: p
        },
        fragmentShader: {
          log: C,
          prefix: g
        }
      });
    }
    i.deleteShader(v), i.deleteShader(x), I = new fl(i, m), E = eS(i, m);
  }
  let I;
  this.getUniforms = function() {
    return I === void 0 && S(this), I;
  };
  let E;
  this.getAttributes = function() {
    return E === void 0 && S(this), E;
  };
  let M = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return M === !1 && (M = i.getProgramParameter(m, q1)), M;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = X1++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = v, this.fragmentShader = x, this;
}
let fS = 0;
class dS {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), a = this._getShaderCacheForMaterial(e);
    return a.has(i) === !1 && (a.add(i), i.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new pS(e), t.set(e, n)), n;
  }
}
class pS {
  constructor(e) {
    this.id = fS++, this.code = e, this.usedTimes = 0;
  }
}
function AS(s, e, t, n, i, r, a) {
  const o = new Hl(), c = new dS(), l = [], u = i.isWebGL2, h = i.logarithmicDepthBuffer, f = i.vertexTextures;
  let d = i.precision;
  const A = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function m(E) {
    return E === 0 ? "uv" : `uv${E}`;
  }
  function p(E, M, T, D, F) {
    const C = D.fog, R = F.geometry, O = E.isMeshStandardMaterial ? D.environment : null, V = (E.isMeshStandardMaterial ? t : e).get(E.envMap || O), q = V && V.mapping === Ia ? V.image.height : null, z = A[E.type];
    E.precision !== null && (d = i.getMaxPrecision(E.precision), d !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", d, "instead."));
    const X = R.morphAttributes.position || R.morphAttributes.normal || R.morphAttributes.color, w = X !== void 0 ? X.length : 0;
    let N = 0;
    R.morphAttributes.position !== void 0 && (N = 1), R.morphAttributes.normal !== void 0 && (N = 2), R.morphAttributes.color !== void 0 && (N = 3);
    let H, j, $, ce;
    if (z) {
      const yt = Ri[z];
      H = yt.vertexShader, j = yt.fragmentShader;
    } else
      H = E.vertexShader, j = E.fragmentShader, c.update(E), $ = c.getVertexShaderID(E), ce = c.getFragmentShaderID(E);
    const ee = s.getRenderTarget(), le = F.isInstancedMesh === !0, Z = F.isBatchedMesh === !0, he = !!E.map, _e = !!E.matcap, U = !!V, ye = !!E.aoMap, ie = !!E.lightMap, re = !!E.bumpMap, te = !!E.normalMap, Ie = !!E.displacementMap, se = !!E.emissiveMap, K = !!E.metalnessMap, ve = !!E.roughnessMap, fe = E.anisotropy > 0, oe = E.clearcoat > 0, L = E.iridescence > 0, B = E.sheen > 0, W = E.transmission > 0, de = fe && !!E.anisotropyMap, Ae = oe && !!E.clearcoatMap, G = oe && !!E.clearcoatNormalMap, Ce = oe && !!E.clearcoatRoughnessMap, Se = L && !!E.iridescenceMap, De = L && !!E.iridescenceThicknessMap, Q = B && !!E.sheenColorMap, Me = B && !!E.sheenRoughnessMap, pe = !!E.specularMap, Le = !!E.specularColorMap, Fe = !!E.specularIntensityMap, Ge = W && !!E.transmissionMap, Ue = W && !!E.thicknessMap, we = !!E.gradientMap, Ye = !!E.alphaMap, J = E.alphaTest > 0, ke = !!E.alphaHash, Te = !!E.extensions, Ee = !!R.attributes.uv1, Re = !!R.attributes.uv2, Xe = !!R.attributes.uv3;
    let Ke = dr;
    return E.toneMapped && (ee === null || ee.isXRRenderTarget === !0) && (Ke = s.toneMapping), {
      isWebGL2: u,
      shaderID: z,
      shaderType: E.type,
      shaderName: E.name,
      vertexShader: H,
      fragmentShader: j,
      defines: E.defines,
      customVertexShaderID: $,
      customFragmentShaderID: ce,
      isRawShaderMaterial: E.isRawShaderMaterial === !0,
      glslVersion: E.glslVersion,
      precision: d,
      batching: Z,
      instancing: le,
      instancingColor: le && F.instanceColor !== null,
      supportsVertexTextures: f,
      outputColorSpace: ee === null ? s.outputColorSpace : ee.isXRRenderTarget === !0 ? ee.texture.colorSpace : rn,
      map: he,
      matcap: _e,
      envMap: U,
      envMapMode: U && V.mapping,
      envMapCubeUVHeight: q,
      aoMap: ye,
      lightMap: ie,
      bumpMap: re,
      normalMap: te,
      displacementMap: f && Ie,
      emissiveMap: se,
      normalMapObjectSpace: te && E.normalMapType === i0,
      normalMapTangentSpace: te && E.normalMapType === Gr,
      metalnessMap: K,
      roughnessMap: ve,
      anisotropy: fe,
      anisotropyMap: de,
      clearcoat: oe,
      clearcoatMap: Ae,
      clearcoatNormalMap: G,
      clearcoatRoughnessMap: Ce,
      iridescence: L,
      iridescenceMap: Se,
      iridescenceThicknessMap: De,
      sheen: B,
      sheenColorMap: Q,
      sheenRoughnessMap: Me,
      specularMap: pe,
      specularColorMap: Le,
      specularIntensityMap: Fe,
      transmission: W,
      transmissionMap: Ge,
      thicknessMap: Ue,
      gradientMap: we,
      opaque: E.transparent === !1 && E.blending === ys,
      alphaMap: Ye,
      alphaTest: J,
      alphaHash: ke,
      combine: E.combine,
      //
      mapUv: he && m(E.map.channel),
      aoMapUv: ye && m(E.aoMap.channel),
      lightMapUv: ie && m(E.lightMap.channel),
      bumpMapUv: re && m(E.bumpMap.channel),
      normalMapUv: te && m(E.normalMap.channel),
      displacementMapUv: Ie && m(E.displacementMap.channel),
      emissiveMapUv: se && m(E.emissiveMap.channel),
      metalnessMapUv: K && m(E.metalnessMap.channel),
      roughnessMapUv: ve && m(E.roughnessMap.channel),
      anisotropyMapUv: de && m(E.anisotropyMap.channel),
      clearcoatMapUv: Ae && m(E.clearcoatMap.channel),
      clearcoatNormalMapUv: G && m(E.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ce && m(E.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Se && m(E.iridescenceMap.channel),
      iridescenceThicknessMapUv: De && m(E.iridescenceThicknessMap.channel),
      sheenColorMapUv: Q && m(E.sheenColorMap.channel),
      sheenRoughnessMapUv: Me && m(E.sheenRoughnessMap.channel),
      specularMapUv: pe && m(E.specularMap.channel),
      specularColorMapUv: Le && m(E.specularColorMap.channel),
      specularIntensityMapUv: Fe && m(E.specularIntensityMap.channel),
      transmissionMapUv: Ge && m(E.transmissionMap.channel),
      thicknessMapUv: Ue && m(E.thicknessMap.channel),
      alphaMapUv: Ye && m(E.alphaMap.channel),
      //
      vertexTangents: !!R.attributes.tangent && (te || fe),
      vertexColors: E.vertexColors,
      vertexAlphas: E.vertexColors === !0 && !!R.attributes.color && R.attributes.color.itemSize === 4,
      vertexUv1s: Ee,
      vertexUv2s: Re,
      vertexUv3s: Xe,
      pointsUvs: F.isPoints === !0 && !!R.attributes.uv && (he || Ye),
      fog: !!C,
      useFog: E.fog === !0,
      fogExp2: C && C.isFogExp2,
      flatShading: E.flatShading === !0,
      sizeAttenuation: E.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: R.morphAttributes.position !== void 0,
      morphNormals: R.morphAttributes.normal !== void 0,
      morphColors: R.morphAttributes.color !== void 0,
      morphTargetsCount: w,
      morphTextureStride: N,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: E.dithering,
      shadowMapEnabled: s.shadowMap.enabled && T.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: Ke,
      useLegacyLights: s._useLegacyLights,
      decodeVideoTexture: he && E.map.isVideoTexture === !0 && Tt.getTransfer(E.map.colorSpace) === zt,
      premultipliedAlpha: E.premultipliedAlpha,
      doubleSided: E.side === Mn,
      flipSided: E.side === Fn,
      useDepthPacking: E.depthPacking >= 0,
      depthPacking: E.depthPacking || 0,
      index0AttributeName: E.index0AttributeName,
      extensionDerivatives: Te && E.extensions.derivatives === !0,
      extensionFragDepth: Te && E.extensions.fragDepth === !0,
      extensionDrawBuffers: Te && E.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Te && E.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: E.customProgramCacheKey()
    };
  }
  function g(E) {
    const M = [];
    if (E.shaderID ? M.push(E.shaderID) : (M.push(E.customVertexShaderID), M.push(E.customFragmentShaderID)), E.defines !== void 0)
      for (const T in E.defines)
        M.push(T), M.push(E.defines[T]);
    return E.isRawShaderMaterial === !1 && (_(M, E), b(M, E), M.push(s.outputColorSpace)), M.push(E.customProgramCacheKey), M.join();
  }
  function _(E, M) {
    E.push(M.precision), E.push(M.outputColorSpace), E.push(M.envMapMode), E.push(M.envMapCubeUVHeight), E.push(M.mapUv), E.push(M.alphaMapUv), E.push(M.lightMapUv), E.push(M.aoMapUv), E.push(M.bumpMapUv), E.push(M.normalMapUv), E.push(M.displacementMapUv), E.push(M.emissiveMapUv), E.push(M.metalnessMapUv), E.push(M.roughnessMapUv), E.push(M.anisotropyMapUv), E.push(M.clearcoatMapUv), E.push(M.clearcoatNormalMapUv), E.push(M.clearcoatRoughnessMapUv), E.push(M.iridescenceMapUv), E.push(M.iridescenceThicknessMapUv), E.push(M.sheenColorMapUv), E.push(M.sheenRoughnessMapUv), E.push(M.specularMapUv), E.push(M.specularColorMapUv), E.push(M.specularIntensityMapUv), E.push(M.transmissionMapUv), E.push(M.thicknessMapUv), E.push(M.combine), E.push(M.fogExp2), E.push(M.sizeAttenuation), E.push(M.morphTargetsCount), E.push(M.morphAttributeCount), E.push(M.numDirLights), E.push(M.numPointLights), E.push(M.numSpotLights), E.push(M.numSpotLightMaps), E.push(M.numHemiLights), E.push(M.numRectAreaLights), E.push(M.numDirLightShadows), E.push(M.numPointLightShadows), E.push(M.numSpotLightShadows), E.push(M.numSpotLightShadowsWithMaps), E.push(M.numLightProbes), E.push(M.shadowMapType), E.push(M.toneMapping), E.push(M.numClippingPlanes), E.push(M.numClipIntersection), E.push(M.depthPacking);
  }
  function b(E, M) {
    o.disableAll(), M.isWebGL2 && o.enable(0), M.supportsVertexTextures && o.enable(1), M.instancing && o.enable(2), M.instancingColor && o.enable(3), M.matcap && o.enable(4), M.envMap && o.enable(5), M.normalMapObjectSpace && o.enable(6), M.normalMapTangentSpace && o.enable(7), M.clearcoat && o.enable(8), M.iridescence && o.enable(9), M.alphaTest && o.enable(10), M.vertexColors && o.enable(11), M.vertexAlphas && o.enable(12), M.vertexUv1s && o.enable(13), M.vertexUv2s && o.enable(14), M.vertexUv3s && o.enable(15), M.vertexTangents && o.enable(16), M.anisotropy && o.enable(17), M.alphaHash && o.enable(18), M.batching && o.enable(19), E.push(o.mask), o.disableAll(), M.fog && o.enable(0), M.useFog && o.enable(1), M.flatShading && o.enable(2), M.logarithmicDepthBuffer && o.enable(3), M.skinning && o.enable(4), M.morphTargets && o.enable(5), M.morphNormals && o.enable(6), M.morphColors && o.enable(7), M.premultipliedAlpha && o.enable(8), M.shadowMapEnabled && o.enable(9), M.useLegacyLights && o.enable(10), M.doubleSided && o.enable(11), M.flipSided && o.enable(12), M.useDepthPacking && o.enable(13), M.dithering && o.enable(14), M.transmission && o.enable(15), M.sheen && o.enable(16), M.opaque && o.enable(17), M.pointsUvs && o.enable(18), M.decodeVideoTexture && o.enable(19), E.push(o.mask);
  }
  function y(E) {
    const M = A[E.type];
    let T;
    if (M) {
      const D = Ri[M];
      T = Vl.clone(D.uniforms);
    } else
      T = E.uniforms;
    return T;
  }
  function v(E, M) {
    let T;
    for (let D = 0, F = l.length; D < F; D++) {
      const C = l[D];
      if (C.cacheKey === M) {
        T = C, ++T.usedTimes;
        break;
      }
    }
    return T === void 0 && (T = new hS(s, M, E, r), l.push(T)), T;
  }
  function x(E) {
    if (--E.usedTimes === 0) {
      const M = l.indexOf(E);
      l[M] = l[l.length - 1], l.pop(), E.destroy();
    }
  }
  function S(E) {
    c.remove(E);
  }
  function I() {
    c.dispose();
  }
  return {
    getParameters: p,
    getProgramCacheKey: g,
    getUniforms: y,
    acquireProgram: v,
    releaseProgram: x,
    releaseShaderCache: S,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: l,
    dispose: I
  };
}
function gS() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let a = s.get(r);
    return a === void 0 && (a = {}, s.set(r, a)), a;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, a, o) {
    s.get(r)[a] = o;
  }
  function i() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function mS(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function Fp(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function kp() {
  const s = [];
  let e = 0;
  const t = [], n = [], i = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function a(h, f, d, A, m, p) {
    let g = s[e];
    return g === void 0 ? (g = {
      id: h.id,
      object: h,
      geometry: f,
      material: d,
      groupOrder: A,
      renderOrder: h.renderOrder,
      z: m,
      group: p
    }, s[e] = g) : (g.id = h.id, g.object = h, g.geometry = f, g.material = d, g.groupOrder = A, g.renderOrder = h.renderOrder, g.z = m, g.group = p), e++, g;
  }
  function o(h, f, d, A, m, p) {
    const g = a(h, f, d, A, m, p);
    d.transmission > 0 ? n.push(g) : d.transparent === !0 ? i.push(g) : t.push(g);
  }
  function c(h, f, d, A, m, p) {
    const g = a(h, f, d, A, m, p);
    d.transmission > 0 ? n.unshift(g) : d.transparent === !0 ? i.unshift(g) : t.unshift(g);
  }
  function l(h, f) {
    t.length > 1 && t.sort(h || mS), n.length > 1 && n.sort(f || Fp), i.length > 1 && i.sort(f || Fp);
  }
  function u() {
    for (let h = e, f = s.length; h < f; h++) {
      const d = s[h];
      if (d.id === null)
        break;
      d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: o,
    unshift: c,
    finish: u,
    sort: l
  };
}
function _S() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let a;
    return r === void 0 ? (a = new kp(), s.set(n, [a])) : i >= r.length ? (a = new kp(), r.push(a)) : a = r[i], a;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function bS() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new P(),
            color: new Pe()
          };
          break;
        case "SpotLight":
          t = {
            position: new P(),
            direction: new P(),
            color: new Pe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new P(),
            color: new Pe(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new P(),
            skyColor: new Pe(),
            groundColor: new Pe()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Pe(),
            position: new P(),
            halfWidth: new P(),
            halfHeight: new P()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function yS() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let vS = 0;
function ES(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function xS(s, e) {
  const t = new bS(), n = yS(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++)
    i.probe.push(new P());
  const r = new P(), a = new Je(), o = new Je();
  function c(u, h) {
    let f = 0, d = 0, A = 0;
    for (let D = 0; D < 9; D++)
      i.probe[D].set(0, 0, 0);
    let m = 0, p = 0, g = 0, _ = 0, b = 0, y = 0, v = 0, x = 0, S = 0, I = 0, E = 0;
    u.sort(ES);
    const M = h === !0 ? Math.PI : 1;
    for (let D = 0, F = u.length; D < F; D++) {
      const C = u[D], R = C.color, O = C.intensity, V = C.distance, q = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
      if (C.isAmbientLight)
        f += R.r * O * M, d += R.g * O * M, A += R.b * O * M;
      else if (C.isLightProbe) {
        for (let z = 0; z < 9; z++)
          i.probe[z].addScaledVector(C.sh.coefficients[z], O);
        E++;
      } else if (C.isDirectionalLight) {
        const z = t.get(C);
        if (z.color.copy(C.color).multiplyScalar(C.intensity * M), C.castShadow) {
          const X = C.shadow, w = n.get(C);
          w.shadowBias = X.bias, w.shadowNormalBias = X.normalBias, w.shadowRadius = X.radius, w.shadowMapSize = X.mapSize, i.directionalShadow[m] = w, i.directionalShadowMap[m] = q, i.directionalShadowMatrix[m] = C.shadow.matrix, y++;
        }
        i.directional[m] = z, m++;
      } else if (C.isSpotLight) {
        const z = t.get(C);
        z.position.setFromMatrixPosition(C.matrixWorld), z.color.copy(R).multiplyScalar(O * M), z.distance = V, z.coneCos = Math.cos(C.angle), z.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), z.decay = C.decay, i.spot[g] = z;
        const X = C.shadow;
        if (C.map && (i.spotLightMap[S] = C.map, S++, X.updateMatrices(C), C.castShadow && I++), i.spotLightMatrix[g] = X.matrix, C.castShadow) {
          const w = n.get(C);
          w.shadowBias = X.bias, w.shadowNormalBias = X.normalBias, w.shadowRadius = X.radius, w.shadowMapSize = X.mapSize, i.spotShadow[g] = w, i.spotShadowMap[g] = q, x++;
        }
        g++;
      } else if (C.isRectAreaLight) {
        const z = t.get(C);
        z.color.copy(R).multiplyScalar(O), z.halfWidth.set(C.width * 0.5, 0, 0), z.halfHeight.set(0, C.height * 0.5, 0), i.rectArea[_] = z, _++;
      } else if (C.isPointLight) {
        const z = t.get(C);
        if (z.color.copy(C.color).multiplyScalar(C.intensity * M), z.distance = C.distance, z.decay = C.decay, C.castShadow) {
          const X = C.shadow, w = n.get(C);
          w.shadowBias = X.bias, w.shadowNormalBias = X.normalBias, w.shadowRadius = X.radius, w.shadowMapSize = X.mapSize, w.shadowCameraNear = X.camera.near, w.shadowCameraFar = X.camera.far, i.pointShadow[p] = w, i.pointShadowMap[p] = q, i.pointShadowMatrix[p] = C.shadow.matrix, v++;
        }
        i.point[p] = z, p++;
      } else if (C.isHemisphereLight) {
        const z = t.get(C);
        z.skyColor.copy(C.color).multiplyScalar(O * M), z.groundColor.copy(C.groundColor).multiplyScalar(O * M), i.hemi[b] = z, b++;
      }
    }
    _ > 0 && (e.isWebGL2 || s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = He.LTC_FLOAT_1, i.rectAreaLTC2 = He.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = He.LTC_HALF_1, i.rectAreaLTC2 = He.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = f, i.ambient[1] = d, i.ambient[2] = A;
    const T = i.hash;
    (T.directionalLength !== m || T.pointLength !== p || T.spotLength !== g || T.rectAreaLength !== _ || T.hemiLength !== b || T.numDirectionalShadows !== y || T.numPointShadows !== v || T.numSpotShadows !== x || T.numSpotMaps !== S || T.numLightProbes !== E) && (i.directional.length = m, i.spot.length = g, i.rectArea.length = _, i.point.length = p, i.hemi.length = b, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = v, i.pointShadowMap.length = v, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = v, i.spotLightMatrix.length = x + S - I, i.spotLightMap.length = S, i.numSpotLightShadowsWithMaps = I, i.numLightProbes = E, T.directionalLength = m, T.pointLength = p, T.spotLength = g, T.rectAreaLength = _, T.hemiLength = b, T.numDirectionalShadows = y, T.numPointShadows = v, T.numSpotShadows = x, T.numSpotMaps = S, T.numLightProbes = E, i.version = vS++);
  }
  function l(u, h) {
    let f = 0, d = 0, A = 0, m = 0, p = 0;
    const g = h.matrixWorldInverse;
    for (let _ = 0, b = u.length; _ < b; _++) {
      const y = u[_];
      if (y.isDirectionalLight) {
        const v = i.directional[f];
        v.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), v.direction.sub(r), v.direction.transformDirection(g), f++;
      } else if (y.isSpotLight) {
        const v = i.spot[A];
        v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(g), v.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), v.direction.sub(r), v.direction.transformDirection(g), A++;
      } else if (y.isRectAreaLight) {
        const v = i.rectArea[m];
        v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(g), o.identity(), a.copy(y.matrixWorld), a.premultiply(g), o.extractRotation(a), v.halfWidth.set(y.width * 0.5, 0, 0), v.halfHeight.set(0, y.height * 0.5, 0), v.halfWidth.applyMatrix4(o), v.halfHeight.applyMatrix4(o), m++;
      } else if (y.isPointLight) {
        const v = i.point[d];
        v.position.setFromMatrixPosition(y.matrixWorld), v.position.applyMatrix4(g), d++;
      } else if (y.isHemisphereLight) {
        const v = i.hemi[p];
        v.direction.setFromMatrixPosition(y.matrixWorld), v.direction.transformDirection(g), p++;
      }
    }
  }
  return {
    setup: c,
    setupView: l,
    state: i
  };
}
function Np(s, e) {
  const t = new xS(s, e), n = [], i = [];
  function r() {
    n.length = 0, i.length = 0;
  }
  function a(h) {
    n.push(h);
  }
  function o(h) {
    i.push(h);
  }
  function c(h) {
    t.setup(n, h);
  }
  function l(h) {
    t.setupView(n, h);
  }
  return {
    init: r,
    state: {
      lightsArray: n,
      shadowsArray: i,
      lights: t
    },
    setupLights: c,
    setupLightsView: l,
    pushLight: a,
    pushShadow: o
  };
}
function SS(s, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(r, a = 0) {
    const o = t.get(r);
    let c;
    return o === void 0 ? (c = new Np(s, e), t.set(r, [c])) : a >= o.length ? (c = new Np(s, e), o.push(c)) : c = o[a], c;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Wo extends vn {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = n0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Xl extends vn {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const CS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, MS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function IS(s, e, t) {
  let n = new Vo();
  const i = new xe(), r = new xe(), a = new Dt(), o = new Wo({ depthPacking: Ql }), c = new Xl(), l = {}, u = t.maxTextureSize, h = { [mi]: Fn, [Fn]: mi, [Mn]: Mn }, f = new Kn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new xe() },
      radius: { value: 4 }
    },
    vertexShader: CS,
    fragmentShader: MS
  }), d = f.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const A = new ot();
  A.setAttribute(
    "position",
    new ut(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const m = new Ne(A, f), p = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Qf;
  let g = this.type;
  this.render = function(v, x, S) {
    if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || v.length === 0)
      return;
    const I = s.getRenderTarget(), E = s.getActiveCubeFace(), M = s.getActiveMipmapLevel(), T = s.state;
    T.setBlending(fr), T.buffers.color.setClear(1, 1, 1, 1), T.buffers.depth.setTest(!0), T.setScissorTest(!1);
    const D = g !== Oi && this.type === Oi, F = g === Oi && this.type !== Oi;
    for (let C = 0, R = v.length; C < R; C++) {
      const O = v[C], V = O.shadow;
      if (V === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (V.autoUpdate === !1 && V.needsUpdate === !1)
        continue;
      i.copy(V.mapSize);
      const q = V.getFrameExtents();
      if (i.multiply(q), r.copy(V.mapSize), (i.x > u || i.y > u) && (i.x > u && (r.x = Math.floor(u / q.x), i.x = r.x * q.x, V.mapSize.x = r.x), i.y > u && (r.y = Math.floor(u / q.y), i.y = r.y * q.y, V.mapSize.y = r.y)), V.map === null || D === !0 || F === !0) {
        const X = this.type !== Oi ? { minFilter: tn, magFilter: tn } : {};
        V.map !== null && V.map.dispose(), V.map = new pi(i.x, i.y, X), V.map.texture.name = O.name + ".shadowMap", V.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(V.map), s.clear();
      const z = V.getViewportCount();
      for (let X = 0; X < z; X++) {
        const w = V.getViewport(X);
        a.set(
          r.x * w.x,
          r.y * w.y,
          r.x * w.z,
          r.y * w.w
        ), T.viewport(a), V.updateMatrices(O, X), n = V.getFrustum(), y(x, S, V.camera, O, this.type);
      }
      V.isPointLightShadow !== !0 && this.type === Oi && _(V, S), V.needsUpdate = !1;
    }
    g = this.type, p.needsUpdate = !1, s.setRenderTarget(I, E, M);
  };
  function _(v, x) {
    const S = e.update(m);
    f.defines.VSM_SAMPLES !== v.blurSamples && (f.defines.VSM_SAMPLES = v.blurSamples, d.defines.VSM_SAMPLES = v.blurSamples, f.needsUpdate = !0, d.needsUpdate = !0), v.mapPass === null && (v.mapPass = new pi(i.x, i.y)), f.uniforms.shadow_pass.value = v.map.texture, f.uniforms.resolution.value = v.mapSize, f.uniforms.radius.value = v.radius, s.setRenderTarget(v.mapPass), s.clear(), s.renderBufferDirect(x, null, S, f, m, null), d.uniforms.shadow_pass.value = v.mapPass.texture, d.uniforms.resolution.value = v.mapSize, d.uniforms.radius.value = v.radius, s.setRenderTarget(v.map), s.clear(), s.renderBufferDirect(x, null, S, d, m, null);
  }
  function b(v, x, S, I) {
    let E = null;
    const M = S.isPointLight === !0 ? v.customDistanceMaterial : v.customDepthMaterial;
    if (M !== void 0)
      E = M;
    else if (E = S.isPointLight === !0 ? c : o, s.localClippingEnabled && x.clipShadows === !0 && Array.isArray(x.clippingPlanes) && x.clippingPlanes.length !== 0 || x.displacementMap && x.displacementScale !== 0 || x.alphaMap && x.alphaTest > 0 || x.map && x.alphaTest > 0) {
      const T = E.uuid, D = x.uuid;
      let F = l[T];
      F === void 0 && (F = {}, l[T] = F);
      let C = F[D];
      C === void 0 && (C = E.clone(), F[D] = C), E = C;
    }
    if (E.visible = x.visible, E.wireframe = x.wireframe, I === Oi ? E.side = x.shadowSide !== null ? x.shadowSide : x.side : E.side = x.shadowSide !== null ? x.shadowSide : h[x.side], E.alphaMap = x.alphaMap, E.alphaTest = x.alphaTest, E.map = x.map, E.clipShadows = x.clipShadows, E.clippingPlanes = x.clippingPlanes, E.clipIntersection = x.clipIntersection, E.displacementMap = x.displacementMap, E.displacementScale = x.displacementScale, E.displacementBias = x.displacementBias, E.wireframeLinewidth = x.wireframeLinewidth, E.linewidth = x.linewidth, S.isPointLight === !0 && E.isMeshDistanceMaterial === !0) {
      const T = s.properties.get(E);
      T.light = S;
    }
    return E;
  }
  function y(v, x, S, I, E) {
    if (v.visible === !1)
      return;
    if (v.layers.test(x.layers) && (v.isMesh || v.isLine || v.isPoints) && (v.castShadow || v.receiveShadow && E === Oi) && (!v.frustumCulled || n.intersectsObject(v))) {
      v.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, v.matrixWorld);
      const D = e.update(v), F = v.material;
      if (Array.isArray(F)) {
        const C = D.groups;
        for (let R = 0, O = C.length; R < O; R++) {
          const V = C[R], q = F[V.materialIndex];
          if (q && q.visible) {
            const z = b(v, q, I, E);
            v.onBeforeShadow(s, v, x, S, D, z, V), s.renderBufferDirect(S, null, D, z, v, V), v.onAfterShadow(s, v, x, S, D, z, V);
          }
        }
      } else if (F.visible) {
        const C = b(v, F, I, E);
        v.onBeforeShadow(s, v, x, S, D, C, null), s.renderBufferDirect(S, null, D, C, v, null), v.onAfterShadow(s, v, x, S, D, C, null);
      }
    }
    const T = v.children;
    for (let D = 0, F = T.length; D < F; D++)
      y(T[D], x, S, I, E);
  }
}
function wS(s, e, t) {
  const n = t.isWebGL2;
  function i() {
    let J = !1;
    const ke = new Dt();
    let Te = null;
    const Ee = new Dt(0, 0, 0, 0);
    return {
      setMask: function(Re) {
        Te !== Re && !J && (s.colorMask(Re, Re, Re, Re), Te = Re);
      },
      setLocked: function(Re) {
        J = Re;
      },
      setClear: function(Re, Xe, Ke, Xt, yt) {
        yt === !0 && (Re *= Xt, Xe *= Xt, Ke *= Xt), ke.set(Re, Xe, Ke, Xt), Ee.equals(ke) === !1 && (s.clearColor(Re, Xe, Ke, Xt), Ee.copy(ke));
      },
      reset: function() {
        J = !1, Te = null, Ee.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let J = !1, ke = null, Te = null, Ee = null;
    return {
      setTest: function(Re) {
        Re ? Z(s.DEPTH_TEST) : he(s.DEPTH_TEST);
      },
      setMask: function(Re) {
        ke !== Re && !J && (s.depthMask(Re), ke = Re);
      },
      setFunc: function(Re) {
        if (Te !== Re) {
          switch (Re) {
            case Dm:
              s.depthFunc(s.NEVER);
              break;
            case Lm:
              s.depthFunc(s.ALWAYS);
              break;
            case Pm:
              s.depthFunc(s.LESS);
              break;
            case Co:
              s.depthFunc(s.LEQUAL);
              break;
            case Um:
              s.depthFunc(s.EQUAL);
              break;
            case Fm:
              s.depthFunc(s.GEQUAL);
              break;
            case km:
              s.depthFunc(s.GREATER);
              break;
            case Nm:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Te = Re;
        }
      },
      setLocked: function(Re) {
        J = Re;
      },
      setClear: function(Re) {
        Ee !== Re && (s.clearDepth(Re), Ee = Re);
      },
      reset: function() {
        J = !1, ke = null, Te = null, Ee = null;
      }
    };
  }
  function a() {
    let J = !1, ke = null, Te = null, Ee = null, Re = null, Xe = null, Ke = null, Xt = null, yt = null;
    return {
      setTest: function(nt) {
        J || (nt ? Z(s.STENCIL_TEST) : he(s.STENCIL_TEST));
      },
      setMask: function(nt) {
        ke !== nt && !J && (s.stencilMask(nt), ke = nt);
      },
      setFunc: function(nt, kt, Yt) {
        (Te !== nt || Ee !== kt || Re !== Yt) && (s.stencilFunc(nt, kt, Yt), Te = nt, Ee = kt, Re = Yt);
      },
      setOp: function(nt, kt, Yt) {
        (Xe !== nt || Ke !== kt || Xt !== Yt) && (s.stencilOp(nt, kt, Yt), Xe = nt, Ke = kt, Xt = Yt);
      },
      setLocked: function(nt) {
        J = nt;
      },
      setClear: function(nt) {
        yt !== nt && (s.clearStencil(nt), yt = nt);
      },
      reset: function() {
        J = !1, ke = null, Te = null, Ee = null, Re = null, Xe = null, Ke = null, Xt = null, yt = null;
      }
    };
  }
  const o = new i(), c = new r(), l = new a(), u = /* @__PURE__ */ new WeakMap(), h = /* @__PURE__ */ new WeakMap();
  let f = {}, d = {}, A = /* @__PURE__ */ new WeakMap(), m = [], p = null, g = !1, _ = null, b = null, y = null, v = null, x = null, S = null, I = null, E = new Pe(0, 0, 0), M = 0, T = !1, D = null, F = null, C = null, R = null, O = null;
  const V = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let q = !1, z = 0;
  const X = s.getParameter(s.VERSION);
  X.indexOf("WebGL") !== -1 ? (z = parseFloat(/^WebGL (\d)/.exec(X)[1]), q = z >= 1) : X.indexOf("OpenGL ES") !== -1 && (z = parseFloat(/^OpenGL ES (\d)/.exec(X)[1]), q = z >= 2);
  let w = null, N = {};
  const H = s.getParameter(s.SCISSOR_BOX), j = s.getParameter(s.VIEWPORT), $ = new Dt().fromArray(H), ce = new Dt().fromArray(j);
  function ee(J, ke, Te, Ee) {
    const Re = new Uint8Array(4), Xe = s.createTexture();
    s.bindTexture(J, Xe), s.texParameteri(J, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(J, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let Ke = 0; Ke < Te; Ke++)
      n && (J === s.TEXTURE_3D || J === s.TEXTURE_2D_ARRAY) ? s.texImage3D(ke, 0, s.RGBA, 1, 1, Ee, 0, s.RGBA, s.UNSIGNED_BYTE, Re) : s.texImage2D(ke + Ke, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, Re);
    return Xe;
  }
  const le = {};
  le[s.TEXTURE_2D] = ee(s.TEXTURE_2D, s.TEXTURE_2D, 1), le[s.TEXTURE_CUBE_MAP] = ee(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (le[s.TEXTURE_2D_ARRAY] = ee(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), le[s.TEXTURE_3D] = ee(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), Z(s.DEPTH_TEST), c.setFunc(Co), se(!1), K(Xh), Z(s.CULL_FACE), te(fr);
  function Z(J) {
    f[J] !== !0 && (s.enable(J), f[J] = !0);
  }
  function he(J) {
    f[J] !== !1 && (s.disable(J), f[J] = !1);
  }
  function _e(J, ke) {
    return d[J] !== ke ? (s.bindFramebuffer(J, ke), d[J] = ke, n && (J === s.DRAW_FRAMEBUFFER && (d[s.FRAMEBUFFER] = ke), J === s.FRAMEBUFFER && (d[s.DRAW_FRAMEBUFFER] = ke)), !0) : !1;
  }
  function U(J, ke) {
    let Te = m, Ee = !1;
    if (J)
      if (Te = A.get(ke), Te === void 0 && (Te = [], A.set(ke, Te)), J.isWebGLMultipleRenderTargets) {
        const Re = J.texture;
        if (Te.length !== Re.length || Te[0] !== s.COLOR_ATTACHMENT0) {
          for (let Xe = 0, Ke = Re.length; Xe < Ke; Xe++)
            Te[Xe] = s.COLOR_ATTACHMENT0 + Xe;
          Te.length = Re.length, Ee = !0;
        }
      } else
        Te[0] !== s.COLOR_ATTACHMENT0 && (Te[0] = s.COLOR_ATTACHMENT0, Ee = !0);
    else
      Te[0] !== s.BACK && (Te[0] = s.BACK, Ee = !0);
    Ee && (t.isWebGL2 ? s.drawBuffers(Te) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Te));
  }
  function ye(J) {
    return p !== J ? (s.useProgram(J), p = J, !0) : !1;
  }
  const ie = {
    [Br]: s.FUNC_ADD,
    [mm]: s.FUNC_SUBTRACT,
    [_m]: s.FUNC_REVERSE_SUBTRACT
  };
  if (n)
    ie[Kh] = s.MIN, ie[Zh] = s.MAX;
  else {
    const J = e.get("EXT_blend_minmax");
    J !== null && (ie[Kh] = J.MIN_EXT, ie[Zh] = J.MAX_EXT);
  }
  const re = {
    [bm]: s.ZERO,
    [ym]: s.ONE,
    [vm]: s.SRC_COLOR,
    [vl]: s.SRC_ALPHA,
    [Im]: s.SRC_ALPHA_SATURATE,
    [Cm]: s.DST_COLOR,
    [xm]: s.DST_ALPHA,
    [Em]: s.ONE_MINUS_SRC_COLOR,
    [El]: s.ONE_MINUS_SRC_ALPHA,
    [Mm]: s.ONE_MINUS_DST_COLOR,
    [Sm]: s.ONE_MINUS_DST_ALPHA,
    [wm]: s.CONSTANT_COLOR,
    [Tm]: s.ONE_MINUS_CONSTANT_COLOR,
    [Bm]: s.CONSTANT_ALPHA,
    [Rm]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function te(J, ke, Te, Ee, Re, Xe, Ke, Xt, yt, nt) {
    if (J === fr) {
      g === !0 && (he(s.BLEND), g = !1);
      return;
    }
    if (g === !1 && (Z(s.BLEND), g = !0), J !== gm) {
      if (J !== _ || nt !== T) {
        if ((b !== Br || x !== Br) && (s.blendEquation(s.FUNC_ADD), b = Br, x = Br), nt)
          switch (J) {
            case ys:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case Yh:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case jh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Jh:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
        else
          switch (J) {
            case ys:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case Yh:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case jh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Jh:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
        y = null, v = null, S = null, I = null, E.set(0, 0, 0), M = 0, _ = J, T = nt;
      }
      return;
    }
    Re = Re || ke, Xe = Xe || Te, Ke = Ke || Ee, (ke !== b || Re !== x) && (s.blendEquationSeparate(ie[ke], ie[Re]), b = ke, x = Re), (Te !== y || Ee !== v || Xe !== S || Ke !== I) && (s.blendFuncSeparate(re[Te], re[Ee], re[Xe], re[Ke]), y = Te, v = Ee, S = Xe, I = Ke), (Xt.equals(E) === !1 || yt !== M) && (s.blendColor(Xt.r, Xt.g, Xt.b, yt), E.copy(Xt), M = yt), _ = J, T = !1;
  }
  function Ie(J, ke) {
    J.side === Mn ? he(s.CULL_FACE) : Z(s.CULL_FACE);
    let Te = J.side === Fn;
    ke && (Te = !Te), se(Te), J.blending === ys && J.transparent === !1 ? te(fr) : te(J.blending, J.blendEquation, J.blendSrc, J.blendDst, J.blendEquationAlpha, J.blendSrcAlpha, J.blendDstAlpha, J.blendColor, J.blendAlpha, J.premultipliedAlpha), c.setFunc(J.depthFunc), c.setTest(J.depthTest), c.setMask(J.depthWrite), o.setMask(J.colorWrite);
    const Ee = J.stencilWrite;
    l.setTest(Ee), Ee && (l.setMask(J.stencilWriteMask), l.setFunc(J.stencilFunc, J.stencilRef, J.stencilFuncMask), l.setOp(J.stencilFail, J.stencilZFail, J.stencilZPass)), fe(J.polygonOffset, J.polygonOffsetFactor, J.polygonOffsetUnits), J.alphaToCoverage === !0 ? Z(s.SAMPLE_ALPHA_TO_COVERAGE) : he(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function se(J) {
    D !== J && (J ? s.frontFace(s.CW) : s.frontFace(s.CCW), D = J);
  }
  function K(J) {
    J !== pm ? (Z(s.CULL_FACE), J !== F && (J === Xh ? s.cullFace(s.BACK) : J === Am ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : he(s.CULL_FACE), F = J;
  }
  function ve(J) {
    J !== C && (q && s.lineWidth(J), C = J);
  }
  function fe(J, ke, Te) {
    J ? (Z(s.POLYGON_OFFSET_FILL), (R !== ke || O !== Te) && (s.polygonOffset(ke, Te), R = ke, O = Te)) : he(s.POLYGON_OFFSET_FILL);
  }
  function oe(J) {
    J ? Z(s.SCISSOR_TEST) : he(s.SCISSOR_TEST);
  }
  function L(J) {
    J === void 0 && (J = s.TEXTURE0 + V - 1), w !== J && (s.activeTexture(J), w = J);
  }
  function B(J, ke, Te) {
    Te === void 0 && (w === null ? Te = s.TEXTURE0 + V - 1 : Te = w);
    let Ee = N[Te];
    Ee === void 0 && (Ee = { type: void 0, texture: void 0 }, N[Te] = Ee), (Ee.type !== J || Ee.texture !== ke) && (w !== Te && (s.activeTexture(Te), w = Te), s.bindTexture(J, ke || le[J]), Ee.type = J, Ee.texture = ke);
  }
  function W() {
    const J = N[w];
    J !== void 0 && J.type !== void 0 && (s.bindTexture(J.type, null), J.type = void 0, J.texture = void 0);
  }
  function de() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Ae() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function G() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Ce() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Se() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function De() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Q() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Me() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function pe() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Le() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (J) {
      console.error("THREE.WebGLState:", J);
    }
  }
  function Fe(J) {
    $.equals(J) === !1 && (s.scissor(J.x, J.y, J.z, J.w), $.copy(J));
  }
  function Ge(J) {
    ce.equals(J) === !1 && (s.viewport(J.x, J.y, J.z, J.w), ce.copy(J));
  }
  function Ue(J, ke) {
    let Te = h.get(ke);
    Te === void 0 && (Te = /* @__PURE__ */ new WeakMap(), h.set(ke, Te));
    let Ee = Te.get(J);
    Ee === void 0 && (Ee = s.getUniformBlockIndex(ke, J.name), Te.set(J, Ee));
  }
  function we(J, ke) {
    const Ee = h.get(ke).get(J);
    u.get(ke) !== Ee && (s.uniformBlockBinding(ke, Ee, J.__bindingPointIndex), u.set(ke, Ee));
  }
  function Ye() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), n === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), f = {}, w = null, N = {}, d = {}, A = /* @__PURE__ */ new WeakMap(), m = [], p = null, g = !1, _ = null, b = null, y = null, v = null, x = null, S = null, I = null, E = new Pe(0, 0, 0), M = 0, T = !1, D = null, F = null, C = null, R = null, O = null, $.set(0, 0, s.canvas.width, s.canvas.height), ce.set(0, 0, s.canvas.width, s.canvas.height), o.reset(), c.reset(), l.reset();
  }
  return {
    buffers: {
      color: o,
      depth: c,
      stencil: l
    },
    enable: Z,
    disable: he,
    bindFramebuffer: _e,
    drawBuffers: U,
    useProgram: ye,
    setBlending: te,
    setMaterial: Ie,
    setFlipSided: se,
    setCullFace: K,
    setLineWidth: ve,
    setPolygonOffset: fe,
    setScissorTest: oe,
    activeTexture: L,
    bindTexture: B,
    unbindTexture: W,
    compressedTexImage2D: de,
    compressedTexImage3D: Ae,
    texImage2D: pe,
    texImage3D: Le,
    updateUBOMapping: Ue,
    uniformBlockBinding: we,
    texStorage2D: Q,
    texStorage3D: Me,
    texSubImage2D: G,
    texSubImage3D: Ce,
    compressedTexSubImage2D: Se,
    compressedTexSubImage3D: De,
    scissor: Fe,
    viewport: Ge,
    reset: Ye
  };
}
function TS(s, e, t, n, i, r, a) {
  const o = i.isWebGL2, c = i.maxTextures, l = i.maxCubemapSize, u = i.maxTextureSize, h = i.maxSamples, f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, d = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), A = /* @__PURE__ */ new WeakMap();
  let m;
  const p = /* @__PURE__ */ new WeakMap();
  let g = !1;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function _(L, B) {
    return g ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(L, B)
    ) : Po("canvas");
  }
  function b(L, B, W, de) {
    let Ae = 1;
    if ((L.width > de || L.height > de) && (Ae = de / Math.max(L.width, L.height)), Ae < 1 || B === !0)
      if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap) {
        const G = B ? Bl : Math.floor, Ce = G(Ae * L.width), Se = G(Ae * L.height);
        m === void 0 && (m = _(Ce, Se));
        const De = W ? _(Ce, Se) : m;
        return De.width = Ce, De.height = Se, De.getContext("2d").drawImage(L, 0, 0, Ce, Se), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + L.width + "x" + L.height + ") to (" + Ce + "x" + Se + ")."), De;
      } else
        return "data" in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + L.width + "x" + L.height + ")."), L;
    return L;
  }
  function y(L) {
    return xf(L.width) && xf(L.height);
  }
  function v(L) {
    return o ? !1 : L.wrapS !== Ln || L.wrapT !== Ln || L.minFilter !== tn && L.minFilter !== wt;
  }
  function x(L, B) {
    return L.generateMipmaps && B && L.minFilter !== tn && L.minFilter !== wt;
  }
  function S(L) {
    s.generateMipmap(L);
  }
  function I(L, B, W, de, Ae = !1) {
    if (o === !1)
      return B;
    if (L !== null) {
      if (s[L] !== void 0)
        return s[L];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'");
    }
    let G = B;
    if (B === s.RED && (W === s.FLOAT && (G = s.R32F), W === s.HALF_FLOAT && (G = s.R16F), W === s.UNSIGNED_BYTE && (G = s.R8)), B === s.RED_INTEGER && (W === s.UNSIGNED_BYTE && (G = s.R8UI), W === s.UNSIGNED_SHORT && (G = s.R16UI), W === s.UNSIGNED_INT && (G = s.R32UI), W === s.BYTE && (G = s.R8I), W === s.SHORT && (G = s.R16I), W === s.INT && (G = s.R32I)), B === s.RG && (W === s.FLOAT && (G = s.RG32F), W === s.HALF_FLOAT && (G = s.RG16F), W === s.UNSIGNED_BYTE && (G = s.RG8)), B === s.RGBA) {
      const Ce = Ae ? Bo : Tt.getTransfer(de);
      W === s.FLOAT && (G = s.RGBA32F), W === s.HALF_FLOAT && (G = s.RGBA16F), W === s.UNSIGNED_BYTE && (G = Ce === zt ? s.SRGB8_ALPHA8 : s.RGBA8), W === s.UNSIGNED_SHORT_4_4_4_4 && (G = s.RGBA4), W === s.UNSIGNED_SHORT_5_5_5_1 && (G = s.RGB5_A1);
    }
    return (G === s.R16F || G === s.R32F || G === s.RG16F || G === s.RG32F || G === s.RGBA16F || G === s.RGBA32F) && e.get("EXT_color_buffer_float"), G;
  }
  function E(L, B, W) {
    return x(L, W) === !0 || L.isFramebufferTexture && L.minFilter !== tn && L.minFilter !== wt ? Math.log2(Math.max(B.width, B.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? B.mipmaps.length : 1;
  }
  function M(L) {
    return L === tn || L === Io || L === Aa ? s.NEAREST : s.LINEAR;
  }
  function T(L) {
    const B = L.target;
    B.removeEventListener("dispose", T), F(B), B.isVideoTexture && A.delete(B);
  }
  function D(L) {
    const B = L.target;
    B.removeEventListener("dispose", D), R(B);
  }
  function F(L) {
    const B = n.get(L);
    if (B.__webglInit === void 0)
      return;
    const W = L.source, de = p.get(W);
    if (de) {
      const Ae = de[B.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && C(L), Object.keys(de).length === 0 && p.delete(W);
    }
    n.remove(L);
  }
  function C(L) {
    const B = n.get(L);
    s.deleteTexture(B.__webglTexture);
    const W = L.source, de = p.get(W);
    delete de[B.__cacheKey], a.memory.textures--;
  }
  function R(L) {
    const B = L.texture, W = n.get(L), de = n.get(B);
    if (de.__webglTexture !== void 0 && (s.deleteTexture(de.__webglTexture), a.memory.textures--), L.depthTexture && L.depthTexture.dispose(), L.isWebGLCubeRenderTarget)
      for (let Ae = 0; Ae < 6; Ae++) {
        if (Array.isArray(W.__webglFramebuffer[Ae]))
          for (let G = 0; G < W.__webglFramebuffer[Ae].length; G++)
            s.deleteFramebuffer(W.__webglFramebuffer[Ae][G]);
        else
          s.deleteFramebuffer(W.__webglFramebuffer[Ae]);
        W.__webglDepthbuffer && s.deleteRenderbuffer(W.__webglDepthbuffer[Ae]);
      }
    else {
      if (Array.isArray(W.__webglFramebuffer))
        for (let Ae = 0; Ae < W.__webglFramebuffer.length; Ae++)
          s.deleteFramebuffer(W.__webglFramebuffer[Ae]);
      else
        s.deleteFramebuffer(W.__webglFramebuffer);
      if (W.__webglDepthbuffer && s.deleteRenderbuffer(W.__webglDepthbuffer), W.__webglMultisampledFramebuffer && s.deleteFramebuffer(W.__webglMultisampledFramebuffer), W.__webglColorRenderbuffer)
        for (let Ae = 0; Ae < W.__webglColorRenderbuffer.length; Ae++)
          W.__webglColorRenderbuffer[Ae] && s.deleteRenderbuffer(W.__webglColorRenderbuffer[Ae]);
      W.__webglDepthRenderbuffer && s.deleteRenderbuffer(W.__webglDepthRenderbuffer);
    }
    if (L.isWebGLMultipleRenderTargets)
      for (let Ae = 0, G = B.length; Ae < G; Ae++) {
        const Ce = n.get(B[Ae]);
        Ce.__webglTexture && (s.deleteTexture(Ce.__webglTexture), a.memory.textures--), n.remove(B[Ae]);
      }
    n.remove(B), n.remove(L);
  }
  let O = 0;
  function V() {
    O = 0;
  }
  function q() {
    const L = O;
    return L >= c && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + c), O += 1, L;
  }
  function z(L) {
    const B = [];
    return B.push(L.wrapS), B.push(L.wrapT), B.push(L.wrapR || 0), B.push(L.magFilter), B.push(L.minFilter), B.push(L.anisotropy), B.push(L.internalFormat), B.push(L.format), B.push(L.type), B.push(L.generateMipmaps), B.push(L.premultiplyAlpha), B.push(L.flipY), B.push(L.unpackAlignment), B.push(L.colorSpace), B.join();
  }
  function X(L, B) {
    const W = n.get(L);
    if (L.isVideoTexture && fe(L), L.isRenderTargetTexture === !1 && L.version > 0 && W.__version !== L.version) {
      const de = L.image;
      if (de === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (de.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Z(W, L, B);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, W.__webglTexture, s.TEXTURE0 + B);
  }
  function w(L, B) {
    const W = n.get(L);
    if (L.version > 0 && W.__version !== L.version) {
      Z(W, L, B);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, W.__webglTexture, s.TEXTURE0 + B);
  }
  function N(L, B) {
    const W = n.get(L);
    if (L.version > 0 && W.__version !== L.version) {
      Z(W, L, B);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, W.__webglTexture, s.TEXTURE0 + B);
  }
  function H(L, B) {
    const W = n.get(L);
    if (L.version > 0 && W.__version !== L.version) {
      he(W, L, B);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, W.__webglTexture, s.TEXTURE0 + B);
  }
  const j = {
    [Ar]: s.REPEAT,
    [Ln]: s.CLAMP_TO_EDGE,
    [ba]: s.MIRRORED_REPEAT
  }, $ = {
    [tn]: s.NEAREST,
    [Io]: s.NEAREST_MIPMAP_NEAREST,
    [Aa]: s.NEAREST_MIPMAP_LINEAR,
    [wt]: s.LINEAR,
    [Fl]: s.LINEAR_MIPMAP_NEAREST,
    [_i]: s.LINEAR_MIPMAP_LINEAR
  }, ce = {
    [r0]: s.NEVER,
    [u0]: s.ALWAYS,
    [s0]: s.LESS,
    [Jf]: s.LEQUAL,
    [a0]: s.EQUAL,
    [l0]: s.GEQUAL,
    [o0]: s.GREATER,
    [c0]: s.NOTEQUAL
  };
  function ee(L, B, W) {
    if (W ? (s.texParameteri(L, s.TEXTURE_WRAP_S, j[B.wrapS]), s.texParameteri(L, s.TEXTURE_WRAP_T, j[B.wrapT]), (L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY) && s.texParameteri(L, s.TEXTURE_WRAP_R, j[B.wrapR]), s.texParameteri(L, s.TEXTURE_MAG_FILTER, $[B.magFilter]), s.texParameteri(L, s.TEXTURE_MIN_FILTER, $[B.minFilter])) : (s.texParameteri(L, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(L, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), (L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY) && s.texParameteri(L, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE), (B.wrapS !== Ln || B.wrapT !== Ln) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(L, s.TEXTURE_MAG_FILTER, M(B.magFilter)), s.texParameteri(L, s.TEXTURE_MIN_FILTER, M(B.minFilter)), B.minFilter !== tn && B.minFilter !== wt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), B.compareFunction && (s.texParameteri(L, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(L, s.TEXTURE_COMPARE_FUNC, ce[B.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const de = e.get("EXT_texture_filter_anisotropic");
      if (B.magFilter === tn || B.minFilter !== Aa && B.minFilter !== _i || B.type === pn && e.has("OES_texture_float_linear") === !1 || o === !1 && B.type === Pn && e.has("OES_texture_half_float_linear") === !1)
        return;
      (B.anisotropy > 1 || n.get(B).__currentAnisotropy) && (s.texParameterf(L, de.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(B.anisotropy, i.getMaxAnisotropy())), n.get(B).__currentAnisotropy = B.anisotropy);
    }
  }
  function le(L, B) {
    let W = !1;
    L.__webglInit === void 0 && (L.__webglInit = !0, B.addEventListener("dispose", T));
    const de = B.source;
    let Ae = p.get(de);
    Ae === void 0 && (Ae = {}, p.set(de, Ae));
    const G = z(B);
    if (G !== L.__cacheKey) {
      Ae[G] === void 0 && (Ae[G] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, W = !0), Ae[G].usedTimes++;
      const Ce = Ae[L.__cacheKey];
      Ce !== void 0 && (Ae[L.__cacheKey].usedTimes--, Ce.usedTimes === 0 && C(B)), L.__cacheKey = G, L.__webglTexture = Ae[G].texture;
    }
    return W;
  }
  function Z(L, B, W) {
    let de = s.TEXTURE_2D;
    (B.isDataArrayTexture || B.isCompressedArrayTexture) && (de = s.TEXTURE_2D_ARRAY), B.isData3DTexture && (de = s.TEXTURE_3D);
    const Ae = le(L, B), G = B.source;
    t.bindTexture(de, L.__webglTexture, s.TEXTURE0 + W);
    const Ce = n.get(G);
    if (G.version !== Ce.__version || Ae === !0) {
      t.activeTexture(s.TEXTURE0 + W);
      const Se = Tt.getPrimaries(Tt.workingColorSpace), De = B.colorSpace === jn ? null : Tt.getPrimaries(B.colorSpace), Q = B.colorSpace === jn || Se === De ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, B.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, B.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Q);
      const Me = v(B) && y(B.image) === !1;
      let pe = b(B.image, Me, !1, u);
      pe = oe(B, pe);
      const Le = y(pe) || o, Fe = r.convert(B.format, B.colorSpace);
      let Ge = r.convert(B.type), Ue = I(B.internalFormat, Fe, Ge, B.colorSpace, B.isVideoTexture);
      ee(de, B, Le);
      let we;
      const Ye = B.mipmaps, J = o && B.isVideoTexture !== !0 && Ue !== Nl, ke = Ce.__version === void 0 || Ae === !0, Te = E(B, pe, Le);
      if (B.isDepthTexture)
        Ue = s.DEPTH_COMPONENT, o ? B.type === pn ? Ue = s.DEPTH_COMPONENT32F : B.type === ur ? Ue = s.DEPTH_COMPONENT24 : B.type === Dr ? Ue = s.DEPTH24_STENCIL8 : Ue = s.DEPTH_COMPONENT16 : B.type === pn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), B.format === Lr && Ue === s.DEPTH_COMPONENT && B.type !== kl && B.type !== ur && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), B.type = ur, Ge = r.convert(B.type)), B.format === xs && Ue === s.DEPTH_COMPONENT && (Ue = s.DEPTH_STENCIL, B.type !== Dr && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), B.type = Dr, Ge = r.convert(B.type))), ke && (J ? t.texStorage2D(s.TEXTURE_2D, 1, Ue, pe.width, pe.height) : t.texImage2D(s.TEXTURE_2D, 0, Ue, pe.width, pe.height, 0, Fe, Ge, null));
      else if (B.isDataTexture)
        if (Ye.length > 0 && Le) {
          J && ke && t.texStorage2D(s.TEXTURE_2D, Te, Ue, Ye[0].width, Ye[0].height);
          for (let Ee = 0, Re = Ye.length; Ee < Re; Ee++)
            we = Ye[Ee], J ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, we.width, we.height, Fe, Ge, we.data) : t.texImage2D(s.TEXTURE_2D, Ee, Ue, we.width, we.height, 0, Fe, Ge, we.data);
          B.generateMipmaps = !1;
        } else
          J ? (ke && t.texStorage2D(s.TEXTURE_2D, Te, Ue, pe.width, pe.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, pe.width, pe.height, Fe, Ge, pe.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ue, pe.width, pe.height, 0, Fe, Ge, pe.data);
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          J && ke && t.texStorage3D(s.TEXTURE_2D_ARRAY, Te, Ue, Ye[0].width, Ye[0].height, pe.depth);
          for (let Ee = 0, Re = Ye.length; Ee < Re; Ee++)
            we = Ye[Ee], B.format !== dn ? Fe !== null ? J ? t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, we.width, we.height, pe.depth, Fe, we.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, Ee, Ue, we.width, we.height, pe.depth, 0, we.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : J ? t.texSubImage3D(s.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, we.width, we.height, pe.depth, Fe, Ge, we.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, Ee, Ue, we.width, we.height, pe.depth, 0, Fe, Ge, we.data);
        } else {
          J && ke && t.texStorage2D(s.TEXTURE_2D, Te, Ue, Ye[0].width, Ye[0].height);
          for (let Ee = 0, Re = Ye.length; Ee < Re; Ee++)
            we = Ye[Ee], B.format !== dn ? Fe !== null ? J ? t.compressedTexSubImage2D(s.TEXTURE_2D, Ee, 0, 0, we.width, we.height, Fe, we.data) : t.compressedTexImage2D(s.TEXTURE_2D, Ee, Ue, we.width, we.height, 0, we.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : J ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, we.width, we.height, Fe, Ge, we.data) : t.texImage2D(s.TEXTURE_2D, Ee, Ue, we.width, we.height, 0, Fe, Ge, we.data);
        }
      else if (B.isDataArrayTexture)
        J ? (ke && t.texStorage3D(s.TEXTURE_2D_ARRAY, Te, Ue, pe.width, pe.height, pe.depth), t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Fe, Ge, pe.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ue, pe.width, pe.height, pe.depth, 0, Fe, Ge, pe.data);
      else if (B.isData3DTexture)
        J ? (ke && t.texStorage3D(s.TEXTURE_3D, Te, Ue, pe.width, pe.height, pe.depth), t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, pe.width, pe.height, pe.depth, Fe, Ge, pe.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ue, pe.width, pe.height, pe.depth, 0, Fe, Ge, pe.data);
      else if (B.isFramebufferTexture) {
        if (ke)
          if (J)
            t.texStorage2D(s.TEXTURE_2D, Te, Ue, pe.width, pe.height);
          else {
            let Ee = pe.width, Re = pe.height;
            for (let Xe = 0; Xe < Te; Xe++)
              t.texImage2D(s.TEXTURE_2D, Xe, Ue, Ee, Re, 0, Fe, Ge, null), Ee >>= 1, Re >>= 1;
          }
      } else if (Ye.length > 0 && Le) {
        J && ke && t.texStorage2D(s.TEXTURE_2D, Te, Ue, Ye[0].width, Ye[0].height);
        for (let Ee = 0, Re = Ye.length; Ee < Re; Ee++)
          we = Ye[Ee], J ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, Fe, Ge, we) : t.texImage2D(s.TEXTURE_2D, Ee, Ue, Fe, Ge, we);
        B.generateMipmaps = !1;
      } else
        J ? (ke && t.texStorage2D(s.TEXTURE_2D, Te, Ue, pe.width, pe.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Fe, Ge, pe)) : t.texImage2D(s.TEXTURE_2D, 0, Ue, Fe, Ge, pe);
      x(B, Le) && S(de), Ce.__version = G.version, B.onUpdate && B.onUpdate(B);
    }
    L.__version = B.version;
  }
  function he(L, B, W) {
    if (B.image.length !== 6)
      return;
    const de = le(L, B), Ae = B.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, L.__webglTexture, s.TEXTURE0 + W);
    const G = n.get(Ae);
    if (Ae.version !== G.__version || de === !0) {
      t.activeTexture(s.TEXTURE0 + W);
      const Ce = Tt.getPrimaries(Tt.workingColorSpace), Se = B.colorSpace === jn ? null : Tt.getPrimaries(B.colorSpace), De = B.colorSpace === jn || Ce === Se ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, B.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, B.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, De);
      const Q = B.isCompressedTexture || B.image[0].isCompressedTexture, Me = B.image[0] && B.image[0].isDataTexture, pe = [];
      for (let Ee = 0; Ee < 6; Ee++)
        !Q && !Me ? pe[Ee] = b(B.image[Ee], !1, !0, l) : pe[Ee] = Me ? B.image[Ee].image : B.image[Ee], pe[Ee] = oe(B, pe[Ee]);
      const Le = pe[0], Fe = y(Le) || o, Ge = r.convert(B.format, B.colorSpace), Ue = r.convert(B.type), we = I(B.internalFormat, Ge, Ue, B.colorSpace), Ye = o && B.isVideoTexture !== !0, J = G.__version === void 0 || de === !0;
      let ke = E(B, Le, Fe);
      ee(s.TEXTURE_CUBE_MAP, B, Fe);
      let Te;
      if (Q) {
        Ye && J && t.texStorage2D(s.TEXTURE_CUBE_MAP, ke, we, Le.width, Le.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          Te = pe[Ee].mipmaps;
          for (let Re = 0; Re < Te.length; Re++) {
            const Xe = Te[Re];
            B.format !== dn ? Ge !== null ? Ye ? t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re, 0, 0, Xe.width, Xe.height, Ge, Xe.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re, we, Xe.width, Xe.height, 0, Xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ye ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re, 0, 0, Xe.width, Xe.height, Ge, Ue, Xe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re, we, Xe.width, Xe.height, 0, Ge, Ue, Xe.data);
          }
        }
      } else {
        Te = B.mipmaps, Ye && J && (Te.length > 0 && ke++, t.texStorage2D(s.TEXTURE_CUBE_MAP, ke, we, pe[0].width, pe[0].height));
        for (let Ee = 0; Ee < 6; Ee++)
          if (Me) {
            Ye ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, pe[Ee].width, pe[Ee].height, Ge, Ue, pe[Ee].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, we, pe[Ee].width, pe[Ee].height, 0, Ge, Ue, pe[Ee].data);
            for (let Re = 0; Re < Te.length; Re++) {
              const Ke = Te[Re].image[Ee].image;
              Ye ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re + 1, 0, 0, Ke.width, Ke.height, Ge, Ue, Ke.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re + 1, we, Ke.width, Ke.height, 0, Ge, Ue, Ke.data);
            }
          } else {
            Ye ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, Ge, Ue, pe[Ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, we, Ge, Ue, pe[Ee]);
            for (let Re = 0; Re < Te.length; Re++) {
              const Xe = Te[Re];
              Ye ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re + 1, 0, 0, Ge, Ue, Xe.image[Ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Re + 1, we, Ge, Ue, Xe.image[Ee]);
            }
          }
      }
      x(B, Fe) && S(s.TEXTURE_CUBE_MAP), G.__version = Ae.version, B.onUpdate && B.onUpdate(B);
    }
    L.__version = B.version;
  }
  function _e(L, B, W, de, Ae, G) {
    const Ce = r.convert(W.format, W.colorSpace), Se = r.convert(W.type), De = I(W.internalFormat, Ce, Se, W.colorSpace);
    if (!n.get(B).__hasExternalTextures) {
      const Me = Math.max(1, B.width >> G), pe = Math.max(1, B.height >> G);
      Ae === s.TEXTURE_3D || Ae === s.TEXTURE_2D_ARRAY ? t.texImage3D(Ae, G, De, Me, pe, B.depth, 0, Ce, Se, null) : t.texImage2D(Ae, G, De, Me, pe, 0, Ce, Se, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, L), ve(B) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, de, Ae, n.get(W).__webglTexture, 0, K(B)) : (Ae === s.TEXTURE_2D || Ae >= s.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, de, Ae, n.get(W).__webglTexture, G), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function U(L, B, W) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, L), B.depthBuffer && !B.stencilBuffer) {
      let de = o === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
      if (W || ve(B)) {
        const Ae = B.depthTexture;
        Ae && Ae.isDepthTexture && (Ae.type === pn ? de = s.DEPTH_COMPONENT32F : Ae.type === ur && (de = s.DEPTH_COMPONENT24));
        const G = K(B);
        ve(B) ? f.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, G, de, B.width, B.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, G, de, B.width, B.height);
      } else
        s.renderbufferStorage(s.RENDERBUFFER, de, B.width, B.height);
      s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, L);
    } else if (B.depthBuffer && B.stencilBuffer) {
      const de = K(B);
      W && ve(B) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, de, s.DEPTH24_STENCIL8, B.width, B.height) : ve(B) ? f.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, de, s.DEPTH24_STENCIL8, B.width, B.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, B.width, B.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, L);
    } else {
      const de = B.isWebGLMultipleRenderTargets === !0 ? B.texture : [B.texture];
      for (let Ae = 0; Ae < de.length; Ae++) {
        const G = de[Ae], Ce = r.convert(G.format, G.colorSpace), Se = r.convert(G.type), De = I(G.internalFormat, Ce, Se, G.colorSpace), Q = K(B);
        W && ve(B) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Q, De, B.width, B.height) : ve(B) ? f.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Q, De, B.width, B.height) : s.renderbufferStorage(s.RENDERBUFFER, De, B.width, B.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function ye(L, B) {
    if (B && B.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, L), !(B.depthTexture && B.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(B.depthTexture).__webglTexture || B.depthTexture.image.width !== B.width || B.depthTexture.image.height !== B.height) && (B.depthTexture.image.width = B.width, B.depthTexture.image.height = B.height, B.depthTexture.needsUpdate = !0), X(B.depthTexture, 0);
    const de = n.get(B.depthTexture).__webglTexture, Ae = K(B);
    if (B.depthTexture.format === Lr)
      ve(B) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, de, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, de, 0);
    else if (B.depthTexture.format === xs)
      ve(B) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, de, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, de, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ie(L) {
    const B = n.get(L), W = L.isWebGLCubeRenderTarget === !0;
    if (L.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (W)
        throw new Error("target.depthTexture not supported in Cube render targets");
      ye(B.__webglFramebuffer, L);
    } else if (W) {
      B.__webglDepthbuffer = [];
      for (let de = 0; de < 6; de++)
        t.bindFramebuffer(s.FRAMEBUFFER, B.__webglFramebuffer[de]), B.__webglDepthbuffer[de] = s.createRenderbuffer(), U(B.__webglDepthbuffer[de], L, !1);
    } else
      t.bindFramebuffer(s.FRAMEBUFFER, B.__webglFramebuffer), B.__webglDepthbuffer = s.createRenderbuffer(), U(B.__webglDepthbuffer, L, !1);
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function re(L, B, W) {
    const de = n.get(L);
    B !== void 0 && _e(de.__webglFramebuffer, L, L.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), W !== void 0 && ie(L);
  }
  function te(L) {
    const B = L.texture, W = n.get(L), de = n.get(B);
    L.addEventListener("dispose", D), L.isWebGLMultipleRenderTargets !== !0 && (de.__webglTexture === void 0 && (de.__webglTexture = s.createTexture()), de.__version = B.version, a.memory.textures++);
    const Ae = L.isWebGLCubeRenderTarget === !0, G = L.isWebGLMultipleRenderTargets === !0, Ce = y(L) || o;
    if (Ae) {
      W.__webglFramebuffer = [];
      for (let Se = 0; Se < 6; Se++)
        if (o && B.mipmaps && B.mipmaps.length > 0) {
          W.__webglFramebuffer[Se] = [];
          for (let De = 0; De < B.mipmaps.length; De++)
            W.__webglFramebuffer[Se][De] = s.createFramebuffer();
        } else
          W.__webglFramebuffer[Se] = s.createFramebuffer();
    } else {
      if (o && B.mipmaps && B.mipmaps.length > 0) {
        W.__webglFramebuffer = [];
        for (let Se = 0; Se < B.mipmaps.length; Se++)
          W.__webglFramebuffer[Se] = s.createFramebuffer();
      } else
        W.__webglFramebuffer = s.createFramebuffer();
      if (G)
        if (i.drawBuffers) {
          const Se = L.texture;
          for (let De = 0, Q = Se.length; De < Q; De++) {
            const Me = n.get(Se[De]);
            Me.__webglTexture === void 0 && (Me.__webglTexture = s.createTexture(), a.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && L.samples > 0 && ve(L) === !1) {
        const Se = G ? B : [B];
        W.__webglMultisampledFramebuffer = s.createFramebuffer(), W.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
        for (let De = 0; De < Se.length; De++) {
          const Q = Se[De];
          W.__webglColorRenderbuffer[De] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, W.__webglColorRenderbuffer[De]);
          const Me = r.convert(Q.format, Q.colorSpace), pe = r.convert(Q.type), Le = I(Q.internalFormat, Me, pe, Q.colorSpace, L.isXRRenderTarget === !0), Fe = K(L);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Fe, Le, L.width, L.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + De, s.RENDERBUFFER, W.__webglColorRenderbuffer[De]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), L.depthBuffer && (W.__webglDepthRenderbuffer = s.createRenderbuffer(), U(W.__webglDepthRenderbuffer, L, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (Ae) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, de.__webglTexture), ee(s.TEXTURE_CUBE_MAP, B, Ce);
      for (let Se = 0; Se < 6; Se++)
        if (o && B.mipmaps && B.mipmaps.length > 0)
          for (let De = 0; De < B.mipmaps.length; De++)
            _e(W.__webglFramebuffer[Se][De], L, B, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Se, De);
        else
          _e(W.__webglFramebuffer[Se], L, B, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Se, 0);
      x(B, Ce) && S(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (G) {
      const Se = L.texture;
      for (let De = 0, Q = Se.length; De < Q; De++) {
        const Me = Se[De], pe = n.get(Me);
        t.bindTexture(s.TEXTURE_2D, pe.__webglTexture), ee(s.TEXTURE_2D, Me, Ce), _e(W.__webglFramebuffer, L, Me, s.COLOR_ATTACHMENT0 + De, s.TEXTURE_2D, 0), x(Me, Ce) && S(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Se = s.TEXTURE_2D;
      if ((L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (o ? Se = L.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Se, de.__webglTexture), ee(Se, B, Ce), o && B.mipmaps && B.mipmaps.length > 0)
        for (let De = 0; De < B.mipmaps.length; De++)
          _e(W.__webglFramebuffer[De], L, B, s.COLOR_ATTACHMENT0, Se, De);
      else
        _e(W.__webglFramebuffer, L, B, s.COLOR_ATTACHMENT0, Se, 0);
      x(B, Ce) && S(Se), t.unbindTexture();
    }
    L.depthBuffer && ie(L);
  }
  function Ie(L) {
    const B = y(L) || o, W = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
    for (let de = 0, Ae = W.length; de < Ae; de++) {
      const G = W[de];
      if (x(G, B)) {
        const Ce = L.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, Se = n.get(G).__webglTexture;
        t.bindTexture(Ce, Se), S(Ce), t.unbindTexture();
      }
    }
  }
  function se(L) {
    if (o && L.samples > 0 && ve(L) === !1) {
      const B = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture], W = L.width, de = L.height;
      let Ae = s.COLOR_BUFFER_BIT;
      const G = [], Ce = L.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Se = n.get(L), De = L.isWebGLMultipleRenderTargets === !0;
      if (De)
        for (let Q = 0; Q < B.length; Q++)
          t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Q, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Q, s.TEXTURE_2D, null, 0);
      t.bindFramebuffer(s.READ_FRAMEBUFFER, Se.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Se.__webglFramebuffer);
      for (let Q = 0; Q < B.length; Q++) {
        G.push(s.COLOR_ATTACHMENT0 + Q), L.depthBuffer && G.push(Ce);
        const Me = Se.__ignoreDepthValues !== void 0 ? Se.__ignoreDepthValues : !1;
        if (Me === !1 && (L.depthBuffer && (Ae |= s.DEPTH_BUFFER_BIT), L.stencilBuffer && (Ae |= s.STENCIL_BUFFER_BIT)), De && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Se.__webglColorRenderbuffer[Q]), Me === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [Ce]), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [Ce])), De) {
          const pe = n.get(B[Q]).__webglTexture;
          s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, pe, 0);
        }
        s.blitFramebuffer(0, 0, W, de, 0, 0, W, de, Ae, s.NEAREST), d && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, G);
      }
      if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), De)
        for (let Q = 0; Q < B.length; Q++) {
          t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Q, s.RENDERBUFFER, Se.__webglColorRenderbuffer[Q]);
          const Me = n.get(B[Q]).__webglTexture;
          t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Q, s.TEXTURE_2D, Me, 0);
        }
      t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Se.__webglMultisampledFramebuffer);
    }
  }
  function K(L) {
    return Math.min(h, L.samples);
  }
  function ve(L) {
    const B = n.get(L);
    return o && L.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && B.__useRenderToTexture !== !1;
  }
  function fe(L) {
    const B = a.render.frame;
    A.get(L) !== B && (A.set(L, B), L.update());
  }
  function oe(L, B) {
    const W = L.colorSpace, de = L.format, Ae = L.type;
    return L.isCompressedTexture === !0 || L.isVideoTexture === !0 || L.format === Tl || W !== rn && W !== jn && (Tt.getTransfer(W) === zt ? o === !1 ? e.has("EXT_sRGB") === !0 && de === dn ? (L.format = Tl, L.minFilter = wt, L.generateMipmaps = !1) : B = Zf.sRGBToLinear(B) : (de !== dn || Ae !== fn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), B;
  }
  this.allocateTextureUnit = q, this.resetTextureUnits = V, this.setTexture2D = X, this.setTexture2DArray = w, this.setTexture3D = N, this.setTextureCube = H, this.rebindTextures = re, this.setupRenderTarget = te, this.updateRenderTargetMipmap = Ie, this.updateMultisampleRenderTarget = se, this.setupDepthRenderbuffer = ie, this.setupFrameBufferTexture = _e, this.useMultisampledRTT = ve;
}
function E0(s, e, t) {
  const n = t.isWebGL2;
  function i(r, a = jn) {
    let o;
    const c = Tt.getTransfer(a);
    if (r === fn)
      return s.UNSIGNED_BYTE;
    if (r === Hf)
      return s.UNSIGNED_SHORT_4_4_4_4;
    if (r === Vf)
      return s.UNSIGNED_SHORT_5_5_5_1;
    if (r === qm)
      return s.BYTE;
    if (r === Xm)
      return s.SHORT;
    if (r === kl)
      return s.UNSIGNED_SHORT;
    if (r === zf)
      return s.INT;
    if (r === ur)
      return s.UNSIGNED_INT;
    if (r === pn)
      return s.FLOAT;
    if (r === Pn)
      return n ? s.HALF_FLOAT : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (r === Ym)
      return s.ALPHA;
    if (r === dn)
      return s.RGBA;
    if (r === jm)
      return s.LUMINANCE;
    if (r === Jm)
      return s.LUMINANCE_ALPHA;
    if (r === Lr)
      return s.DEPTH_COMPONENT;
    if (r === xs)
      return s.DEPTH_STENCIL;
    if (r === Tl)
      return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (r === ps)
      return s.RED;
    if (r === Wf)
      return s.RED_INTEGER;
    if (r === As)
      return s.RG;
    if (r === qf)
      return s.RG_INTEGER;
    if (r === Xf)
      return s.RGBA_INTEGER;
    if (r === Ao || r === ll || r === ul || r === go)
      if (c === zt)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (r === Ao)
            return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === ll)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === ul)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === go)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (r === Ao)
          return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === ll)
          return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === ul)
          return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === go)
          return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === xl || r === ef || r === Sl || r === tf)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (r === xl)
          return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === ef)
          return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === Sl)
          return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === tf)
          return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === Nl)
      return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === Cl || r === Ml)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (r === Cl)
          return c === zt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === Ml)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === Il || r === nf || r === rf || r === sf || r === wo || r === af || r === of || r === cf || r === lf || r === uf || r === hf || r === ff || r === df || r === pf)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (r === Il)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === nf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === rf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === sf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === wo)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === af)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === of)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === cf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === lf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === uf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === hf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === ff)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === df)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === pf)
          return c === zt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === mo || r === Af || r === gf)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (r === mo)
          return c === zt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === Af)
          return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === gf)
          return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === Km || r === mf || r === _f || r === bf)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (r === mo)
          return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === mf)
          return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === _f)
          return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === bf)
          return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === Dr ? n ? s.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null;
  }
  return { convert: i };
}
class x0 extends _n {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Un extends bt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const BS = { type: "move" };
class eh {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Un(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Un(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new P(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new P()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Un(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new P(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new P()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, r = null, a = null;
    const o = this._targetRay, c = this._grip, l = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (l && e.hand) {
        a = !0;
        for (const m of e.hand.values()) {
          const p = t.getJointPose(m, n), g = this._getHandJoint(l, m);
          p !== null && (g.matrix.fromArray(p.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = p.radius), g.visible = p !== null;
        }
        const u = l.joints["index-finger-tip"], h = l.joints["thumb-tip"], f = u.position.distanceTo(h.position), d = 0.02, A = 5e-3;
        l.inputState.pinching && f > d + A ? (l.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !l.inputState.pinching && f <= d - A && (l.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1));
      o !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(BS)));
    }
    return o !== null && (o.visible = i !== null), c !== null && (c.visible = r !== null), l !== null && (l.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Un();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class RS extends Yi {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, r = 1, a = null, o = "local-floor", c = 1, l = null, u = null, h = null, f = null, d = null, A = null;
    const m = t.getContextAttributes();
    let p = null, g = null;
    const _ = [], b = [], y = new xe();
    let v = null;
    const x = new _n();
    x.layers.enable(1), x.viewport = new Dt();
    const S = new _n();
    S.layers.enable(2), S.viewport = new Dt();
    const I = [x, S], E = new x0();
    E.layers.enable(1), E.layers.enable(2);
    let M = null, T = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
      let j = _[H];
      return j === void 0 && (j = new eh(), _[H] = j), j.getTargetRaySpace();
    }, this.getControllerGrip = function(H) {
      let j = _[H];
      return j === void 0 && (j = new eh(), _[H] = j), j.getGripSpace();
    }, this.getHand = function(H) {
      let j = _[H];
      return j === void 0 && (j = new eh(), _[H] = j), j.getHandSpace();
    };
    function D(H) {
      const j = b.indexOf(H.inputSource);
      if (j === -1)
        return;
      const $ = _[j];
      $ !== void 0 && ($.update(H.inputSource, H.frame, l || a), $.dispatchEvent({ type: H.type, data: H.inputSource }));
    }
    function F() {
      i.removeEventListener("select", D), i.removeEventListener("selectstart", D), i.removeEventListener("selectend", D), i.removeEventListener("squeeze", D), i.removeEventListener("squeezestart", D), i.removeEventListener("squeezeend", D), i.removeEventListener("end", F), i.removeEventListener("inputsourceschange", C);
      for (let H = 0; H < _.length; H++) {
        const j = b[H];
        j !== null && (b[H] = null, _[H].disconnect(j));
      }
      M = null, T = null, e.setRenderTarget(p), d = null, f = null, h = null, i = null, g = null, N.stop(), n.isPresenting = !1, e.setPixelRatio(v), e.setSize(y.width, y.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(H) {
      r = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(H) {
      o = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return l || a;
    }, this.setReferenceSpace = function(H) {
      l = H;
    }, this.getBaseLayer = function() {
      return f !== null ? f : d;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return A;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(H) {
      if (i = H, i !== null) {
        if (p = e.getRenderTarget(), i.addEventListener("select", D), i.addEventListener("selectstart", D), i.addEventListener("selectend", D), i.addEventListener("squeeze", D), i.addEventListener("squeezestart", D), i.addEventListener("squeezeend", D), i.addEventListener("end", F), i.addEventListener("inputsourceschange", C), m.xrCompatible !== !0 && await t.makeXRCompatible(), v = e.getPixelRatio(), e.getSize(y), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const j = {
            antialias: i.renderState.layers === void 0 ? m.antialias : !0,
            alpha: !0,
            depth: m.depth,
            stencil: m.stencil,
            framebufferScaleFactor: r
          };
          d = new XRWebGLLayer(i, t, j), i.updateRenderState({ baseLayer: d }), e.setPixelRatio(1), e.setSize(d.framebufferWidth, d.framebufferHeight, !1), g = new pi(
            d.framebufferWidth,
            d.framebufferHeight,
            {
              format: dn,
              type: fn,
              colorSpace: e.outputColorSpace,
              stencilBuffer: m.stencil
            }
          );
        } else {
          let j = null, $ = null, ce = null;
          m.depth && (ce = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, j = m.stencil ? xs : Lr, $ = m.stencil ? Dr : ur);
          const ee = {
            colorFormat: t.RGBA8,
            depthFormat: ce,
            scaleFactor: r
          };
          h = new XRWebGLBinding(i, t), f = h.createProjectionLayer(ee), i.updateRenderState({ layers: [f] }), e.setPixelRatio(1), e.setSize(f.textureWidth, f.textureHeight, !1), g = new pi(
            f.textureWidth,
            f.textureHeight,
            {
              format: dn,
              type: fn,
              depthTexture: new rd(f.textureWidth, f.textureHeight, $, void 0, void 0, void 0, void 0, void 0, void 0, j),
              stencilBuffer: m.stencil,
              colorSpace: e.outputColorSpace,
              samples: m.antialias ? 4 : 0
            }
          );
          const le = e.properties.get(g);
          le.__ignoreDepthValues = f.ignoreDepthValues;
        }
        g.isXRRenderTarget = !0, this.setFoveation(c), l = null, a = await i.requestReferenceSpace(o), N.setContext(i), N.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function C(H) {
      for (let j = 0; j < H.removed.length; j++) {
        const $ = H.removed[j], ce = b.indexOf($);
        ce >= 0 && (b[ce] = null, _[ce].disconnect($));
      }
      for (let j = 0; j < H.added.length; j++) {
        const $ = H.added[j];
        let ce = b.indexOf($);
        if (ce === -1) {
          for (let le = 0; le < _.length; le++)
            if (le >= b.length) {
              b.push($), ce = le;
              break;
            } else if (b[le] === null) {
              b[le] = $, ce = le;
              break;
            }
          if (ce === -1)
            break;
        }
        const ee = _[ce];
        ee && ee.connect($);
      }
    }
    const R = new P(), O = new P();
    function V(H, j, $) {
      R.setFromMatrixPosition(j.matrixWorld), O.setFromMatrixPosition($.matrixWorld);
      const ce = R.distanceTo(O), ee = j.projectionMatrix.elements, le = $.projectionMatrix.elements, Z = ee[14] / (ee[10] - 1), he = ee[14] / (ee[10] + 1), _e = (ee[9] + 1) / ee[5], U = (ee[9] - 1) / ee[5], ye = (ee[8] - 1) / ee[0], ie = (le[8] + 1) / le[0], re = Z * ye, te = Z * ie, Ie = ce / (-ye + ie), se = Ie * -ye;
      j.matrixWorld.decompose(H.position, H.quaternion, H.scale), H.translateX(se), H.translateZ(Ie), H.matrixWorld.compose(H.position, H.quaternion, H.scale), H.matrixWorldInverse.copy(H.matrixWorld).invert();
      const K = Z + Ie, ve = he + Ie, fe = re - se, oe = te + (ce - se), L = _e * he / ve * K, B = U * he / ve * K;
      H.projectionMatrix.makePerspective(fe, oe, L, B, K, ve), H.projectionMatrixInverse.copy(H.projectionMatrix).invert();
    }
    function q(H, j) {
      j === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices(j.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld).invert();
    }
    this.updateCamera = function(H) {
      if (i === null)
        return;
      E.near = S.near = x.near = H.near, E.far = S.far = x.far = H.far, (M !== E.near || T !== E.far) && (i.updateRenderState({
        depthNear: E.near,
        depthFar: E.far
      }), M = E.near, T = E.far);
      const j = H.parent, $ = E.cameras;
      q(E, j);
      for (let ce = 0; ce < $.length; ce++)
        q($[ce], j);
      $.length === 2 ? V(E, x, S) : E.projectionMatrix.copy(x.projectionMatrix), z(H, E, j);
    };
    function z(H, j, $) {
      $ === null ? H.matrix.copy(j.matrixWorld) : (H.matrix.copy($.matrixWorld), H.matrix.invert(), H.matrix.multiply(j.matrixWorld)), H.matrix.decompose(H.position, H.quaternion, H.scale), H.updateMatrixWorld(!0), H.projectionMatrix.copy(j.projectionMatrix), H.projectionMatrixInverse.copy(j.projectionMatrixInverse), H.isPerspectiveCamera && (H.fov = xa * 2 * Math.atan(1 / H.projectionMatrix.elements[5]), H.zoom = 1);
    }
    this.getCamera = function() {
      return E;
    }, this.getFoveation = function() {
      if (!(f === null && d === null))
        return c;
    }, this.setFoveation = function(H) {
      c = H, f !== null && (f.fixedFoveation = H), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = H);
    };
    let X = null;
    function w(H, j) {
      if (u = j.getViewerPose(l || a), A = j, u !== null) {
        const $ = u.views;
        d !== null && (e.setRenderTargetFramebuffer(g, d.framebuffer), e.setRenderTarget(g));
        let ce = !1;
        $.length !== E.cameras.length && (E.cameras.length = 0, ce = !0);
        for (let ee = 0; ee < $.length; ee++) {
          const le = $[ee];
          let Z = null;
          if (d !== null)
            Z = d.getViewport(le);
          else {
            const _e = h.getViewSubImage(f, le);
            Z = _e.viewport, ee === 0 && (e.setRenderTargetTextures(
              g,
              _e.colorTexture,
              f.ignoreDepthValues ? void 0 : _e.depthStencilTexture
            ), e.setRenderTarget(g));
          }
          let he = I[ee];
          he === void 0 && (he = new _n(), he.layers.enable(ee), he.viewport = new Dt(), I[ee] = he), he.matrix.fromArray(le.transform.matrix), he.matrix.decompose(he.position, he.quaternion, he.scale), he.projectionMatrix.fromArray(le.projectionMatrix), he.projectionMatrixInverse.copy(he.projectionMatrix).invert(), he.viewport.set(Z.x, Z.y, Z.width, Z.height), ee === 0 && (E.matrix.copy(he.matrix), E.matrix.decompose(E.position, E.quaternion, E.scale)), ce === !0 && E.cameras.push(he);
        }
      }
      for (let $ = 0; $ < _.length; $++) {
        const ce = b[$], ee = _[$];
        ce !== null && ee !== void 0 && ee.update(ce, j, l || a);
      }
      X && X(H, j), j.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: j }), A = null;
    }
    const N = new g0();
    N.setAnimationLoop(w), this.setAnimationLoop = function(H) {
      X = H;
    }, this.dispose = function() {
    };
  }
}
function DS(s, e) {
  function t(p, g) {
    p.matrixAutoUpdate === !0 && p.updateMatrix(), g.value.copy(p.matrix);
  }
  function n(p, g) {
    g.color.getRGB(p.fogColor.value, A0(s)), g.isFog ? (p.fogNear.value = g.near, p.fogFar.value = g.far) : g.isFogExp2 && (p.fogDensity.value = g.density);
  }
  function i(p, g, _, b, y) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? r(p, g) : g.isMeshToonMaterial ? (r(p, g), h(p, g)) : g.isMeshPhongMaterial ? (r(p, g), u(p, g)) : g.isMeshStandardMaterial ? (r(p, g), f(p, g), g.isMeshPhysicalMaterial && d(p, g, y)) : g.isMeshMatcapMaterial ? (r(p, g), A(p, g)) : g.isMeshDepthMaterial ? r(p, g) : g.isMeshDistanceMaterial ? (r(p, g), m(p, g)) : g.isMeshNormalMaterial ? r(p, g) : g.isLineBasicMaterial ? (a(p, g), g.isLineDashedMaterial && o(p, g)) : g.isPointsMaterial ? c(p, g, _, b) : g.isSpriteMaterial ? l(p, g) : g.isShadowMaterial ? (p.color.value.copy(g.color), p.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function r(p, g) {
    p.opacity.value = g.opacity, g.color && p.diffuse.value.copy(g.color), g.emissive && p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (p.map.value = g.map, t(g.map, p.mapTransform)), g.alphaMap && (p.alphaMap.value = g.alphaMap, t(g.alphaMap, p.alphaMapTransform)), g.bumpMap && (p.bumpMap.value = g.bumpMap, t(g.bumpMap, p.bumpMapTransform), p.bumpScale.value = g.bumpScale, g.side === Fn && (p.bumpScale.value *= -1)), g.normalMap && (p.normalMap.value = g.normalMap, t(g.normalMap, p.normalMapTransform), p.normalScale.value.copy(g.normalScale), g.side === Fn && p.normalScale.value.negate()), g.displacementMap && (p.displacementMap.value = g.displacementMap, t(g.displacementMap, p.displacementMapTransform), p.displacementScale.value = g.displacementScale, p.displacementBias.value = g.displacementBias), g.emissiveMap && (p.emissiveMap.value = g.emissiveMap, t(g.emissiveMap, p.emissiveMapTransform)), g.specularMap && (p.specularMap.value = g.specularMap, t(g.specularMap, p.specularMapTransform)), g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
    const _ = e.get(g).envMap;
    if (_ && (p.envMap.value = _, p.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, p.reflectivity.value = g.reflectivity, p.ior.value = g.ior, p.refractionRatio.value = g.refractionRatio), g.lightMap) {
      p.lightMap.value = g.lightMap;
      const b = s._useLegacyLights === !0 ? Math.PI : 1;
      p.lightMapIntensity.value = g.lightMapIntensity * b, t(g.lightMap, p.lightMapTransform);
    }
    g.aoMap && (p.aoMap.value = g.aoMap, p.aoMapIntensity.value = g.aoMapIntensity, t(g.aoMap, p.aoMapTransform));
  }
  function a(p, g) {
    p.diffuse.value.copy(g.color), p.opacity.value = g.opacity, g.map && (p.map.value = g.map, t(g.map, p.mapTransform));
  }
  function o(p, g) {
    p.dashSize.value = g.dashSize, p.totalSize.value = g.dashSize + g.gapSize, p.scale.value = g.scale;
  }
  function c(p, g, _, b) {
    p.diffuse.value.copy(g.color), p.opacity.value = g.opacity, p.size.value = g.size * _, p.scale.value = b * 0.5, g.map && (p.map.value = g.map, t(g.map, p.uvTransform)), g.alphaMap && (p.alphaMap.value = g.alphaMap, t(g.alphaMap, p.alphaMapTransform)), g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
  }
  function l(p, g) {
    p.diffuse.value.copy(g.color), p.opacity.value = g.opacity, p.rotation.value = g.rotation, g.map && (p.map.value = g.map, t(g.map, p.mapTransform)), g.alphaMap && (p.alphaMap.value = g.alphaMap, t(g.alphaMap, p.alphaMapTransform)), g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
  }
  function u(p, g) {
    p.specular.value.copy(g.specular), p.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function h(p, g) {
    g.gradientMap && (p.gradientMap.value = g.gradientMap);
  }
  function f(p, g) {
    p.metalness.value = g.metalness, g.metalnessMap && (p.metalnessMap.value = g.metalnessMap, t(g.metalnessMap, p.metalnessMapTransform)), p.roughness.value = g.roughness, g.roughnessMap && (p.roughnessMap.value = g.roughnessMap, t(g.roughnessMap, p.roughnessMapTransform)), e.get(g).envMap && (p.envMapIntensity.value = g.envMapIntensity);
  }
  function d(p, g, _) {
    p.ior.value = g.ior, g.sheen > 0 && (p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), p.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (p.sheenColorMap.value = g.sheenColorMap, t(g.sheenColorMap, p.sheenColorMapTransform)), g.sheenRoughnessMap && (p.sheenRoughnessMap.value = g.sheenRoughnessMap, t(g.sheenRoughnessMap, p.sheenRoughnessMapTransform))), g.clearcoat > 0 && (p.clearcoat.value = g.clearcoat, p.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (p.clearcoatMap.value = g.clearcoatMap, t(g.clearcoatMap, p.clearcoatMapTransform)), g.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, t(g.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (p.clearcoatNormalMap.value = g.clearcoatNormalMap, t(g.clearcoatNormalMap, p.clearcoatNormalMapTransform), p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === Fn && p.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (p.iridescence.value = g.iridescence, p.iridescenceIOR.value = g.iridescenceIOR, p.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], p.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (p.iridescenceMap.value = g.iridescenceMap, t(g.iridescenceMap, p.iridescenceMapTransform)), g.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = g.iridescenceThicknessMap, t(g.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))), g.transmission > 0 && (p.transmission.value = g.transmission, p.transmissionSamplerMap.value = _.texture, p.transmissionSamplerSize.value.set(_.width, _.height), g.transmissionMap && (p.transmissionMap.value = g.transmissionMap, t(g.transmissionMap, p.transmissionMapTransform)), p.thickness.value = g.thickness, g.thicknessMap && (p.thicknessMap.value = g.thicknessMap, t(g.thicknessMap, p.thicknessMapTransform)), p.attenuationDistance.value = g.attenuationDistance, p.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (p.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (p.anisotropyMap.value = g.anisotropyMap, t(g.anisotropyMap, p.anisotropyMapTransform))), p.specularIntensity.value = g.specularIntensity, p.specularColor.value.copy(g.specularColor), g.specularColorMap && (p.specularColorMap.value = g.specularColorMap, t(g.specularColorMap, p.specularColorMapTransform)), g.specularIntensityMap && (p.specularIntensityMap.value = g.specularIntensityMap, t(g.specularIntensityMap, p.specularIntensityMapTransform));
  }
  function A(p, g) {
    g.matcap && (p.matcap.value = g.matcap);
  }
  function m(p, g) {
    const _ = e.get(g).light;
    p.referencePosition.value.setFromMatrixPosition(_.matrixWorld), p.nearDistance.value = _.shadow.camera.near, p.farDistance.value = _.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function LS(s, e, t, n) {
  let i = {}, r = {}, a = [];
  const o = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(_, b) {
    const y = b.program;
    n.uniformBlockBinding(_, y);
  }
  function l(_, b) {
    let y = i[_.id];
    y === void 0 && (A(_), y = u(_), i[_.id] = y, _.addEventListener("dispose", p));
    const v = b.program;
    n.updateUBOMapping(_, v);
    const x = e.render.frame;
    r[_.id] !== x && (f(_), r[_.id] = x);
  }
  function u(_) {
    const b = h();
    _.__bindingPointIndex = b;
    const y = s.createBuffer(), v = _.__size, x = _.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, y), s.bufferData(s.UNIFORM_BUFFER, v, x), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, b, y), y;
  }
  function h() {
    for (let _ = 0; _ < o; _++)
      if (a.indexOf(_) === -1)
        return a.push(_), _;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function f(_) {
    const b = i[_.id], y = _.uniforms, v = _.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, b);
    for (let x = 0, S = y.length; x < S; x++) {
      const I = y[x];
      if (d(I, x, v) === !0) {
        const E = I.__offset, M = Array.isArray(I.value) ? I.value : [I.value];
        let T = 0;
        for (let D = 0; D < M.length; D++) {
          const F = M[D], C = m(F);
          typeof F == "number" ? (I.__data[0] = F, s.bufferSubData(s.UNIFORM_BUFFER, E + T, I.__data)) : F.isMatrix3 ? (I.__data[0] = F.elements[0], I.__data[1] = F.elements[1], I.__data[2] = F.elements[2], I.__data[3] = F.elements[0], I.__data[4] = F.elements[3], I.__data[5] = F.elements[4], I.__data[6] = F.elements[5], I.__data[7] = F.elements[0], I.__data[8] = F.elements[6], I.__data[9] = F.elements[7], I.__data[10] = F.elements[8], I.__data[11] = F.elements[0]) : (F.toArray(I.__data, T), T += C.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        s.bufferSubData(s.UNIFORM_BUFFER, E, I.__data);
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function d(_, b, y) {
    const v = _.value;
    if (y[b] === void 0) {
      if (typeof v == "number")
        y[b] = v;
      else {
        const x = Array.isArray(v) ? v : [v], S = [];
        for (let I = 0; I < x.length; I++)
          S.push(x[I].clone());
        y[b] = S;
      }
      return !0;
    } else if (typeof v == "number") {
      if (y[b] !== v)
        return y[b] = v, !0;
    } else {
      const x = Array.isArray(y[b]) ? y[b] : [y[b]], S = Array.isArray(v) ? v : [v];
      for (let I = 0; I < x.length; I++) {
        const E = x[I];
        if (E.equals(S[I]) === !1)
          return E.copy(S[I]), !0;
      }
    }
    return !1;
  }
  function A(_) {
    const b = _.uniforms;
    let y = 0;
    const v = 16;
    let x = 0;
    for (let S = 0, I = b.length; S < I; S++) {
      const E = b[S], M = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, T = Array.isArray(E.value) ? E.value : [E.value];
      for (let D = 0, F = T.length; D < F; D++) {
        const C = T[D], R = m(C);
        M.boundary += R.boundary, M.storage += R.storage;
      }
      if (E.__data = new Float32Array(M.storage / Float32Array.BYTES_PER_ELEMENT), E.__offset = y, S > 0) {
        x = y % v;
        const D = v - x;
        x !== 0 && D - M.boundary < 0 && (y += v - x, E.__offset = y);
      }
      y += M.storage;
    }
    return x = y % v, x > 0 && (y += v - x), _.__size = y, _.__cache = {}, this;
  }
  function m(_) {
    const b = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof _ == "number" ? (b.boundary = 4, b.storage = 4) : _.isVector2 ? (b.boundary = 8, b.storage = 8) : _.isVector3 || _.isColor ? (b.boundary = 16, b.storage = 12) : _.isVector4 ? (b.boundary = 16, b.storage = 16) : _.isMatrix3 ? (b.boundary = 48, b.storage = 48) : _.isMatrix4 ? (b.boundary = 64, b.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), b;
  }
  function p(_) {
    const b = _.target;
    b.removeEventListener("dispose", p);
    const y = a.indexOf(b.__bindingPointIndex);
    a.splice(y, 1), s.deleteBuffer(i[b.id]), delete i[b.id], delete r[b.id];
  }
  function g() {
    for (const _ in i)
      s.deleteBuffer(i[_]);
    a = [], i = {}, r = {};
  }
  return {
    bind: c,
    update: l,
    dispose: g
  };
}
class sd {
  constructor(e = {}) {
    const {
      canvas: t = f0(),
      context: n = null,
      depth: i = !0,
      stencil: r = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: l = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: h = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    n !== null ? f = n.getContextAttributes().alpha : f = a;
    const d = new Uint32Array(4), A = new Int32Array(4);
    let m = null, p = null;
    const g = [], _ = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Ot, this._useLegacyLights = !1, this.toneMapping = dr, this.toneMappingExposure = 1;
    const b = this;
    let y = !1, v = 0, x = 0, S = null, I = -1, E = null;
    const M = new Dt(), T = new Dt();
    let D = null;
    const F = new Pe(0);
    let C = 0, R = t.width, O = t.height, V = 1, q = null, z = null;
    const X = new Dt(0, 0, R, O), w = new Dt(0, 0, R, O);
    let N = !1;
    const H = new Vo();
    let j = !1, $ = !1, ce = null;
    const ee = new Je(), le = new xe(), Z = new P(), he = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function _e() {
      return S === null ? V : 1;
    }
    let U = n;
    function ye(k, ne) {
      for (let ge = 0; ge < k.length; ge++) {
        const be = k[ge], me = t.getContext(be, ne);
        if (me !== null)
          return me;
      }
      return null;
    }
    try {
      const k = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: o,
        premultipliedAlpha: c,
        preserveDrawingBuffer: l,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Ma}`), t.addEventListener("webglcontextlost", Ye, !1), t.addEventListener("webglcontextrestored", J, !1), t.addEventListener("webglcontextcreationerror", ke, !1), U === null) {
        const ne = ["webgl2", "webgl", "experimental-webgl"];
        if (b.isWebGL1Renderer === !0 && ne.shift(), U = ye(ne, k), U === null)
          throw ye(ne) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && U instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), U.getShaderPrecisionFormat === void 0 && (U.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (k) {
      throw console.error("THREE.WebGLRenderer: " + k.message), k;
    }
    let ie, re, te, Ie, se, K, ve, fe, oe, L, B, W, de, Ae, G, Ce, Se, De, Q, Me, pe, Le, Fe, Ge;
    function Ue() {
      ie = new Yx(U), re = new zx(U, ie, e), ie.init(re), Le = new E0(U, ie, re), te = new wS(U, ie, re), Ie = new Kx(U), se = new gS(), K = new TS(U, ie, te, se, re, Le, Ie), ve = new Vx(b), fe = new Xx(b), oe = new sv(U, re), Fe = new Qx(U, ie, oe, re), L = new jx(U, oe, Ie, Fe), B = new t1(U, L, oe, Ie), Q = new e1(U, re, K), Ce = new Hx(se), W = new AS(b, ve, fe, ie, re, Fe, Ce), de = new DS(b, se), Ae = new _S(), G = new SS(ie, re), De = new Ox(b, ve, fe, te, B, f, c), Se = new IS(b, B, re), Ge = new LS(U, Ie, re, te), Me = new Gx(U, ie, Ie, re), pe = new Jx(U, ie, Ie, re), Ie.programs = W.programs, b.capabilities = re, b.extensions = ie, b.properties = se, b.renderLists = Ae, b.shadowMap = Se, b.state = te, b.info = Ie;
    }
    Ue();
    const we = new RS(b, U);
    this.xr = we, this.getContext = function() {
      return U;
    }, this.getContextAttributes = function() {
      return U.getContextAttributes();
    }, this.forceContextLoss = function() {
      const k = ie.get("WEBGL_lose_context");
      k && k.loseContext();
    }, this.forceContextRestore = function() {
      const k = ie.get("WEBGL_lose_context");
      k && k.restoreContext();
    }, this.getPixelRatio = function() {
      return V;
    }, this.setPixelRatio = function(k) {
      k !== void 0 && (V = k, this.setSize(R, O, !1));
    }, this.getSize = function(k) {
      return k.set(R, O);
    }, this.setSize = function(k, ne, ge = !0) {
      if (we.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      R = k, O = ne, t.width = Math.floor(k * V), t.height = Math.floor(ne * V), ge === !0 && (t.style.width = k + "px", t.style.height = ne + "px"), this.setViewport(0, 0, k, ne);
    }, this.getDrawingBufferSize = function(k) {
      return k.set(R * V, O * V).floor();
    }, this.setDrawingBufferSize = function(k, ne, ge) {
      R = k, O = ne, V = ge, t.width = Math.floor(k * ge), t.height = Math.floor(ne * ge), this.setViewport(0, 0, k, ne);
    }, this.getCurrentViewport = function(k) {
      return k.copy(M);
    }, this.getViewport = function(k) {
      return k.copy(X);
    }, this.setViewport = function(k, ne, ge, be) {
      k.isVector4 ? X.set(k.x, k.y, k.z, k.w) : X.set(k, ne, ge, be), te.viewport(M.copy(X).multiplyScalar(V).floor());
    }, this.getScissor = function(k) {
      return k.copy(w);
    }, this.setScissor = function(k, ne, ge, be) {
      k.isVector4 ? w.set(k.x, k.y, k.z, k.w) : w.set(k, ne, ge, be), te.scissor(T.copy(w).multiplyScalar(V).floor());
    }, this.getScissorTest = function() {
      return N;
    }, this.setScissorTest = function(k) {
      te.setScissorTest(N = k);
    }, this.setOpaqueSort = function(k) {
      q = k;
    }, this.setTransparentSort = function(k) {
      z = k;
    }, this.getClearColor = function(k) {
      return k.copy(De.getClearColor());
    }, this.setClearColor = function() {
      De.setClearColor.apply(De, arguments);
    }, this.getClearAlpha = function() {
      return De.getClearAlpha();
    }, this.setClearAlpha = function() {
      De.setClearAlpha.apply(De, arguments);
    }, this.clear = function(k = !0, ne = !0, ge = !0) {
      let be = 0;
      if (k) {
        let me = !1;
        if (S !== null) {
          const We = S.texture.format;
          me = We === Xf || We === qf || We === Wf;
        }
        if (me) {
          const We = S.texture.type, Ze = We === fn || We === ur || We === kl || We === Dr || We === Hf || We === Vf, et = De.getClearColor(), Be = De.getClearAlpha(), ct = et.r, lt = et.g, it = et.b;
          Ze ? (d[0] = ct, d[1] = lt, d[2] = it, d[3] = Be, U.clearBufferuiv(U.COLOR, 0, d)) : (A[0] = ct, A[1] = lt, A[2] = it, A[3] = Be, U.clearBufferiv(U.COLOR, 0, A));
        } else
          be |= U.COLOR_BUFFER_BIT;
      }
      ne && (be |= U.DEPTH_BUFFER_BIT), ge && (be |= U.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), U.clear(be);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Ye, !1), t.removeEventListener("webglcontextrestored", J, !1), t.removeEventListener("webglcontextcreationerror", ke, !1), Ae.dispose(), G.dispose(), se.dispose(), ve.dispose(), fe.dispose(), B.dispose(), Fe.dispose(), Ge.dispose(), W.dispose(), we.dispose(), we.removeEventListener("sessionstart", yt), we.removeEventListener("sessionend", nt), ce && (ce.dispose(), ce = null), kt.stop();
    };
    function Ye(k) {
      k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
    }
    function J() {
      console.log("THREE.WebGLRenderer: Context Restored."), y = !1;
      const k = Ie.autoReset, ne = Se.enabled, ge = Se.autoUpdate, be = Se.needsUpdate, me = Se.type;
      Ue(), Ie.autoReset = k, Se.enabled = ne, Se.autoUpdate = ge, Se.needsUpdate = be, Se.type = me;
    }
    function ke(k) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
    }
    function Te(k) {
      const ne = k.target;
      ne.removeEventListener("dispose", Te), Ee(ne);
    }
    function Ee(k) {
      Re(k), se.remove(k);
    }
    function Re(k) {
      const ne = se.get(k).programs;
      ne !== void 0 && (ne.forEach(function(ge) {
        W.releaseProgram(ge);
      }), k.isShaderMaterial && W.releaseShaderCache(k));
    }
    this.renderBufferDirect = function(k, ne, ge, be, me, We) {
      ne === null && (ne = he);
      const Ze = me.isMesh && me.matrixWorld.determinant() < 0, et = ci(k, ne, ge, be, me);
      te.setMaterial(be, Ze);
      let Be = ge.index, ct = 1;
      if (be.wireframe === !0) {
        if (Be = L.getWireframeAttribute(ge), Be === void 0)
          return;
        ct = 2;
      }
      const lt = ge.drawRange, it = ge.attributes.position;
      let Gt = lt.start * ct, Nn = (lt.start + lt.count) * ct;
      We !== null && (Gt = Math.max(Gt, We.start * ct), Nn = Math.min(Nn, (We.start + We.count) * ct)), Be !== null ? (Gt = Math.max(Gt, 0), Nn = Math.min(Nn, Be.count)) : it != null && (Gt = Math.max(Gt, 0), Nn = Math.min(Nn, it.count));
      const an = Nn - Gt;
      if (an < 0 || an === 1 / 0)
        return;
      Fe.setup(me, be, et, ge, Be);
      let Zn, Ut = Me;
      if (Be !== null && (Zn = oe.get(Be), Ut = pe, Ut.setIndex(Zn)), me.isMesh)
        be.wireframe === !0 ? (te.setLineWidth(be.wireframeLinewidth * _e()), Ut.setMode(U.LINES)) : Ut.setMode(U.TRIANGLES);
      else if (me.isLine) {
        let ht = be.linewidth;
        ht === void 0 && (ht = 1), te.setLineWidth(ht * _e()), me.isLineSegments ? Ut.setMode(U.LINES) : me.isLineLoop ? Ut.setMode(U.LINE_LOOP) : Ut.setMode(U.LINE_STRIP);
      } else
        me.isPoints ? Ut.setMode(U.POINTS) : me.isSprite && Ut.setMode(U.TRIANGLES);
      if (me.isBatchedMesh)
        Ut.renderMultiDraw(me._multiDrawStarts, me._multiDrawCounts, me._multiDrawCount);
      else if (me.isInstancedMesh)
        Ut.renderInstances(Gt, an, me.count);
      else if (ge.isInstancedBufferGeometry) {
        const ht = ge._maxInstanceCount !== void 0 ? ge._maxInstanceCount : 1 / 0, gr = Math.min(ge.instanceCount, ht);
        Ut.renderInstances(Gt, an, gr);
      } else
        Ut.render(Gt, an);
    };
    function Xe(k, ne, ge) {
      k.transparent === !0 && k.side === Mn && k.forceSinglePass === !1 ? (k.side = Fn, k.needsUpdate = !0, Zt(k, ne, ge), k.side = mi, k.needsUpdate = !0, Zt(k, ne, ge), k.side = Mn) : Zt(k, ne, ge);
    }
    this.compile = function(k, ne, ge = null) {
      ge === null && (ge = k), p = G.get(ge), p.init(), _.push(p), ge.traverseVisible(function(me) {
        me.isLight && me.layers.test(ne.layers) && (p.pushLight(me), me.castShadow && p.pushShadow(me));
      }), k !== ge && k.traverseVisible(function(me) {
        me.isLight && me.layers.test(ne.layers) && (p.pushLight(me), me.castShadow && p.pushShadow(me));
      }), p.setupLights(b._useLegacyLights);
      const be = /* @__PURE__ */ new Set();
      return k.traverse(function(me) {
        const We = me.material;
        if (We)
          if (Array.isArray(We))
            for (let Ze = 0; Ze < We.length; Ze++) {
              const et = We[Ze];
              Xe(et, ge, me), be.add(et);
            }
          else
            Xe(We, ge, me), be.add(We);
      }), _.pop(), p = null, be;
    }, this.compileAsync = function(k, ne, ge = null) {
      const be = this.compile(k, ne, ge);
      return new Promise((me) => {
        function We() {
          if (be.forEach(function(Ze) {
            se.get(Ze).currentProgram.isReady() && be.delete(Ze);
          }), be.size === 0) {
            me(k);
            return;
          }
          setTimeout(We, 10);
        }
        ie.get("KHR_parallel_shader_compile") !== null ? We() : setTimeout(We, 10);
      });
    };
    let Ke = null;
    function Xt(k) {
      Ke && Ke(k);
    }
    function yt() {
      kt.stop();
    }
    function nt() {
      kt.start();
    }
    const kt = new g0();
    kt.setAnimationLoop(Xt), typeof self < "u" && kt.setContext(self), this.setAnimationLoop = function(k) {
      Ke = k, we.setAnimationLoop(k), k === null ? kt.stop() : kt.start();
    }, we.addEventListener("sessionstart", yt), we.addEventListener("sessionend", nt), this.render = function(k, ne) {
      if (ne !== void 0 && ne.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (y === !0)
        return;
      k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(), ne.parent === null && ne.matrixWorldAutoUpdate === !0 && ne.updateMatrixWorld(), we.enabled === !0 && we.isPresenting === !0 && (we.cameraAutoUpdate === !0 && we.updateCamera(ne), ne = we.getCamera()), k.isScene === !0 && k.onBeforeRender(b, k, ne, S), p = G.get(k, _.length), p.init(), _.push(p), ee.multiplyMatrices(ne.projectionMatrix, ne.matrixWorldInverse), H.setFromProjectionMatrix(ee), $ = this.localClippingEnabled, j = Ce.init(this.clippingPlanes, $), m = Ae.get(k, g.length), m.init(), g.push(m), Yt(k, ne, 0, b.sortObjects), m.finish(), b.sortObjects === !0 && m.sort(q, z), this.info.render.frame++, j === !0 && Ce.beginShadows();
      const ge = p.state.shadowsArray;
      if (Se.render(ge, k, ne), j === !0 && Ce.endShadows(), this.info.autoReset === !0 && this.info.reset(), De.render(m, k), p.setupLights(b._useLegacyLights), ne.isArrayCamera) {
        const be = ne.cameras;
        for (let me = 0, We = be.length; me < We; me++) {
          const Ze = be[me];
          Lt(m, k, Ze, Ze.viewport);
        }
      } else
        Lt(m, k, ne);
      S !== null && (K.updateMultisampleRenderTarget(S), K.updateRenderTargetMipmap(S)), k.isScene === !0 && k.onAfterRender(b, k, ne), Fe.resetDefaultState(), I = -1, E = null, _.pop(), _.length > 0 ? p = _[_.length - 1] : p = null, g.pop(), g.length > 0 ? m = g[g.length - 1] : m = null;
    };
    function Yt(k, ne, ge, be) {
      if (k.visible === !1)
        return;
      if (k.layers.test(ne.layers)) {
        if (k.isGroup)
          ge = k.renderOrder;
        else if (k.isLOD)
          k.autoUpdate === !0 && k.update(ne);
        else if (k.isLight)
          p.pushLight(k), k.castShadow && p.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || H.intersectsSprite(k)) {
            be && Z.setFromMatrixPosition(k.matrixWorld).applyMatrix4(ee);
            const Ze = B.update(k), et = k.material;
            et.visible && m.push(k, Ze, et, ge, Z.z, null);
          }
        } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || H.intersectsObject(k))) {
          const Ze = B.update(k), et = k.material;
          if (be && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), Z.copy(k.boundingSphere.center)) : (Ze.boundingSphere === null && Ze.computeBoundingSphere(), Z.copy(Ze.boundingSphere.center)), Z.applyMatrix4(k.matrixWorld).applyMatrix4(ee)), Array.isArray(et)) {
            const Be = Ze.groups;
            for (let ct = 0, lt = Be.length; ct < lt; ct++) {
              const it = Be[ct], Gt = et[it.materialIndex];
              Gt && Gt.visible && m.push(k, Ze, Gt, ge, Z.z, it);
            }
          } else
            et.visible && m.push(k, Ze, et, ge, Z.z, null);
        }
      }
      const We = k.children;
      for (let Ze = 0, et = We.length; Ze < et; Ze++)
        Yt(We[Ze], ne, ge, be);
    }
    function Lt(k, ne, ge, be) {
      const me = k.opaque, We = k.transmissive, Ze = k.transparent;
      p.setupLightsView(ge), j === !0 && Ce.setGlobalState(b.clippingPlanes, ge), We.length > 0 && gn(me, We, ne, ge), be && te.viewport(M.copy(be)), me.length > 0 && Bn(me, ne, ge), We.length > 0 && Bn(We, ne, ge), Ze.length > 0 && Bn(Ze, ne, ge), te.buffers.depth.setTest(!0), te.buffers.depth.setMask(!0), te.buffers.color.setMask(!0), te.setPolygonOffset(!1);
    }
    function gn(k, ne, ge, be) {
      if ((ge.isScene === !0 ? ge.overrideMaterial : null) !== null)
        return;
      const We = re.isWebGL2;
      ce === null && (ce = new pi(1, 1, {
        generateMipmaps: !0,
        type: ie.has("EXT_color_buffer_half_float") ? Pn : fn,
        minFilter: _i,
        samples: We ? 4 : 0
      })), b.getDrawingBufferSize(le), We ? ce.setSize(le.x, le.y) : ce.setSize(Bl(le.x), Bl(le.y));
      const Ze = b.getRenderTarget();
      b.setRenderTarget(ce), b.getClearColor(F), C = b.getClearAlpha(), C < 1 && b.setClearColor(16777215, 0.5), b.clear();
      const et = b.toneMapping;
      b.toneMapping = dr, Bn(k, ge, be), K.updateMultisampleRenderTarget(ce), K.updateRenderTargetMipmap(ce);
      let Be = !1;
      for (let ct = 0, lt = ne.length; ct < lt; ct++) {
        const it = ne[ct], Gt = it.object, Nn = it.geometry, an = it.material, Zn = it.group;
        if (an.side === Mn && Gt.layers.test(be.layers)) {
          const Ut = an.side;
          an.side = Fn, an.needsUpdate = !0, mn(Gt, ge, be, Nn, an, Zn), an.side = Ut, an.needsUpdate = !0, Be = !0;
        }
      }
      Be === !0 && (K.updateMultisampleRenderTarget(ce), K.updateRenderTargetMipmap(ce)), b.setRenderTarget(Ze), b.setClearColor(F, C), b.toneMapping = et;
    }
    function Bn(k, ne, ge) {
      const be = ne.isScene === !0 ? ne.overrideMaterial : null;
      for (let me = 0, We = k.length; me < We; me++) {
        const Ze = k[me], et = Ze.object, Be = Ze.geometry, ct = be === null ? Ze.material : be, lt = Ze.group;
        et.layers.test(ge.layers) && mn(et, ne, ge, Be, ct, lt);
      }
    }
    function mn(k, ne, ge, be, me, We) {
      k.onBeforeRender(b, ne, ge, be, me, We), k.modelViewMatrix.multiplyMatrices(ge.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), me.onBeforeRender(b, ne, ge, be, k, We), me.transparent === !0 && me.side === Mn && me.forceSinglePass === !1 ? (me.side = Fn, me.needsUpdate = !0, b.renderBufferDirect(ge, ne, be, me, k, We), me.side = mi, me.needsUpdate = !0, b.renderBufferDirect(ge, ne, be, me, k, We), me.side = Mn) : b.renderBufferDirect(ge, ne, be, me, k, We), k.onAfterRender(b, ne, ge, be, me, We);
    }
    function Zt(k, ne, ge) {
      ne.isScene !== !0 && (ne = he);
      const be = se.get(k), me = p.state.lights, We = p.state.shadowsArray, Ze = me.state.version, et = W.getParameters(k, me.state, We, ne, ge), Be = W.getProgramCacheKey(et);
      let ct = be.programs;
      be.environment = k.isMeshStandardMaterial ? ne.environment : null, be.fog = ne.fog, be.envMap = (k.isMeshStandardMaterial ? fe : ve).get(k.envMap || be.environment), ct === void 0 && (k.addEventListener("dispose", Te), ct = /* @__PURE__ */ new Map(), be.programs = ct);
      let lt = ct.get(Be);
      if (lt !== void 0) {
        if (be.currentProgram === lt && be.lightsStateVersion === Ze)
          return Ei(k, et), lt;
      } else
        et.uniforms = W.getUniforms(k), k.onBuild(ge, et, b), k.onBeforeCompile(et, b), lt = W.acquireProgram(et, Be), ct.set(Be, lt), be.uniforms = et.uniforms;
      const it = be.uniforms;
      return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && (it.clippingPlanes = Ce.uniform), Ei(k, et), be.needsLights = bu(k), be.lightsStateVersion = Ze, be.needsLights && (it.ambientLightColor.value = me.state.ambient, it.lightProbe.value = me.state.probe, it.directionalLights.value = me.state.directional, it.directionalLightShadows.value = me.state.directionalShadow, it.spotLights.value = me.state.spot, it.spotLightShadows.value = me.state.spotShadow, it.rectAreaLights.value = me.state.rectArea, it.ltc_1.value = me.state.rectAreaLTC1, it.ltc_2.value = me.state.rectAreaLTC2, it.pointLights.value = me.state.point, it.pointLightShadows.value = me.state.pointShadow, it.hemisphereLights.value = me.state.hemi, it.directionalShadowMap.value = me.state.directionalShadowMap, it.directionalShadowMatrix.value = me.state.directionalShadowMatrix, it.spotShadowMap.value = me.state.spotShadowMap, it.spotLightMatrix.value = me.state.spotLightMatrix, it.spotLightMap.value = me.state.spotLightMap, it.pointShadowMap.value = me.state.pointShadowMap, it.pointShadowMatrix.value = me.state.pointShadowMatrix), be.currentProgram = lt, be.uniformsList = null, lt;
    }
    function Sn(k) {
      if (k.uniformsList === null) {
        const ne = k.currentProgram.getUniforms();
        k.uniformsList = fl.seqWithValue(ne.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function Ei(k, ne) {
      const ge = se.get(k);
      ge.outputColorSpace = ne.outputColorSpace, ge.batching = ne.batching, ge.instancing = ne.instancing, ge.instancingColor = ne.instancingColor, ge.skinning = ne.skinning, ge.morphTargets = ne.morphTargets, ge.morphNormals = ne.morphNormals, ge.morphColors = ne.morphColors, ge.morphTargetsCount = ne.morphTargetsCount, ge.numClippingPlanes = ne.numClippingPlanes, ge.numIntersection = ne.numClipIntersection, ge.vertexAlphas = ne.vertexAlphas, ge.vertexTangents = ne.vertexTangents, ge.toneMapping = ne.toneMapping;
    }
    function ci(k, ne, ge, be, me) {
      ne.isScene !== !0 && (ne = he), K.resetTextureUnits();
      const We = ne.fog, Ze = be.isMeshStandardMaterial ? ne.environment : null, et = S === null ? b.outputColorSpace : S.isXRRenderTarget === !0 ? S.texture.colorSpace : rn, Be = (be.isMeshStandardMaterial ? fe : ve).get(be.envMap || Ze), ct = be.vertexColors === !0 && !!ge.attributes.color && ge.attributes.color.itemSize === 4, lt = !!ge.attributes.tangent && (!!be.normalMap || be.anisotropy > 0), it = !!ge.morphAttributes.position, Gt = !!ge.morphAttributes.normal, Nn = !!ge.morphAttributes.color;
      let an = dr;
      be.toneMapped && (S === null || S.isXRRenderTarget === !0) && (an = b.toneMapping);
      const Zn = ge.morphAttributes.position || ge.morphAttributes.normal || ge.morphAttributes.color, Ut = Zn !== void 0 ? Zn.length : 0, ht = se.get(be), gr = p.state.lights;
      if (j === !0 && ($ === !0 || k !== E)) {
        const On = k === E && be.id === I;
        Ce.setState(be, k, On);
      }
      let Vt = !1;
      be.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== gr.state.version || ht.outputColorSpace !== et || me.isBatchedMesh && ht.batching === !1 || !me.isBatchedMesh && ht.batching === !0 || me.isInstancedMesh && ht.instancing === !1 || !me.isInstancedMesh && ht.instancing === !0 || me.isSkinnedMesh && ht.skinning === !1 || !me.isSkinnedMesh && ht.skinning === !0 || me.isInstancedMesh && ht.instancingColor === !0 && me.instanceColor === null || me.isInstancedMesh && ht.instancingColor === !1 && me.instanceColor !== null || ht.envMap !== Be || be.fog === !0 && ht.fog !== We || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== Ce.numPlanes || ht.numIntersection !== Ce.numIntersection) || ht.vertexAlphas !== ct || ht.vertexTangents !== lt || ht.morphTargets !== it || ht.morphNormals !== Gt || ht.morphColors !== Nn || ht.toneMapping !== an || re.isWebGL2 === !0 && ht.morphTargetsCount !== Ut) && (Vt = !0) : (Vt = !0, ht.__version = be.version);
      let xi = ht.currentProgram;
      Vt === !0 && (xi = Zt(be, ne, me));
      let Ua = !1, Si = !1, Vr = !1;
      const $t = xi.getUniforms(), Ci = ht.uniforms;
      if (te.useProgram(xi.program) && (Ua = !0, Si = !0, Vr = !0), be.id !== I && (I = be.id, Si = !0), Ua || E !== k) {
        $t.setValue(U, "projectionMatrix", k.projectionMatrix), $t.setValue(U, "viewMatrix", k.matrixWorldInverse);
        const On = $t.map.cameraPosition;
        On !== void 0 && On.setValue(U, Z.setFromMatrixPosition(k.matrixWorld)), re.logarithmicDepthBuffer && $t.setValue(
          U,
          "logDepthBufFC",
          2 / (Math.log(k.far + 1) / Math.LN2)
        ), (be.isMeshPhongMaterial || be.isMeshToonMaterial || be.isMeshLambertMaterial || be.isMeshBasicMaterial || be.isMeshStandardMaterial || be.isShaderMaterial) && $t.setValue(U, "isOrthographic", k.isOrthographicCamera === !0), E !== k && (E = k, Si = !0, Vr = !0);
      }
      if (me.isSkinnedMesh) {
        $t.setOptional(U, me, "bindMatrix"), $t.setOptional(U, me, "bindMatrixInverse");
        const On = me.skeleton;
        On && (re.floatVertexTextures ? (On.boneTexture === null && On.computeBoneTexture(), $t.setValue(U, "boneTexture", On.boneTexture, K)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      me.isBatchedMesh && ($t.setOptional(U, me, "batchingTexture"), $t.setValue(U, "batchingTexture", me._matricesTexture, K));
      const Wr = ge.morphAttributes;
      if ((Wr.position !== void 0 || Wr.normal !== void 0 || Wr.color !== void 0 && re.isWebGL2 === !0) && Q.update(me, ge, xi), (Si || ht.receiveShadow !== me.receiveShadow) && (ht.receiveShadow = me.receiveShadow, $t.setValue(U, "receiveShadow", me.receiveShadow)), be.isMeshGouraudMaterial && be.envMap !== null && (Ci.envMap.value = Be, Ci.flipEnvMap.value = Be.isCubeTexture && Be.isRenderTargetTexture === !1 ? -1 : 1), Si && ($t.setValue(U, "toneMappingExposure", b.toneMappingExposure), ht.needsLights && Ki(Ci, Vr), We && be.fog === !0 && de.refreshFogUniforms(Ci, We), de.refreshMaterialUniforms(Ci, be, V, O, ce), fl.upload(U, Sn(ht), Ci, K)), be.isShaderMaterial && be.uniformsNeedUpdate === !0 && (fl.upload(U, Sn(ht), Ci, K), be.uniformsNeedUpdate = !1), be.isSpriteMaterial && $t.setValue(U, "center", me.center), $t.setValue(U, "modelViewMatrix", me.modelViewMatrix), $t.setValue(U, "normalMatrix", me.normalMatrix), $t.setValue(U, "modelMatrix", me.matrixWorld), be.isShaderMaterial || be.isRawShaderMaterial) {
        const On = be.uniformsGroups;
        for (let $n = 0, yu = On.length; $n < yu; $n++)
          if (re.isWebGL2) {
            const qr = On[$n];
            Ge.update(qr, xi), Ge.bind(qr, xi);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return xi;
    }
    function Ki(k, ne) {
      k.ambientLightColor.needsUpdate = ne, k.lightProbe.needsUpdate = ne, k.directionalLights.needsUpdate = ne, k.directionalLightShadows.needsUpdate = ne, k.pointLights.needsUpdate = ne, k.pointLightShadows.needsUpdate = ne, k.spotLights.needsUpdate = ne, k.spotLightShadows.needsUpdate = ne, k.rectAreaLights.needsUpdate = ne, k.hemisphereLights.needsUpdate = ne;
    }
    function bu(k) {
      return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return v;
    }, this.getActiveMipmapLevel = function() {
      return x;
    }, this.getRenderTarget = function() {
      return S;
    }, this.setRenderTargetTextures = function(k, ne, ge) {
      se.get(k.texture).__webglTexture = ne, se.get(k.depthTexture).__webglTexture = ge;
      const be = se.get(k);
      be.__hasExternalTextures = !0, be.__hasExternalTextures && (be.__autoAllocateDepthBuffer = ge === void 0, be.__autoAllocateDepthBuffer || ie.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), be.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(k, ne) {
      const ge = se.get(k);
      ge.__webglFramebuffer = ne, ge.__useDefaultFramebuffer = ne === void 0;
    }, this.setRenderTarget = function(k, ne = 0, ge = 0) {
      S = k, v = ne, x = ge;
      let be = !0, me = null, We = !1, Ze = !1;
      if (k) {
        const Be = se.get(k);
        Be.__useDefaultFramebuffer !== void 0 ? (te.bindFramebuffer(U.FRAMEBUFFER, null), be = !1) : Be.__webglFramebuffer === void 0 ? K.setupRenderTarget(k) : Be.__hasExternalTextures && K.rebindTextures(k, se.get(k.texture).__webglTexture, se.get(k.depthTexture).__webglTexture);
        const ct = k.texture;
        (ct.isData3DTexture || ct.isDataArrayTexture || ct.isCompressedArrayTexture) && (Ze = !0);
        const lt = se.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget ? (Array.isArray(lt[ne]) ? me = lt[ne][ge] : me = lt[ne], We = !0) : re.isWebGL2 && k.samples > 0 && K.useMultisampledRTT(k) === !1 ? me = se.get(k).__webglMultisampledFramebuffer : Array.isArray(lt) ? me = lt[ge] : me = lt, M.copy(k.viewport), T.copy(k.scissor), D = k.scissorTest;
      } else
        M.copy(X).multiplyScalar(V).floor(), T.copy(w).multiplyScalar(V).floor(), D = N;
      if (te.bindFramebuffer(U.FRAMEBUFFER, me) && re.drawBuffers && be && te.drawBuffers(k, me), te.viewport(M), te.scissor(T), te.setScissorTest(D), We) {
        const Be = se.get(k.texture);
        U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_CUBE_MAP_POSITIVE_X + ne, Be.__webglTexture, ge);
      } else if (Ze) {
        const Be = se.get(k.texture), ct = ne || 0;
        U.framebufferTextureLayer(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, Be.__webglTexture, ge || 0, ct);
      }
      I = -1;
    }, this.readRenderTargetPixels = function(k, ne, ge, be, me, We, Ze) {
      if (!(k && k.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let et = se.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && Ze !== void 0 && (et = et[Ze]), et) {
        te.bindFramebuffer(U.FRAMEBUFFER, et);
        try {
          const Be = k.texture, ct = Be.format, lt = Be.type;
          if (ct !== dn && Le.convert(ct) !== U.getParameter(U.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const it = lt === Pn && (ie.has("EXT_color_buffer_half_float") || re.isWebGL2 && ie.has("EXT_color_buffer_float"));
          if (lt !== fn && Le.convert(lt) !== U.getParameter(U.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(lt === pn && (re.isWebGL2 || ie.has("OES_texture_float") || ie.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !it) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ne >= 0 && ne <= k.width - be && ge >= 0 && ge <= k.height - me && U.readPixels(ne, ge, be, me, Le.convert(ct), Le.convert(lt), We);
        } finally {
          const Be = S !== null ? se.get(S).__webglFramebuffer : null;
          te.bindFramebuffer(U.FRAMEBUFFER, Be);
        }
      }
    }, this.copyFramebufferToTexture = function(k, ne, ge = 0) {
      const be = Math.pow(2, -ge), me = Math.floor(ne.image.width * be), We = Math.floor(ne.image.height * be);
      K.setTexture2D(ne, 0), U.copyTexSubImage2D(U.TEXTURE_2D, ge, 0, 0, k.x, k.y, me, We), te.unbindTexture();
    }, this.copyTextureToTexture = function(k, ne, ge, be = 0) {
      const me = ne.image.width, We = ne.image.height, Ze = Le.convert(ge.format), et = Le.convert(ge.type);
      K.setTexture2D(ge, 0), U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL, ge.flipY), U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ge.premultiplyAlpha), U.pixelStorei(U.UNPACK_ALIGNMENT, ge.unpackAlignment), ne.isDataTexture ? U.texSubImage2D(U.TEXTURE_2D, be, k.x, k.y, me, We, Ze, et, ne.image.data) : ne.isCompressedTexture ? U.compressedTexSubImage2D(U.TEXTURE_2D, be, k.x, k.y, ne.mipmaps[0].width, ne.mipmaps[0].height, Ze, ne.mipmaps[0].data) : U.texSubImage2D(U.TEXTURE_2D, be, k.x, k.y, Ze, et, ne.image), be === 0 && ge.generateMipmaps && U.generateMipmap(U.TEXTURE_2D), te.unbindTexture();
    }, this.copyTextureToTexture3D = function(k, ne, ge, be, me = 0) {
      if (b.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const We = k.max.x - k.min.x + 1, Ze = k.max.y - k.min.y + 1, et = k.max.z - k.min.z + 1, Be = Le.convert(be.format), ct = Le.convert(be.type);
      let lt;
      if (be.isData3DTexture)
        K.setTexture3D(be, 0), lt = U.TEXTURE_3D;
      else if (be.isDataArrayTexture)
        K.setTexture2DArray(be, 0), lt = U.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL, be.flipY), U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL, be.premultiplyAlpha), U.pixelStorei(U.UNPACK_ALIGNMENT, be.unpackAlignment);
      const it = U.getParameter(U.UNPACK_ROW_LENGTH), Gt = U.getParameter(U.UNPACK_IMAGE_HEIGHT), Nn = U.getParameter(U.UNPACK_SKIP_PIXELS), an = U.getParameter(U.UNPACK_SKIP_ROWS), Zn = U.getParameter(U.UNPACK_SKIP_IMAGES), Ut = ge.isCompressedTexture ? ge.mipmaps[0] : ge.image;
      U.pixelStorei(U.UNPACK_ROW_LENGTH, Ut.width), U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, Ut.height), U.pixelStorei(U.UNPACK_SKIP_PIXELS, k.min.x), U.pixelStorei(U.UNPACK_SKIP_ROWS, k.min.y), U.pixelStorei(U.UNPACK_SKIP_IMAGES, k.min.z), ge.isDataTexture || ge.isData3DTexture ? U.texSubImage3D(lt, me, ne.x, ne.y, ne.z, We, Ze, et, Be, ct, Ut.data) : ge.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), U.compressedTexSubImage3D(lt, me, ne.x, ne.y, ne.z, We, Ze, et, Be, Ut.data)) : U.texSubImage3D(lt, me, ne.x, ne.y, ne.z, We, Ze, et, Be, ct, Ut), U.pixelStorei(U.UNPACK_ROW_LENGTH, it), U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, Gt), U.pixelStorei(U.UNPACK_SKIP_PIXELS, Nn), U.pixelStorei(U.UNPACK_SKIP_ROWS, an), U.pixelStorei(U.UNPACK_SKIP_IMAGES, Zn), me === 0 && be.generateMipmaps && U.generateMipmap(lt), te.unbindTexture();
    }, this.initTexture = function(k) {
      k.isCubeTexture ? K.setTextureCube(k, 0) : k.isData3DTexture ? K.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? K.setTexture2DArray(k, 0) : K.setTexture2D(k, 0), te.unbindTexture();
    }, this.resetState = function() {
      v = 0, x = 0, S = null, te.reset(), Fe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Di;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === Ho ? "display-p3" : "srgb", t.unpackColorSpace = Tt.workingColorSpace === wa ? "display-p3" : "srgb";
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Ot ? Wi : va;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Wi ? Ot : rn;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class S0 extends sd {
}
S0.prototype.isWebGL1Renderer = !0;
class Yl {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Pe(e), this.density = t;
  }
  clone() {
    return new Yl(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class jl {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Pe(e), this.near = t, this.far = n;
  }
  clone() {
    return new jl(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class Jl extends bt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class qo {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Lo, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = di();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn('THREE.InterleavedBuffer: "updateRange" is deprecated and removed in r169. Use "addUpdateRange()" instead.'), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = di()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = di()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const qn = /* @__PURE__ */ new P();
class kr {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      qn.fromBufferAttribute(this, t), qn.applyMatrix4(e), this.setXYZ(t, qn.x, qn.y, qn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qn.fromBufferAttribute(this, t), qn.applyNormalMatrix(e), this.setXYZ(t, qn.x, qn.y, qn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      qn.fromBufferAttribute(this, t), qn.transformDirection(e), this.setXYZ(t, qn.x, qn.y, qn.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = dt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = ri(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dt(t, this.array), n = dt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = dt(t, this.array), n = dt(n, this.array), i = dt(i, this.array), r = dt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return new ut(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new kr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Kl extends vn {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Pe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ta;
const Ya = /* @__PURE__ */ new P(), na = /* @__PURE__ */ new P(), ia = /* @__PURE__ */ new P(), ra = /* @__PURE__ */ new xe(), ja = /* @__PURE__ */ new xe(), C0 = /* @__PURE__ */ new Je(), Tc = /* @__PURE__ */ new P(), Ja = /* @__PURE__ */ new P(), Bc = /* @__PURE__ */ new P(), Op = /* @__PURE__ */ new xe(), th = /* @__PURE__ */ new xe(), Qp = /* @__PURE__ */ new xe();
class M0 extends bt {
  constructor(e = new Kl()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", ta === void 0) {
      ta = new ot();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new qo(t, 5);
      ta.setIndex([0, 1, 2, 0, 2, 3]), ta.setAttribute("position", new kr(n, 3, 0, !1)), ta.setAttribute("uv", new kr(n, 2, 3, !1));
    }
    this.geometry = ta, this.material = e, this.center = new xe(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), na.setFromMatrixScale(this.matrixWorld), C0.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ia.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && na.multiplyScalar(-ia.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && (r = Math.cos(n), i = Math.sin(n));
    const a = this.center;
    Rc(Tc.set(-0.5, -0.5, 0), ia, a, na, i, r), Rc(Ja.set(0.5, -0.5, 0), ia, a, na, i, r), Rc(Bc.set(0.5, 0.5, 0), ia, a, na, i, r), Op.set(0, 0), th.set(1, 0), Qp.set(1, 1);
    let o = e.ray.intersectTriangle(Tc, Ja, Bc, !1, Ya);
    if (o === null && (Rc(Ja.set(-0.5, 0.5, 0), ia, a, na, i, r), th.set(0, 1), o = e.ray.intersectTriangle(Tc, Bc, Ja, !1, Ya), o === null))
      return;
    const c = e.ray.origin.distanceTo(Ya);
    c < e.near || c > e.far || t.push({
      distance: c,
      point: Ya.clone(),
      uv: ii.getInterpolation(Ya, Tc, Ja, Bc, Op, th, Qp, new xe()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Rc(s, e, t, n, i, r) {
  ra.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (ja.x = r * ra.x - i * ra.y, ja.y = i * ra.x + r * ra.y) : ja.copy(ra), s.copy(e), s.x += ja.x, s.y += ja.y, s.applyMatrix4(C0);
}
const Dc = /* @__PURE__ */ new P(), Gp = /* @__PURE__ */ new P();
class I0 extends bt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let r;
    for (r = 0; r < i.length && !(t < i[r].distance); r++)
      ;
    return i.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Dc.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Dc);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Dc.setFromMatrixPosition(e.matrixWorld), Gp.setFromMatrixPosition(this.matrixWorld);
      const n = Dc.distanceTo(Gp) / e.zoom;
      t[0].object.visible = !0;
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let a = t[i].distance;
        if (t[i].object.visible && (a -= a * t[i].hysteresis), n >= a)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < r; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, r = n.length; i < r; i++) {
      const a = n[i];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis
      });
    }
    return t;
  }
}
const zp = /* @__PURE__ */ new P(), Hp = /* @__PURE__ */ new Dt(), Vp = /* @__PURE__ */ new Dt(), PS = /* @__PURE__ */ new P(), Wp = /* @__PURE__ */ new Je(), Lc = /* @__PURE__ */ new P(), nh = /* @__PURE__ */ new yn(), qp = /* @__PURE__ */ new Je(), ih = /* @__PURE__ */ new Rs();
class ad extends Ne {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = $h, this.bindMatrix = new Je(), this.bindMatrixInverse = new Je(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new bn()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Lc), this.boundingBox.expandByPoint(Lc);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new yn()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Lc), this.boundingSphere.expandByPoint(Lc);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), nh.copy(this.boundingSphere), nh.applyMatrix4(i), e.ray.intersectsSphere(nh) !== !1 && (qp.copy(i).invert(), ih.copy(e.ray).applyMatrix4(qp), !(this.boundingBox !== null && ih.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, ih)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Dt(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === $h ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Wm ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    Hp.fromBufferAttribute(i.attributes.skinIndex, e), Vp.fromBufferAttribute(i.attributes.skinWeight, e), zp.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const a = Vp.getComponent(r);
      if (a !== 0) {
        const o = Hp.getComponent(r);
        Wp.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(PS.copy(zp).applyMatrix4(Wp), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class Zl extends bt {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class pr extends Jt {
  constructor(e = null, t = 1, n = 1, i, r, a, o, c, l = tn, u = tn, h, f) {
    super(null, a, o, c, l, u, i, r, h, f), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const Xp = /* @__PURE__ */ new Je(), US = /* @__PURE__ */ new Je();
class Xo {
  constructor(e = [], t = []) {
    this.uuid = di(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Je());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Je();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let r = 0, a = e.length; r < a; r++) {
      const o = e[r] ? e[r].matrixWorld : US;
      Xp.multiplyMatrices(o, t[r]), Xp.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Xo(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new pr(t, e, e, dn, pn);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let a = t[r];
      a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new Zl()), this.bones.push(a), this.boneInverses.push(new Je().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const o = n[i];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class Nr extends ut {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const sa = /* @__PURE__ */ new Je(), Yp = /* @__PURE__ */ new Je(), Pc = [], jp = /* @__PURE__ */ new bn(), FS = /* @__PURE__ */ new Je(), Ka = /* @__PURE__ */ new Ne(), Za = /* @__PURE__ */ new yn();
class $l extends Ne {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Nr(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, FS);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new bn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, sa), jp.copy(e.boundingBox).applyMatrix4(sa), this.boundingBox.union(jp);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new yn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, sa), Za.copy(e.boundingSphere).applyMatrix4(sa), this.boundingSphere.union(Za);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (Ka.geometry = this.geometry, Ka.material = this.material, Ka.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Za.copy(this.boundingSphere), Za.applyMatrix4(n), e.ray.intersectsSphere(Za) !== !1))
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, sa), Yp.multiplyMatrices(n, sa), Ka.matrixWorld = Yp, Ka.raycast(e, Pc);
        for (let a = 0, o = Pc.length; a < o; a++) {
          const c = Pc[a];
          c.instanceId = r, c.object = this, t.push(c);
        }
        Pc.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Nr(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function kS(s, e) {
  return s.z - e.z;
}
function NS(s, e) {
  return e.z - s.z;
}
class OS {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, i = this.list;
    this.index >= n.length && n.push({
      start: -1,
      count: -1,
      z: -1
    });
    const r = n[this.index];
    i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const aa = "batchId", Sr = /* @__PURE__ */ new Je(), Jp = /* @__PURE__ */ new Je(), QS = /* @__PURE__ */ new Je(), Kp = /* @__PURE__ */ new Je(), rh = /* @__PURE__ */ new Vo(), Uc = /* @__PURE__ */ new bn(), Kr = /* @__PURE__ */ new yn(), $a = /* @__PURE__ */ new P(), sh = /* @__PURE__ */ new OS(), zn = /* @__PURE__ */ new Ne(), Fc = [];
function GS(s, e, t = 0) {
  const n = e.itemSize;
  if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
    const i = s.count;
    for (let r = 0; r < i; r++)
      for (let a = 0; a < n; a++)
        e.setComponent(r + t, a, s.getComponent(r, a));
  } else
    e.array.set(s.array, t * n);
  e.needsUpdate = !0;
}
class w0 extends Ne {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new ot(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new pr(t, e, e, dn, pn);
    this._matricesTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const c = e.getAttribute(o), { array: l, itemSize: u, normalized: h } = c, f = new l.constructor(n * u), d = new c.constructor(f, u, h);
        d.setUsage(c.usage), t.setAttribute(o, d);
      }
      if (e.getIndex() !== null) {
        const o = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new ut(o, 1));
      }
      const a = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(aa, new ut(a, 1)), this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry atributes
  _validateGeometry(e) {
    if (e.getAttribute(aa))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${aa}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === aa)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), r = t.getAttribute(n);
      if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bn());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, Sr), this.getBoundingBoxAt(i, Uc).applyMatrix4(Sr), t.union(Uc));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yn());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, Sr), this.getBoundingSphereAt(i, Kr).applyMatrix4(Sr), t.union(Kr));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let r = null;
    const a = this._reservedRanges, o = this._drawRanges, c = this._bounds;
    this._geometryCount !== 0 && (r = a[a.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
    const l = e.getIndex(), u = l !== null;
    if (u && (n === -1 ? i.indexCount = l.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const h = this._visibility, f = this._active, d = this._matricesTexture, A = this._matricesTexture.image.data;
    h.push(!0), f.push(!0);
    const m = this._geometryCount;
    this._geometryCount++, QS.toArray(A, m * 16), d.needsUpdate = !0, a.push(i), o.push({
      start: u ? i.indexStart : i.vertexStart,
      count: -1
    }), c.push({
      boxInitialized: !1,
      box: new bn(),
      sphereInitialized: !1,
      sphere: new yn()
    });
    const p = this.geometry.getAttribute(aa);
    for (let g = 0; g < i.vertexCount; g++)
      p.setX(i.vertexStart + g, m);
    return p.needsUpdate = !0, this.setGeometryAt(m, e), m;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), a = t.getIndex(), o = this._reservedRanges[e];
    if (i && a.count > o.indexCount || t.attributes.position.count > o.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const c = o.vertexStart, l = o.vertexCount;
    for (const d in n.attributes) {
      if (d === aa)
        continue;
      const A = t.getAttribute(d), m = n.getAttribute(d);
      GS(A, m, c);
      const p = A.itemSize;
      for (let g = A.count, _ = l; g < _; g++) {
        const b = c + g;
        for (let y = 0; y < p; y++)
          m.setComponent(b, y, 0);
      }
      m.needsUpdate = !0;
    }
    if (i) {
      const d = o.indexStart;
      for (let A = 0; A < a.count; A++)
        r.setX(d + A, c + a.getX(A));
      for (let A = a.count, m = o.indexCount; A < m; A++)
        r.setX(d + A, c);
      r.needsUpdate = !0;
    }
    const u = this._bounds[e];
    t.boundingBox !== null ? (u.box.copy(t.boundingBox), u.boxInitialized = !0) : u.boxInitialized = !1, t.boundingSphere !== null ? (u.sphere.copy(t.boundingSphere), u.sphereInitialized = !0) : u.sphereInitialized = !1;
    const h = this._drawRanges[e], f = t.getAttribute("position");
    return h.count = i ? a.count : f.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.box, a = this.geometry;
    if (i.boxInitialized === !1) {
      r.makeEmpty();
      const o = a.index, c = a.attributes.position, l = this._drawRanges[e];
      for (let u = l.start, h = l.start + l.count; u < h; u++) {
        let f = u;
        o && (f = o.getX(f)), r.expandByPoint($a.fromBufferAttribute(c, f));
      }
      i.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.sphere, a = this.geometry;
    if (i.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, Uc), Uc.getCenter(r.center);
      const o = a.index, c = a.attributes.position, l = this._drawRanges[e];
      let u = 0;
      for (let h = l.start, f = l.start + l.count; h < f; h++) {
        let d = h;
        o && (d = o.getX(d)), $a.fromBufferAttribute(c, d), u = Math.max(u, r.center.distanceToSquared($a));
      }
      r.radius = Math.sqrt(u), i.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, a = this._geometryCount;
    return e >= a || n[e] === !1 ? this : (t.toArray(r, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
    return e >= r || n[e] === !1 ? null : t.fromArray(i, e * 16);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active, i = this._geometryCount;
    return e >= i || n[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const n = this._visibility, i = this._active, r = this._drawRanges, a = this._geometryCount, o = this.matrixWorld, c = this.geometry;
    zn.material = this.material, zn.geometry.index = c.index, zn.geometry.attributes = c.attributes, zn.geometry.boundingBox === null && (zn.geometry.boundingBox = new bn()), zn.geometry.boundingSphere === null && (zn.geometry.boundingSphere = new yn());
    for (let l = 0; l < a; l++) {
      if (!n[l] || !i[l])
        continue;
      const u = r[l];
      zn.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(l, zn.matrixWorld).premultiply(o), this.getBoundingBoxAt(l, zn.geometry.boundingBox), this.getBoundingSphereAt(l, zn.geometry.boundingSphere), zn.raycast(e, Fc);
      for (let h = 0, f = Fc.length; h < f; h++) {
        const d = Fc[h];
        d.object = this, d.batchId = l, t.push(d);
      }
      Fc.length = 0;
    }
    zn.material = null, zn.geometry.index = null, zn.geometry.attributes = {}, zn.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, n, i, r) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const a = i.getIndex(), o = a === null ? 1 : a.array.BYTES_PER_ELEMENT, c = this._visibility, l = this._multiDrawStarts, u = this._multiDrawCounts, h = this._drawRanges, f = this.perObjectFrustumCulled;
    f && (Kp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), rh.setFromProjectionMatrix(
      Kp,
      e.isWebGPURenderer ? Ea : Di
    ));
    let d = 0;
    if (this.sortObjects) {
      Jp.copy(this.matrixWorld).invert(), $a.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Jp);
      for (let p = 0, g = c.length; p < g; p++)
        if (c[p]) {
          this.getMatrixAt(p, Sr), this.getBoundingSphereAt(p, Kr).applyMatrix4(Sr);
          let _ = !1;
          if (f && (_ = !rh.intersectsSphere(Kr)), !_) {
            const b = $a.distanceTo(Kr.center);
            sh.push(h[p], b);
          }
        }
      const A = sh.list, m = this.customSort;
      m === null ? A.sort(r.transparent ? NS : kS) : m.call(this, A, n);
      for (let p = 0, g = A.length; p < g; p++) {
        const _ = A[p];
        l[d] = _.start * o, u[d] = _.count, d++;
      }
      sh.reset();
    } else
      for (let A = 0, m = c.length; A < m; A++)
        if (c[A]) {
          let p = !1;
          if (f && (this.getMatrixAt(A, Sr), this.getBoundingSphereAt(A, Kr).applyMatrix4(Sr), p = !rh.intersectsSphere(Kr)), !p) {
            const g = h[A];
            l[d] = g.start * o, u[d] = g.count, d++;
          }
        }
    this._multiDrawCount = d, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, r, a) {
    this.onBeforeRender(e, null, i, r, a);
  }
}
class kn extends vn {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Pe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Zp = /* @__PURE__ */ new P(), $p = /* @__PURE__ */ new P(), eA = /* @__PURE__ */ new Je(), ah = /* @__PURE__ */ new Rs(), kc = /* @__PURE__ */ new yn();
class Dn extends bt {
  constructor(e = new ot(), t = new kn()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        Zp.fromBufferAttribute(t, i - 1), $p.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Zp.distanceTo($p);
      e.setAttribute("lineDistance", new je(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), kc.copy(n.boundingSphere), kc.applyMatrix4(i), kc.radius += r, e.ray.intersectsSphere(kc) === !1)
      return;
    eA.copy(i).invert(), ah.copy(e.ray).applyMatrix4(eA);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = new P(), u = new P(), h = new P(), f = new P(), d = this.isLineSegments ? 2 : 1, A = n.index, p = n.attributes.position;
    if (A !== null) {
      const g = Math.max(0, a.start), _ = Math.min(A.count, a.start + a.count);
      for (let b = g, y = _ - 1; b < y; b += d) {
        const v = A.getX(b), x = A.getX(b + 1);
        if (l.fromBufferAttribute(p, v), u.fromBufferAttribute(p, x), ah.distanceSqToSegment(l, u, f, h) > c)
          continue;
        f.applyMatrix4(this.matrixWorld);
        const I = e.ray.origin.distanceTo(f);
        I < e.near || I > e.far || t.push({
          distance: I,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: h.clone().applyMatrix4(this.matrixWorld),
          index: b,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const g = Math.max(0, a.start), _ = Math.min(p.count, a.start + a.count);
      for (let b = g, y = _ - 1; b < y; b += d) {
        if (l.fromBufferAttribute(p, b), u.fromBufferAttribute(p, b + 1), ah.distanceSqToSegment(l, u, f, h) > c)
          continue;
        f.applyMatrix4(this.matrixWorld);
        const x = e.ray.origin.distanceTo(f);
        x < e.near || x > e.far || t.push({
          distance: x,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: h.clone().applyMatrix4(this.matrixWorld),
          index: b,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
const tA = /* @__PURE__ */ new P(), nA = /* @__PURE__ */ new P();
class Li extends Dn {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        tA.fromBufferAttribute(t, i), nA.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + tA.distanceTo(nA);
      e.setAttribute("lineDistance", new je(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class od extends Dn {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class eu extends vn {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Pe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const iA = /* @__PURE__ */ new Je(), Mf = /* @__PURE__ */ new Rs(), Nc = /* @__PURE__ */ new yn(), Oc = /* @__PURE__ */ new P();
class cd extends bt {
  constructor(e = new ot(), t = new eu()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, a = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Nc.copy(n.boundingSphere), Nc.applyMatrix4(i), Nc.radius += r, e.ray.intersectsSphere(Nc) === !1)
      return;
    iA.copy(i).invert(), Mf.copy(e.ray).applyMatrix4(iA);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = n.index, h = n.attributes.position;
    if (l !== null) {
      const f = Math.max(0, a.start), d = Math.min(l.count, a.start + a.count);
      for (let A = f, m = d; A < m; A++) {
        const p = l.getX(A);
        Oc.fromBufferAttribute(h, p), rA(Oc, p, c, i, e, t, this);
      }
    } else {
      const f = Math.max(0, a.start), d = Math.min(h.count, a.start + a.count);
      for (let A = f, m = d; A < m; A++)
        Oc.fromBufferAttribute(h, A), rA(Oc, A, c, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, a = i.length; r < a; r++) {
          const o = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
        }
      }
    }
  }
}
function rA(s, e, t, n, i, r, a) {
  const o = Mf.distanceSqToPoint(s);
  if (o < t) {
    const c = new P();
    Mf.closestPointToPoint(s, c), c.applyMatrix4(n);
    const l = i.ray.origin.distanceTo(c);
    if (l < i.near || l > i.far)
      return;
    r.push({
      distance: l,
      distanceToRay: Math.sqrt(o),
      point: c,
      index: e,
      face: null,
      object: a
    });
  }
}
class zS extends Jt {
  constructor(e, t, n, i, r, a, o, c, l) {
    super(e, t, n, i, r, a, o, c, l), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : wt, this.magFilter = r !== void 0 ? r : wt, this.generateMipmaps = !1;
    const u = this;
    function h() {
      u.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class HS extends Jt {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = tn, this.minFilter = tn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Ra extends Jt {
  constructor(e, t, n, i, r, a, o, c, l, u, h, f) {
    super(null, a, o, c, l, u, i, r, h, f), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class T0 extends Ra {
  constructor(e, t, n, i, r, a) {
    super(e, t, n, r, a), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Ln;
  }
}
class B0 extends Ra {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Xi), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class R0 extends Jt {
  constructor(e, t, n, i, r, a, o, c, l) {
    super(e, t, n, i, r, a, o, c, l), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Pi {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), r = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      n = this.getPoint(a / e), r += n.distanceTo(i), t.push(r), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let a;
    t ? a = t : a = e * n[r - 1];
    let o = 0, c = r - 1, l;
    for (; o <= c; )
      if (i = Math.floor(o + (c - o) / 2), l = n[i] - a, l < 0)
        o = i + 1;
      else if (l > 0)
        c = i - 1;
      else {
        c = i;
        break;
      }
    if (i = c, n[i] === a)
      return i / (r - 1);
    const u = n[i], f = n[i + 1] - u, d = (a - u) / f;
    return (i + d) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, r = e + 1e-4;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const a = this.getPoint(i), o = this.getPoint(r), c = t || (a.isVector2 ? new xe() : new P());
    return c.copy(o).sub(a).normalize(), c;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new P(), i = [], r = [], a = [], o = new P(), c = new Je();
    for (let d = 0; d <= e; d++) {
      const A = d / e;
      i[d] = this.getTangentAt(A, new P());
    }
    r[0] = new P(), a[0] = new P();
    let l = Number.MAX_VALUE;
    const u = Math.abs(i[0].x), h = Math.abs(i[0].y), f = Math.abs(i[0].z);
    u <= l && (l = u, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), f <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), a[0].crossVectors(i[0], r[0]);
    for (let d = 1; d <= e; d++) {
      if (r[d] = r[d - 1].clone(), a[d] = a[d - 1].clone(), o.crossVectors(i[d - 1], i[d]), o.length() > Number.EPSILON) {
        o.normalize();
        const A = Math.acos(cn(i[d - 1].dot(i[d]), -1, 1));
        r[d].applyMatrix4(c.makeRotationAxis(o, A));
      }
      a[d].crossVectors(i[d], r[d]);
    }
    if (t === !0) {
      let d = Math.acos(cn(r[0].dot(r[e]), -1, 1));
      d /= e, i[0].dot(o.crossVectors(r[0], r[e])) > 0 && (d = -d);
      for (let A = 1; A <= e; A++)
        r[A].applyMatrix4(c.makeRotationAxis(i[A], d * A)), a[A].crossVectors(i[A], r[A]);
    }
    return {
      tangents: i,
      normals: r,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class tu extends Pi {
  constructor(e = 0, t = 0, n = 1, i = 1, r = 0, a = Math.PI * 2, o = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = c;
  }
  getPoint(e, t) {
    const n = t || new xe(), i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(r) < Number.EPSILON;
    for (; r < 0; )
      r += i;
    for (; r > i; )
      r -= i;
    r < Number.EPSILON && (a ? r = 0 : r = i), this.aClockwise === !0 && !a && (r === i ? r = -i : r = r - i);
    const o = this.aStartAngle + e * r;
    let c = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), f = c - this.aX, d = l - this.aY;
      c = f * u - d * h + this.aX, l = f * h + d * u + this.aY;
    }
    return n.set(c, l);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class D0 extends tu {
  constructor(e, t, n, i, r, a) {
    super(e, t, n, n, i, r, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function ld() {
  let s = 0, e = 0, t = 0, n = 0;
  function i(r, a, o, c) {
    s = r, e = o, t = -3 * r + 3 * a - 2 * o - c, n = 2 * r - 2 * a + o + c;
  }
  return {
    initCatmullRom: function(r, a, o, c, l) {
      i(a, o, l * (o - r), l * (c - a));
    },
    initNonuniformCatmullRom: function(r, a, o, c, l, u, h) {
      let f = (a - r) / l - (o - r) / (l + u) + (o - a) / u, d = (o - a) / u - (c - a) / (u + h) + (c - o) / h;
      f *= u, d *= u, i(a, o, f, d);
    },
    calc: function(r) {
      const a = r * r, o = a * r;
      return s + e * r + t * a + n * o;
    }
  };
}
const Qc = /* @__PURE__ */ new P(), oh = /* @__PURE__ */ new ld(), ch = /* @__PURE__ */ new ld(), lh = /* @__PURE__ */ new ld();
class L0 extends Pi {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new P()) {
    const n = t, i = this.points, r = i.length, a = (r - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a), c = a - o;
    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : c === 0 && o === r - 1 && (o = r - 2, c = 1);
    let l, u;
    this.closed || o > 0 ? l = i[(o - 1) % r] : (Qc.subVectors(i[0], i[1]).add(i[0]), l = Qc);
    const h = i[o % r], f = i[(o + 1) % r];
    if (this.closed || o + 2 < r ? u = i[(o + 2) % r] : (Qc.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), u = Qc), this.curveType === "centripetal" || this.curveType === "chordal") {
      const d = this.curveType === "chordal" ? 0.5 : 0.25;
      let A = Math.pow(l.distanceToSquared(h), d), m = Math.pow(h.distanceToSquared(f), d), p = Math.pow(f.distanceToSquared(u), d);
      m < 1e-4 && (m = 1), A < 1e-4 && (A = m), p < 1e-4 && (p = m), oh.initNonuniformCatmullRom(l.x, h.x, f.x, u.x, A, m, p), ch.initNonuniformCatmullRom(l.y, h.y, f.y, u.y, A, m, p), lh.initNonuniformCatmullRom(l.z, h.z, f.z, u.z, A, m, p);
    } else
      this.curveType === "catmullrom" && (oh.initCatmullRom(l.x, h.x, f.x, u.x, this.tension), ch.initCatmullRom(l.y, h.y, f.y, u.y, this.tension), lh.initCatmullRom(l.z, h.z, f.z, u.z, this.tension));
    return n.set(
      oh.calc(c),
      ch.calc(c),
      lh.calc(c)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new P().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function sA(s, e, t, n, i) {
  const r = (n - e) * 0.5, a = (i - t) * 0.5, o = s * s, c = s * o;
  return (2 * t - 2 * n + r + a) * c + (-3 * t + 3 * n - 2 * r - a) * o + r * s + t;
}
function VS(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function WS(s, e) {
  return 2 * (1 - s) * s * e;
}
function qS(s, e) {
  return s * s * e;
}
function yo(s, e, t, n) {
  return VS(s, e) + WS(s, t) + qS(s, n);
}
function XS(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function YS(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function jS(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function JS(s, e) {
  return s * s * s * e;
}
function vo(s, e, t, n, i) {
  return XS(s, e) + YS(s, t) + jS(s, n) + JS(s, i);
}
class ud extends Pi {
  constructor(e = new xe(), t = new xe(), n = new xe(), i = new xe()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new xe()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      vo(e, i.x, r.x, a.x, o.x),
      vo(e, i.y, r.y, a.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class P0 extends Pi {
  constructor(e = new P(), t = new P(), n = new P(), i = new P()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new P()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2, o = this.v3;
    return n.set(
      vo(e, i.x, r.x, a.x, o.x),
      vo(e, i.y, r.y, a.y, o.y),
      vo(e, i.z, r.z, a.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class hd extends Pi {
  constructor(e = new xe(), t = new xe()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new xe()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new xe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class U0 extends Pi {
  constructor(e = new P(), t = new P()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new P()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new P()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class fd extends Pi {
  constructor(e = new xe(), t = new xe(), n = new xe()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new xe()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2;
    return n.set(
      yo(e, i.x, r.x, a.x),
      yo(e, i.y, r.y, a.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class dd extends Pi {
  constructor(e = new P(), t = new P(), n = new P()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new P()) {
    const n = t, i = this.v0, r = this.v1, a = this.v2;
    return n.set(
      yo(e, i.x, r.x, a.x),
      yo(e, i.y, r.y, a.y),
      yo(e, i.z, r.z, a.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class pd extends Pi {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new xe()) {
    const n = t, i = this.points, r = (i.length - 1) * e, a = Math.floor(r), o = r - a, c = i[a === 0 ? a : a - 1], l = i[a], u = i[a > i.length - 2 ? i.length - 1 : a + 1], h = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return n.set(
      sA(o, c.x, l.x, u.x, h.x),
      sA(o, c.y, l.y, u.y, h.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new xe().fromArray(i));
    }
    return this;
  }
}
var Rl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: D0,
  CatmullRomCurve3: L0,
  CubicBezierCurve: ud,
  CubicBezierCurve3: P0,
  EllipseCurve: tu,
  LineCurve: hd,
  LineCurve3: U0,
  QuadraticBezierCurve: fd,
  QuadraticBezierCurve3: dd,
  SplineCurve: pd
});
class F0 extends Pi {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Rl[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const a = i[r] - n, o = this.curves[r], c = o.getLength(), l = c === 0 ? 0 : 1 - a / c;
        return o.getPointAt(l, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const a = r[i], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(o);
      for (let l = 0; l < c.length; l++) {
        const u = c[l];
        n && n.equals(u) || (t.push(u), n = u);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Rl[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Uo extends F0 {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new xe(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new hd(this.currentPoint.clone(), new xe(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const r = new fd(
      this.currentPoint.clone(),
      new xe(e, t),
      new xe(n, i)
    );
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, a) {
    const o = new ud(
      this.currentPoint.clone(),
      new xe(e, t),
      new xe(n, i),
      new xe(r, a)
    );
    return this.curves.push(o), this.currentPoint.set(r, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new pd(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, r, a) {
    const o = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + o,
      t + c,
      n,
      i,
      r,
      a
    ), this;
  }
  absarc(e, t, n, i, r, a) {
    return this.absellipse(e, t, n, n, i, r, a), this;
  }
  ellipse(e, t, n, i, r, a, o, c) {
    const l = this.currentPoint.x, u = this.currentPoint.y;
    return this.absellipse(e + l, t + u, n, i, r, a, o, c), this;
  }
  absellipse(e, t, n, i, r, a, o, c) {
    const l = new tu(e, t, n, i, r, a, o, c);
    if (this.curves.length > 0) {
      const h = l.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(l);
    const u = l.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Yo extends ot {
  constructor(e = [new xe(0, -0.5), new xe(0.5, 0), new xe(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = cn(i, 0, Math.PI * 2);
    const r = [], a = [], o = [], c = [], l = [], u = 1 / t, h = new P(), f = new xe(), d = new P(), A = new P(), m = new P();
    let p = 0, g = 0;
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          p = e[_ + 1].x - e[_].x, g = e[_ + 1].y - e[_].y, d.x = g * 1, d.y = -p, d.z = g * 0, m.copy(d), d.normalize(), c.push(d.x, d.y, d.z);
          break;
        case e.length - 1:
          c.push(m.x, m.y, m.z);
          break;
        default:
          p = e[_ + 1].x - e[_].x, g = e[_ + 1].y - e[_].y, d.x = g * 1, d.y = -p, d.z = g * 0, A.copy(d), d.x += m.x, d.y += m.y, d.z += m.z, d.normalize(), c.push(d.x, d.y, d.z), m.copy(A);
      }
    for (let _ = 0; _ <= t; _++) {
      const b = n + _ * u * i, y = Math.sin(b), v = Math.cos(b);
      for (let x = 0; x <= e.length - 1; x++) {
        h.x = e[x].x * y, h.y = e[x].y, h.z = e[x].x * v, a.push(h.x, h.y, h.z), f.x = _ / t, f.y = x / (e.length - 1), o.push(f.x, f.y);
        const S = c[3 * x + 0] * y, I = c[3 * x + 1], E = c[3 * x + 0] * v;
        l.push(S, I, E);
      }
    }
    for (let _ = 0; _ < t; _++)
      for (let b = 0; b < e.length - 1; b++) {
        const y = b + _ * e.length, v = y, x = y + e.length, S = y + e.length + 1, I = y + 1;
        r.push(v, x, I), r.push(S, I, x);
      }
    this.setIndex(r), this.setAttribute("position", new je(a, 3)), this.setAttribute("uv", new je(o, 2)), this.setAttribute("normal", new je(l, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Yo(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class jo extends Yo {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const r = new Uo();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new jo(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class nu extends ot {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const r = [], a = [], o = [], c = [], l = new P(), u = new xe();
    a.push(0, 0, 0), o.push(0, 0, 1), c.push(0.5, 0.5);
    for (let h = 0, f = 3; h <= t; h++, f += 3) {
      const d = n + h / t * i;
      l.x = e * Math.cos(d), l.y = e * Math.sin(d), a.push(l.x, l.y, l.z), o.push(0, 0, 1), u.x = (a[f] / e + 1) / 2, u.y = (a[f + 1] / e + 1) / 2, c.push(u.x, u.y);
    }
    for (let h = 1; h <= t; h++)
      r.push(h, h + 1, 0);
    this.setIndex(r), this.setAttribute("position", new je(a, 3)), this.setAttribute("normal", new je(o, 3)), this.setAttribute("uv", new je(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nu(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class hn extends ot {
  constructor(e = 1, t = 1, n = 1, i = 32, r = 1, a = !1, o = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: a,
      thetaStart: o,
      thetaLength: c
    };
    const l = this;
    i = Math.floor(i), r = Math.floor(r);
    const u = [], h = [], f = [], d = [];
    let A = 0;
    const m = [], p = n / 2;
    let g = 0;
    _(), a === !1 && (e > 0 && b(!0), t > 0 && b(!1)), this.setIndex(u), this.setAttribute("position", new je(h, 3)), this.setAttribute("normal", new je(f, 3)), this.setAttribute("uv", new je(d, 2));
    function _() {
      const y = new P(), v = new P();
      let x = 0;
      const S = (t - e) / n;
      for (let I = 0; I <= r; I++) {
        const E = [], M = I / r, T = M * (t - e) + e;
        for (let D = 0; D <= i; D++) {
          const F = D / i, C = F * c + o, R = Math.sin(C), O = Math.cos(C);
          v.x = T * R, v.y = -M * n + p, v.z = T * O, h.push(v.x, v.y, v.z), y.set(R, S, O).normalize(), f.push(y.x, y.y, y.z), d.push(F, 1 - M), E.push(A++);
        }
        m.push(E);
      }
      for (let I = 0; I < i; I++)
        for (let E = 0; E < r; E++) {
          const M = m[E][I], T = m[E + 1][I], D = m[E + 1][I + 1], F = m[E][I + 1];
          u.push(M, T, F), u.push(T, D, F), x += 6;
        }
      l.addGroup(g, x, 0), g += x;
    }
    function b(y) {
      const v = A, x = new xe(), S = new P();
      let I = 0;
      const E = y === !0 ? e : t, M = y === !0 ? 1 : -1;
      for (let D = 1; D <= i; D++)
        h.push(0, p * M, 0), f.push(0, M, 0), d.push(0.5, 0.5), A++;
      const T = A;
      for (let D = 0; D <= i; D++) {
        const C = D / i * c + o, R = Math.cos(C), O = Math.sin(C);
        S.x = E * O, S.y = p * M, S.z = E * R, h.push(S.x, S.y, S.z), f.push(0, M, 0), x.x = R * 0.5 + 0.5, x.y = O * 0.5 * M + 0.5, d.push(x.x, x.y), A++;
      }
      for (let D = 0; D < i; D++) {
        const F = v + D, C = T + D;
        y === !0 ? u.push(C, C + 1, F) : u.push(C + 1, C, F), I += 3;
      }
      l.addGroup(g, I, y === !0 ? 1 : 2), g += I;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new hn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class iu extends hn {
  constructor(e = 1, t = 1, n = 32, i = 1, r = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: a,
      thetaLength: o
    };
  }
  static fromJSON(e) {
    return new iu(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class zr extends ot {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const r = [], a = [];
    o(i), l(n), u(), this.setAttribute("position", new je(r, 3)), this.setAttribute("normal", new je(r.slice(), 3)), this.setAttribute("uv", new je(a, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(_) {
      const b = new P(), y = new P(), v = new P();
      for (let x = 0; x < t.length; x += 3)
        d(t[x + 0], b), d(t[x + 1], y), d(t[x + 2], v), c(b, y, v, _);
    }
    function c(_, b, y, v) {
      const x = v + 1, S = [];
      for (let I = 0; I <= x; I++) {
        S[I] = [];
        const E = _.clone().lerp(y, I / x), M = b.clone().lerp(y, I / x), T = x - I;
        for (let D = 0; D <= T; D++)
          D === 0 && I === x ? S[I][D] = E : S[I][D] = E.clone().lerp(M, D / T);
      }
      for (let I = 0; I < x; I++)
        for (let E = 0; E < 2 * (x - I) - 1; E++) {
          const M = Math.floor(E / 2);
          E % 2 === 0 ? (f(S[I][M + 1]), f(S[I + 1][M]), f(S[I][M])) : (f(S[I][M + 1]), f(S[I + 1][M + 1]), f(S[I + 1][M]));
        }
    }
    function l(_) {
      const b = new P();
      for (let y = 0; y < r.length; y += 3)
        b.x = r[y + 0], b.y = r[y + 1], b.z = r[y + 2], b.normalize().multiplyScalar(_), r[y + 0] = b.x, r[y + 1] = b.y, r[y + 2] = b.z;
    }
    function u() {
      const _ = new P();
      for (let b = 0; b < r.length; b += 3) {
        _.x = r[b + 0], _.y = r[b + 1], _.z = r[b + 2];
        const y = p(_) / 2 / Math.PI + 0.5, v = g(_) / Math.PI + 0.5;
        a.push(y, 1 - v);
      }
      A(), h();
    }
    function h() {
      for (let _ = 0; _ < a.length; _ += 6) {
        const b = a[_ + 0], y = a[_ + 2], v = a[_ + 4], x = Math.max(b, y, v), S = Math.min(b, y, v);
        x > 0.9 && S < 0.1 && (b < 0.2 && (a[_ + 0] += 1), y < 0.2 && (a[_ + 2] += 1), v < 0.2 && (a[_ + 4] += 1));
      }
    }
    function f(_) {
      r.push(_.x, _.y, _.z);
    }
    function d(_, b) {
      const y = _ * 3;
      b.x = e[y + 0], b.y = e[y + 1], b.z = e[y + 2];
    }
    function A() {
      const _ = new P(), b = new P(), y = new P(), v = new P(), x = new xe(), S = new xe(), I = new xe();
      for (let E = 0, M = 0; E < r.length; E += 9, M += 6) {
        _.set(r[E + 0], r[E + 1], r[E + 2]), b.set(r[E + 3], r[E + 4], r[E + 5]), y.set(r[E + 6], r[E + 7], r[E + 8]), x.set(a[M + 0], a[M + 1]), S.set(a[M + 2], a[M + 3]), I.set(a[M + 4], a[M + 5]), v.copy(_).add(b).add(y).divideScalar(3);
        const T = p(v);
        m(x, M + 0, _, T), m(S, M + 2, b, T), m(I, M + 4, y, T);
      }
    }
    function m(_, b, y, v) {
      v < 0 && _.x === 1 && (a[b] = _.x - 1), y.x === 0 && y.z === 0 && (a[b] = v / 2 / Math.PI + 0.5);
    }
    function p(_) {
      return Math.atan2(_.z, -_.x);
    }
    function g(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new zr(e.vertices, e.indices, e.radius, e.details);
  }
}
class ru extends zr {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (1/, , 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], a = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ru(e.radius, e.detail);
  }
}
const Gc = /* @__PURE__ */ new P(), zc = /* @__PURE__ */ new P(), uh = /* @__PURE__ */ new P(), Hc = /* @__PURE__ */ new ii();
class k0 extends ot {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), r = Math.cos(vs * t), a = e.getIndex(), o = e.getAttribute("position"), c = a ? a.count : o.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), f = {}, d = [];
      for (let A = 0; A < c; A += 3) {
        a ? (l[0] = a.getX(A), l[1] = a.getX(A + 1), l[2] = a.getX(A + 2)) : (l[0] = A, l[1] = A + 1, l[2] = A + 2);
        const { a: m, b: p, c: g } = Hc;
        if (m.fromBufferAttribute(o, l[0]), p.fromBufferAttribute(o, l[1]), g.fromBufferAttribute(o, l[2]), Hc.getNormal(uh), h[0] = `${Math.round(m.x * i)},${Math.round(m.y * i)},${Math.round(m.z * i)}`, h[1] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(p.z * i)}`, h[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(g.z * i)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
          for (let _ = 0; _ < 3; _++) {
            const b = (_ + 1) % 3, y = h[_], v = h[b], x = Hc[u[_]], S = Hc[u[b]], I = `${y}_${v}`, E = `${v}_${y}`;
            E in f && f[E] ? (uh.dot(f[E].normal) <= r && (d.push(x.x, x.y, x.z), d.push(S.x, S.y, S.z)), f[E] = null) : I in f || (f[I] = {
              index0: l[_],
              index1: l[b],
              normal: uh.clone()
            });
          }
      }
      for (const A in f)
        if (f[A]) {
          const { index0: m, index1: p } = f[A];
          Gc.fromBufferAttribute(o, m), zc.fromBufferAttribute(o, p), d.push(Gc.x, Gc.y, Gc.z), d.push(zc.x, zc.y, zc.z);
        }
      this.setAttribute("position", new je(d, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Pr extends Uo {
  constructor(e) {
    super(e), this.uuid = di(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Uo().fromJSON(i));
    }
    return this;
  }
}
const KS = {
  triangulate: function(s, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : s.length;
    let r = N0(s, 0, i, t, !0);
    const a = [];
    if (!r || r.next === r.prev)
      return a;
    let o, c, l, u, h, f, d;
    if (n && (r = nC(s, e, r, t)), s.length > 80 * t) {
      o = l = s[0], c = u = s[1];
      for (let A = t; A < i; A += t)
        h = s[A], f = s[A + 1], h < o && (o = h), f < c && (c = f), h > l && (l = h), f > u && (u = f);
      d = Math.max(l - o, u - c), d = d !== 0 ? 32767 / d : 0;
    }
    return Fo(r, a, t, o, c, d, 0), a;
  }
};
function N0(s, e, t, n, i) {
  let r, a;
  if (i === dC(s, e, t, n) > 0)
    for (r = e; r < t; r += n)
      a = aA(r, s[r], s[r + 1], a);
  else
    for (r = t - n; r >= e; r -= n)
      a = aA(r, s[r], s[r + 1], a);
  return a && su(a, a.next) && (No(a), a = a.next), a;
}
function Ms(s, e) {
  if (!s)
    return s;
  e || (e = s);
  let t = s, n;
  do
    if (n = !1, !t.steiner && (su(t, t.next) || nn(t.prev, t, t.next) === 0)) {
      if (No(t), t = e = t.prev, t === t.next)
        break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Fo(s, e, t, n, i, r, a) {
  if (!s)
    return;
  !a && r && oC(s, n, i, r);
  let o = s, c, l;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, l = s.next, r ? $S(s, n, i, r) : ZS(s)) {
      e.push(c.i / t | 0), e.push(s.i / t | 0), e.push(l.i / t | 0), No(s), s = l.next, o = l.next;
      continue;
    }
    if (s = l, s === o) {
      a ? a === 1 ? (s = eC(Ms(s), e, t), Fo(s, e, t, n, i, r, 2)) : a === 2 && tC(s, e, t, n, i, r) : Fo(Ms(s), e, t, n, i, r, 1);
      break;
    }
  }
}
function ZS(s) {
  const e = s.prev, t = s, n = s.next;
  if (nn(e, t, n) >= 0)
    return !1;
  const i = e.x, r = t.x, a = n.x, o = e.y, c = t.y, l = n.y, u = i < r ? i < a ? i : a : r < a ? r : a, h = o < c ? o < l ? o : l : c < l ? c : l, f = i > r ? i > a ? i : a : r > a ? r : a, d = o > c ? o > l ? o : l : c > l ? c : l;
  let A = n.next;
  for (; A !== e; ) {
    if (A.x >= u && A.x <= f && A.y >= h && A.y <= d && fa(i, o, r, c, a, l, A.x, A.y) && nn(A.prev, A, A.next) >= 0)
      return !1;
    A = A.next;
  }
  return !0;
}
function $S(s, e, t, n) {
  const i = s.prev, r = s, a = s.next;
  if (nn(i, r, a) >= 0)
    return !1;
  const o = i.x, c = r.x, l = a.x, u = i.y, h = r.y, f = a.y, d = o < c ? o < l ? o : l : c < l ? c : l, A = u < h ? u < f ? u : f : h < f ? h : f, m = o > c ? o > l ? o : l : c > l ? c : l, p = u > h ? u > f ? u : f : h > f ? h : f, g = If(d, A, e, t, n), _ = If(m, p, e, t, n);
  let b = s.prevZ, y = s.nextZ;
  for (; b && b.z >= g && y && y.z <= _; ) {
    if (b.x >= d && b.x <= m && b.y >= A && b.y <= p && b !== i && b !== a && fa(o, u, c, h, l, f, b.x, b.y) && nn(b.prev, b, b.next) >= 0 || (b = b.prevZ, y.x >= d && y.x <= m && y.y >= A && y.y <= p && y !== i && y !== a && fa(o, u, c, h, l, f, y.x, y.y) && nn(y.prev, y, y.next) >= 0))
      return !1;
    y = y.nextZ;
  }
  for (; b && b.z >= g; ) {
    if (b.x >= d && b.x <= m && b.y >= A && b.y <= p && b !== i && b !== a && fa(o, u, c, h, l, f, b.x, b.y) && nn(b.prev, b, b.next) >= 0)
      return !1;
    b = b.prevZ;
  }
  for (; y && y.z <= _; ) {
    if (y.x >= d && y.x <= m && y.y >= A && y.y <= p && y !== i && y !== a && fa(o, u, c, h, l, f, y.x, y.y) && nn(y.prev, y, y.next) >= 0)
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function eC(s, e, t) {
  let n = s;
  do {
    const i = n.prev, r = n.next.next;
    !su(i, r) && O0(i, n, n.next, r) && ko(i, r) && ko(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), No(n), No(n.next), n = s = r), n = n.next;
  } while (n !== s);
  return Ms(n);
}
function tC(s, e, t, n, i, r) {
  let a = s;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && uC(a, o)) {
        let c = Q0(a, o);
        a = Ms(a, a.next), c = Ms(c, c.next), Fo(a, e, t, n, i, r, 0), Fo(c, e, t, n, i, r, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== s);
}
function nC(s, e, t, n) {
  const i = [];
  let r, a, o, c, l;
  for (r = 0, a = e.length; r < a; r++)
    o = e[r] * n, c = r < a - 1 ? e[r + 1] * n : s.length, l = N0(s, o, c, n, !1), l === l.next && (l.steiner = !0), i.push(lC(l));
  for (i.sort(iC), r = 0; r < i.length; r++)
    t = rC(i[r], t);
  return t;
}
function iC(s, e) {
  return s.x - e.x;
}
function rC(s, e) {
  const t = sC(s, e);
  if (!t)
    return e;
  const n = Q0(t, s);
  return Ms(n, n.next), Ms(t, t.next);
}
function sC(s, e) {
  let t = e, n = -1 / 0, i;
  const r = s.x, a = s.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const f = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (f <= r && f > n && (n = f, i = t.x < t.next.x ? t : t.next, f === r))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i)
    return null;
  const o = i, c = i.x, l = i.y;
  let u = 1 / 0, h;
  t = i;
  do
    r >= t.x && t.x >= c && r !== t.x && fa(a < l ? r : n, a, c, l, a < l ? n : r, a, t.x, t.y) && (h = Math.abs(a - t.y) / (r - t.x), ko(t, s) && (h < u || h === u && (t.x > i.x || t.x === i.x && aC(i, t))) && (i = t, u = h)), t = t.next;
  while (t !== o);
  return i;
}
function aC(s, e) {
  return nn(s.prev, s, e.prev) < 0 && nn(e.next, s, s.next) < 0;
}
function oC(s, e, t, n) {
  let i = s;
  do
    i.z === 0 && (i.z = If(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s);
  i.prevZ.nextZ = null, i.prevZ = null, cC(i);
}
function cC(s) {
  let e, t, n, i, r, a, o, c, l = 1;
  do {
    for (t = s, s = null, r = null, a = 0; t; ) {
      for (a++, n = t, o = 0, e = 0; e < l && (o++, n = n.nextZ, !!n); e++)
        ;
      for (c = l; o > 0 || c > 0 && n; )
        o !== 0 && (c === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, o--) : (i = n, n = n.nextZ, c--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
      t = n;
    }
    r.nextZ = null, l *= 2;
  } while (a > 1);
  return s;
}
function If(s, e, t, n, i) {
  return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function lC(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function fa(s, e, t, n, i, r, a, o) {
  return (i - a) * (e - o) >= (s - a) * (r - o) && (s - a) * (n - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (i - a) * (n - o);
}
function uC(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !hC(s, e) && // dones't intersect other edges
  (ko(s, e) && ko(e, s) && fC(s, e) && // locally visible
  (nn(s.prev, s, e.prev) || nn(s, e.prev, e)) || // does not create opposite-facing sectors
  su(s, e) && nn(s.prev, s, s.next) > 0 && nn(e.prev, e, e.next) > 0);
}
function nn(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function su(s, e) {
  return s.x === e.x && s.y === e.y;
}
function O0(s, e, t, n) {
  const i = Wc(nn(s, e, t)), r = Wc(nn(s, e, n)), a = Wc(nn(t, n, s)), o = Wc(nn(t, n, e));
  return !!(i !== r && a !== o || i === 0 && Vc(s, t, e) || r === 0 && Vc(s, n, e) || a === 0 && Vc(t, s, n) || o === 0 && Vc(t, e, n));
}
function Vc(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function Wc(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function hC(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && O0(t, t.next, s, e))
      return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function ko(s, e) {
  return nn(s.prev, s, s.next) < 0 ? nn(s, e, s.next) >= 0 && nn(s, s.prev, e) >= 0 : nn(s, e, s.prev) < 0 || nn(s, s.next, e) < 0;
}
function fC(s, e) {
  let t = s, n = !1;
  const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== s);
  return n;
}
function Q0(s, e) {
  const t = new wf(s.i, s.x, s.y), n = new wf(e.i, e.x, e.y), i = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function aA(s, e, t, n) {
  const i = new wf(s, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function No(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function wf(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function dC(s, e, t, n) {
  let i = 0;
  for (let r = e, a = t - n; r < t; r += n)
    i += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
  return i;
}
class qi {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, r = 0; r < t; i = r++)
      n += e[i].x * e[r].y - e[r].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return qi.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], r = [];
    oA(e), cA(n, e);
    let a = e.length;
    t.forEach(oA);
    for (let c = 0; c < t.length; c++)
      i.push(a), a += t[c].length, cA(n, t[c]);
    const o = KS.triangulate(n, i);
    for (let c = 0; c < o.length; c += 3)
      r.push(o.slice(c, c + 3));
    return r;
  }
}
function oA(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function cA(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class au extends ot {
  constructor(e = new Pr([new xe(0.5, 0.5), new xe(-0.5, 0.5), new xe(-0.5, -0.5), new xe(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], r = [];
    for (let o = 0, c = e.length; o < c; o++) {
      const l = e[o];
      a(l);
    }
    this.setAttribute("position", new je(i, 3)), this.setAttribute("uv", new je(r, 2)), this.computeVertexNormals();
    function a(o) {
      const c = [], l = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
      let f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, d = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, A = t.bevelSize !== void 0 ? t.bevelSize : d - 0.1, m = t.bevelOffset !== void 0 ? t.bevelOffset : 0, p = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath, _ = t.UVGenerator !== void 0 ? t.UVGenerator : pC;
      let b, y = !1, v, x, S, I;
      g && (b = g.getSpacedPoints(u), y = !0, f = !1, v = g.computeFrenetFrames(u, !1), x = new P(), S = new P(), I = new P()), f || (p = 0, d = 0, A = 0, m = 0);
      const E = o.extractPoints(l);
      let M = E.shape;
      const T = E.holes;
      if (!qi.isClockWise(M)) {
        M = M.reverse();
        for (let U = 0, ye = T.length; U < ye; U++) {
          const ie = T[U];
          qi.isClockWise(ie) && (T[U] = ie.reverse());
        }
      }
      const F = qi.triangulateShape(M, T), C = M;
      for (let U = 0, ye = T.length; U < ye; U++) {
        const ie = T[U];
        M = M.concat(ie);
      }
      function R(U, ye, ie) {
        return ye || console.error("THREE.ExtrudeGeometry: vec does not exist"), U.clone().addScaledVector(ye, ie);
      }
      const O = M.length, V = F.length;
      function q(U, ye, ie) {
        let re, te, Ie;
        const se = U.x - ye.x, K = U.y - ye.y, ve = ie.x - U.x, fe = ie.y - U.y, oe = se * se + K * K, L = se * fe - K * ve;
        if (Math.abs(L) > Number.EPSILON) {
          const B = Math.sqrt(oe), W = Math.sqrt(ve * ve + fe * fe), de = ye.x - K / B, Ae = ye.y + se / B, G = ie.x - fe / W, Ce = ie.y + ve / W, Se = ((G - de) * fe - (Ce - Ae) * ve) / (se * fe - K * ve);
          re = de + se * Se - U.x, te = Ae + K * Se - U.y;
          const De = re * re + te * te;
          if (De <= 2)
            return new xe(re, te);
          Ie = Math.sqrt(De / 2);
        } else {
          let B = !1;
          se > Number.EPSILON ? ve > Number.EPSILON && (B = !0) : se < -Number.EPSILON ? ve < -Number.EPSILON && (B = !0) : Math.sign(K) === Math.sign(fe) && (B = !0), B ? (re = -K, te = se, Ie = Math.sqrt(oe)) : (re = se, te = K, Ie = Math.sqrt(oe / 2));
        }
        return new xe(re / Ie, te / Ie);
      }
      const z = [];
      for (let U = 0, ye = C.length, ie = ye - 1, re = U + 1; U < ye; U++, ie++, re++)
        ie === ye && (ie = 0), re === ye && (re = 0), z[U] = q(C[U], C[ie], C[re]);
      const X = [];
      let w, N = z.concat();
      for (let U = 0, ye = T.length; U < ye; U++) {
        const ie = T[U];
        w = [];
        for (let re = 0, te = ie.length, Ie = te - 1, se = re + 1; re < te; re++, Ie++, se++)
          Ie === te && (Ie = 0), se === te && (se = 0), w[re] = q(ie[re], ie[Ie], ie[se]);
        X.push(w), N = N.concat(w);
      }
      for (let U = 0; U < p; U++) {
        const ye = U / p, ie = d * Math.cos(ye * Math.PI / 2), re = A * Math.sin(ye * Math.PI / 2) + m;
        for (let te = 0, Ie = C.length; te < Ie; te++) {
          const se = R(C[te], z[te], re);
          ee(se.x, se.y, -ie);
        }
        for (let te = 0, Ie = T.length; te < Ie; te++) {
          const se = T[te];
          w = X[te];
          for (let K = 0, ve = se.length; K < ve; K++) {
            const fe = R(se[K], w[K], re);
            ee(fe.x, fe.y, -ie);
          }
        }
      }
      const H = A + m;
      for (let U = 0; U < O; U++) {
        const ye = f ? R(M[U], N[U], H) : M[U];
        y ? (S.copy(v.normals[0]).multiplyScalar(ye.x), x.copy(v.binormals[0]).multiplyScalar(ye.y), I.copy(b[0]).add(S).add(x), ee(I.x, I.y, I.z)) : ee(ye.x, ye.y, 0);
      }
      for (let U = 1; U <= u; U++)
        for (let ye = 0; ye < O; ye++) {
          const ie = f ? R(M[ye], N[ye], H) : M[ye];
          y ? (S.copy(v.normals[U]).multiplyScalar(ie.x), x.copy(v.binormals[U]).multiplyScalar(ie.y), I.copy(b[U]).add(S).add(x), ee(I.x, I.y, I.z)) : ee(ie.x, ie.y, h / u * U);
        }
      for (let U = p - 1; U >= 0; U--) {
        const ye = U / p, ie = d * Math.cos(ye * Math.PI / 2), re = A * Math.sin(ye * Math.PI / 2) + m;
        for (let te = 0, Ie = C.length; te < Ie; te++) {
          const se = R(C[te], z[te], re);
          ee(se.x, se.y, h + ie);
        }
        for (let te = 0, Ie = T.length; te < Ie; te++) {
          const se = T[te];
          w = X[te];
          for (let K = 0, ve = se.length; K < ve; K++) {
            const fe = R(se[K], w[K], re);
            y ? ee(fe.x, fe.y + b[u - 1].y, b[u - 1].x + ie) : ee(fe.x, fe.y, h + ie);
          }
        }
      }
      j(), $();
      function j() {
        const U = i.length / 3;
        if (f) {
          let ye = 0, ie = O * ye;
          for (let re = 0; re < V; re++) {
            const te = F[re];
            le(te[2] + ie, te[1] + ie, te[0] + ie);
          }
          ye = u + p * 2, ie = O * ye;
          for (let re = 0; re < V; re++) {
            const te = F[re];
            le(te[0] + ie, te[1] + ie, te[2] + ie);
          }
        } else {
          for (let ye = 0; ye < V; ye++) {
            const ie = F[ye];
            le(ie[2], ie[1], ie[0]);
          }
          for (let ye = 0; ye < V; ye++) {
            const ie = F[ye];
            le(ie[0] + O * u, ie[1] + O * u, ie[2] + O * u);
          }
        }
        n.addGroup(U, i.length / 3 - U, 0);
      }
      function $() {
        const U = i.length / 3;
        let ye = 0;
        ce(C, ye), ye += C.length;
        for (let ie = 0, re = T.length; ie < re; ie++) {
          const te = T[ie];
          ce(te, ye), ye += te.length;
        }
        n.addGroup(U, i.length / 3 - U, 1);
      }
      function ce(U, ye) {
        let ie = U.length;
        for (; --ie >= 0; ) {
          const re = ie;
          let te = ie - 1;
          te < 0 && (te = U.length - 1);
          for (let Ie = 0, se = u + p * 2; Ie < se; Ie++) {
            const K = O * Ie, ve = O * (Ie + 1), fe = ye + re + K, oe = ye + te + K, L = ye + te + ve, B = ye + re + ve;
            Z(fe, oe, L, B);
          }
        }
      }
      function ee(U, ye, ie) {
        c.push(U), c.push(ye), c.push(ie);
      }
      function le(U, ye, ie) {
        he(U), he(ye), he(ie);
        const re = i.length / 3, te = _.generateTopUV(n, i, re - 3, re - 2, re - 1);
        _e(te[0]), _e(te[1]), _e(te[2]);
      }
      function Z(U, ye, ie, re) {
        he(U), he(ye), he(re), he(ye), he(ie), he(re);
        const te = i.length / 3, Ie = _.generateSideWallUV(n, i, te - 6, te - 3, te - 2, te - 1);
        _e(Ie[0]), _e(Ie[1]), _e(Ie[3]), _e(Ie[1]), _e(Ie[2]), _e(Ie[3]);
      }
      function he(U) {
        i.push(c[U * 3 + 0]), i.push(c[U * 3 + 1]), i.push(c[U * 3 + 2]);
      }
      function _e(U) {
        r.push(U.x), r.push(U.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return AC(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, a = e.shapes.length; r < a; r++) {
      const o = t[e.shapes[r]];
      n.push(o);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new Rl[i.type]().fromJSON(i)), new au(n, e.options);
  }
}
const pC = {
  generateTopUV: function(s, e, t, n, i) {
    const r = e[t * 3], a = e[t * 3 + 1], o = e[n * 3], c = e[n * 3 + 1], l = e[i * 3], u = e[i * 3 + 1];
    return [
      new xe(r, a),
      new xe(o, c),
      new xe(l, u)
    ];
  },
  generateSideWallUV: function(s, e, t, n, i, r) {
    const a = e[t * 3], o = e[t * 3 + 1], c = e[t * 3 + 2], l = e[n * 3], u = e[n * 3 + 1], h = e[n * 3 + 2], f = e[i * 3], d = e[i * 3 + 1], A = e[i * 3 + 2], m = e[r * 3], p = e[r * 3 + 1], g = e[r * 3 + 2];
    return Math.abs(o - u) < Math.abs(a - l) ? [
      new xe(a, 1 - c),
      new xe(l, 1 - h),
      new xe(f, 1 - A),
      new xe(m, 1 - g)
    ] : [
      new xe(o, 1 - c),
      new xe(u, 1 - h),
      new xe(d, 1 - A),
      new xe(p, 1 - g)
    ];
  }
};
function AC(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Jo extends zr {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Jo(e.radius, e.detail);
  }
}
class hr extends zr {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new hr(e.radius, e.detail);
  }
}
class ou extends ot {
  constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, a = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: a
    }, n = Math.max(3, n), i = Math.max(1, i);
    const o = [], c = [], l = [], u = [];
    let h = e;
    const f = (t - e) / i, d = new P(), A = new xe();
    for (let m = 0; m <= i; m++) {
      for (let p = 0; p <= n; p++) {
        const g = r + p / n * a;
        d.x = h * Math.cos(g), d.y = h * Math.sin(g), c.push(d.x, d.y, d.z), l.push(0, 0, 1), A.x = (d.x / t + 1) / 2, A.y = (d.y / t + 1) / 2, u.push(A.x, A.y);
      }
      h += f;
    }
    for (let m = 0; m < i; m++) {
      const p = m * (n + 1);
      for (let g = 0; g < n; g++) {
        const _ = g + p, b = _, y = _ + n + 1, v = _ + n + 2, x = _ + 1;
        o.push(b, y, x), o.push(y, v, x);
      }
    }
    this.setIndex(o), this.setAttribute("position", new je(c, 3)), this.setAttribute("normal", new je(l, 3)), this.setAttribute("uv", new je(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ou(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class cu extends ot {
  constructor(e = new Pr([new xe(0, 0.5), new xe(-0.5, -0.5), new xe(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], r = [], a = [];
    let o = 0, c = 0;
    if (Array.isArray(e) === !1)
      l(e);
    else
      for (let u = 0; u < e.length; u++)
        l(e[u]), this.addGroup(o, c, u), o += c, c = 0;
    this.setIndex(n), this.setAttribute("position", new je(i, 3)), this.setAttribute("normal", new je(r, 3)), this.setAttribute("uv", new je(a, 2));
    function l(u) {
      const h = i.length / 3, f = u.extractPoints(t);
      let d = f.shape;
      const A = f.holes;
      qi.isClockWise(d) === !1 && (d = d.reverse());
      for (let p = 0, g = A.length; p < g; p++) {
        const _ = A[p];
        qi.isClockWise(_) === !0 && (A[p] = _.reverse());
      }
      const m = qi.triangulateShape(d, A);
      for (let p = 0, g = A.length; p < g; p++) {
        const _ = A[p];
        d = d.concat(_);
      }
      for (let p = 0, g = d.length; p < g; p++) {
        const _ = d[p];
        i.push(_.x, _.y, 0), r.push(0, 0, 1), a.push(_.x, _.y);
      }
      for (let p = 0, g = m.length; p < g; p++) {
        const _ = m[p], b = _[0] + h, y = _[1] + h, v = _[2] + h;
        n.push(b, y, v), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return gC(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, r = e.shapes.length; i < r; i++) {
      const a = t[e.shapes[i]];
      n.push(a);
    }
    return new cu(n, e.curveSegments);
  }
}
function gC(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class Da extends ot {
  constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, a = 0, o = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: a,
      thetaLength: o
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const c = Math.min(a + o, Math.PI);
    let l = 0;
    const u = [], h = new P(), f = new P(), d = [], A = [], m = [], p = [];
    for (let g = 0; g <= n; g++) {
      const _ = [], b = g / n;
      let y = 0;
      g === 0 && a === 0 ? y = 0.5 / t : g === n && c === Math.PI && (y = -0.5 / t);
      for (let v = 0; v <= t; v++) {
        const x = v / t;
        h.x = -e * Math.cos(i + x * r) * Math.sin(a + b * o), h.y = e * Math.cos(a + b * o), h.z = e * Math.sin(i + x * r) * Math.sin(a + b * o), A.push(h.x, h.y, h.z), f.copy(h).normalize(), m.push(f.x, f.y, f.z), p.push(x + y, 1 - b), _.push(l++);
      }
      u.push(_);
    }
    for (let g = 0; g < n; g++)
      for (let _ = 0; _ < t; _++) {
        const b = u[g][_ + 1], y = u[g][_], v = u[g + 1][_], x = u[g + 1][_ + 1];
        (g !== 0 || a > 0) && d.push(b, y, x), (g !== n - 1 || c < Math.PI) && d.push(y, v, x);
      }
    this.setIndex(d), this.setAttribute("position", new je(A, 3)), this.setAttribute("normal", new je(m, 3)), this.setAttribute("uv", new je(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Da(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class lu extends zr {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new lu(e.radius, e.detail);
  }
}
class cr extends ot {
  constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: r
    }, n = Math.floor(n), i = Math.floor(i);
    const a = [], o = [], c = [], l = [], u = new P(), h = new P(), f = new P();
    for (let d = 0; d <= n; d++)
      for (let A = 0; A <= i; A++) {
        const m = A / i * r, p = d / n * Math.PI * 2;
        h.x = (e + t * Math.cos(p)) * Math.cos(m), h.y = (e + t * Math.cos(p)) * Math.sin(m), h.z = t * Math.sin(p), o.push(h.x, h.y, h.z), u.x = e * Math.cos(m), u.y = e * Math.sin(m), f.subVectors(h, u).normalize(), c.push(f.x, f.y, f.z), l.push(A / i), l.push(d / n);
      }
    for (let d = 1; d <= n; d++)
      for (let A = 1; A <= i; A++) {
        const m = (i + 1) * d + A - 1, p = (i + 1) * (d - 1) + A - 1, g = (i + 1) * (d - 1) + A, _ = (i + 1) * d + A;
        a.push(m, p, _), a.push(p, g, _);
      }
    this.setIndex(a), this.setAttribute("position", new je(o, 3)), this.setAttribute("normal", new je(c, 3)), this.setAttribute("uv", new je(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new cr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class uu extends ot {
  constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, a = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: a
    }, n = Math.floor(n), i = Math.floor(i);
    const o = [], c = [], l = [], u = [], h = new P(), f = new P(), d = new P(), A = new P(), m = new P(), p = new P(), g = new P();
    for (let b = 0; b <= n; ++b) {
      const y = b / n * r * Math.PI * 2;
      _(y, r, a, e, d), _(y + 0.01, r, a, e, A), p.subVectors(A, d), g.addVectors(A, d), m.crossVectors(p, g), g.crossVectors(m, p), m.normalize(), g.normalize();
      for (let v = 0; v <= i; ++v) {
        const x = v / i * Math.PI * 2, S = -t * Math.cos(x), I = t * Math.sin(x);
        h.x = d.x + (S * g.x + I * m.x), h.y = d.y + (S * g.y + I * m.y), h.z = d.z + (S * g.z + I * m.z), c.push(h.x, h.y, h.z), f.subVectors(h, d).normalize(), l.push(f.x, f.y, f.z), u.push(b / n), u.push(v / i);
      }
    }
    for (let b = 1; b <= n; b++)
      for (let y = 1; y <= i; y++) {
        const v = (i + 1) * (b - 1) + (y - 1), x = (i + 1) * b + (y - 1), S = (i + 1) * b + y, I = (i + 1) * (b - 1) + y;
        o.push(v, x, I), o.push(x, S, I);
      }
    this.setIndex(o), this.setAttribute("position", new je(c, 3)), this.setAttribute("normal", new je(l, 3)), this.setAttribute("uv", new je(u, 2));
    function _(b, y, v, x, S) {
      const I = Math.cos(b), E = Math.sin(b), M = v / y * b, T = Math.cos(M);
      S.x = x * (2 + T) * 0.5 * I, S.y = x * (2 + T) * E * 0.5, S.z = x * Math.sin(M) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uu(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class hu extends ot {
  constructor(e = new dd(new P(-1, -1, 0), new P(-1, 1, 0), new P(1, 1, 0)), t = 64, n = 1, i = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: r
    };
    const a = e.computeFrenetFrames(t, r);
    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
    const o = new P(), c = new P(), l = new xe();
    let u = new P();
    const h = [], f = [], d = [], A = [];
    m(), this.setIndex(A), this.setAttribute("position", new je(h, 3)), this.setAttribute("normal", new je(f, 3)), this.setAttribute("uv", new je(d, 2));
    function m() {
      for (let b = 0; b < t; b++)
        p(b);
      p(r === !1 ? t : 0), _(), g();
    }
    function p(b) {
      u = e.getPointAt(b / t, u);
      const y = a.normals[b], v = a.binormals[b];
      for (let x = 0; x <= i; x++) {
        const S = x / i * Math.PI * 2, I = Math.sin(S), E = -Math.cos(S);
        c.x = E * y.x + I * v.x, c.y = E * y.y + I * v.y, c.z = E * y.z + I * v.z, c.normalize(), f.push(c.x, c.y, c.z), o.x = u.x + n * c.x, o.y = u.y + n * c.y, o.z = u.z + n * c.z, h.push(o.x, o.y, o.z);
      }
    }
    function g() {
      for (let b = 1; b <= t; b++)
        for (let y = 1; y <= i; y++) {
          const v = (i + 1) * (b - 1) + (y - 1), x = (i + 1) * b + (y - 1), S = (i + 1) * b + y, I = (i + 1) * (b - 1) + y;
          A.push(v, x, I), A.push(x, S, I);
        }
    }
    function _() {
      for (let b = 0; b <= t; b++)
        for (let y = 0; y <= i; y++)
          l.x = b / t, l.y = y / i, d.push(l.x, l.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new hu(
      new Rl[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class G0 extends ot {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new P(), r = new P();
      if (e.index !== null) {
        const a = e.attributes.position, o = e.index;
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let l = 0, u = c.length; l < u; ++l) {
          const h = c[l], f = h.start, d = h.count;
          for (let A = f, m = f + d; A < m; A += 3)
            for (let p = 0; p < 3; p++) {
              const g = o.getX(A + p), _ = o.getX(A + (p + 1) % 3);
              i.fromBufferAttribute(a, g), r.fromBufferAttribute(a, _), lA(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, c = a.count / 3; o < c; o++)
          for (let l = 0; l < 3; l++) {
            const u = 3 * o + l, h = 3 * o + (l + 1) % 3;
            i.fromBufferAttribute(a, u), r.fromBufferAttribute(a, h), lA(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new je(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function lA(s, e, t) {
  const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var uA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: en,
  CapsuleGeometry: jo,
  CircleGeometry: nu,
  ConeGeometry: iu,
  CylinderGeometry: hn,
  DodecahedronGeometry: ru,
  EdgesGeometry: k0,
  ExtrudeGeometry: au,
  IcosahedronGeometry: Jo,
  LatheGeometry: Yo,
  OctahedronGeometry: hr,
  PlaneGeometry: ji,
  PolyhedronGeometry: zr,
  RingGeometry: ou,
  ShapeGeometry: cu,
  SphereGeometry: Da,
  TetrahedronGeometry: lu,
  TorusGeometry: cr,
  TorusKnotGeometry: uu,
  TubeGeometry: hu,
  WireframeGeometry: G0
});
class z0 extends vn {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Pe(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class H0 extends Kn {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class Ko extends vn {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Pe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Ui extends Ko {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new xe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return cn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Pe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Pe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Pe(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class V0 extends vn {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Pe(16777215), this.specular = new Pe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class W0 extends vn {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Pe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class q0 extends vn {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class X0 extends vn {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Pe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Y0 extends vn {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Pe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gr, this.normalScale = new xe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class j0 extends kn {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function bs(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function J0(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function K0(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length, n = new Array(t);
  for (let i = 0; i !== t; ++i)
    n[i] = i;
  return n.sort(e), n;
}
function Tf(s, e, t) {
  const n = s.length, i = new s.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const o = t[r] * e;
    for (let c = 0; c !== e; ++c)
      i[a++] = s[o + c];
  }
  return i;
}
function Ad(s, e, t, n) {
  let i = 1, r = s[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = s[i++];
  if (r === void 0)
    return;
  let a = r[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push.apply(t, a)), r = s[i++];
      while (r !== void 0);
    else if (a.toArray !== void 0)
      do
        a = r[n], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = s[i++];
      while (r !== void 0);
    else
      do
        a = r[n], a !== void 0 && (e.push(r.time), t.push(a)), r = s[i++];
      while (r !== void 0);
}
function mC(s, e, t, n, i = 30) {
  const r = s.clone();
  r.name = e;
  const a = [];
  for (let c = 0; c < r.tracks.length; ++c) {
    const l = r.tracks[c], u = l.getValueSize(), h = [], f = [];
    for (let d = 0; d < l.times.length; ++d) {
      const A = l.times[d] * i;
      if (!(A < t || A >= n)) {
        h.push(l.times[d]);
        for (let m = 0; m < u; ++m)
          f.push(l.values[d * u + m]);
      }
    }
    h.length !== 0 && (l.times = bs(h, l.times.constructor), l.values = bs(f, l.values.constructor), a.push(l));
  }
  r.tracks = a;
  let o = 1 / 0;
  for (let c = 0; c < r.tracks.length; ++c)
    o > r.tracks[c].times[0] && (o = r.tracks[c].times[0]);
  for (let c = 0; c < r.tracks.length; ++c)
    r.tracks[c].shift(-1 * o);
  return r.resetDuration(), r;
}
function _C(s, e = 0, t = s, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, r = e / n;
  for (let a = 0; a < i; ++a) {
    const o = t.tracks[a], c = o.ValueTypeName;
    if (c === "bool" || c === "string")
      continue;
    const l = s.tracks.find(function(g) {
      return g.name === o.name && g.ValueTypeName === c;
    });
    if (l === void 0)
      continue;
    let u = 0;
    const h = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
    let f = 0;
    const d = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3);
    const A = o.times.length - 1;
    let m;
    if (r <= o.times[0]) {
      const g = u, _ = h - u;
      m = o.values.slice(g, _);
    } else if (r >= o.times[A]) {
      const g = A * h + u, _ = g + h - u;
      m = o.values.slice(g, _);
    } else {
      const g = o.createInterpolant(), _ = u, b = h - u;
      g.evaluate(r), m = g.resultBuffer.slice(_, b);
    }
    c === "quaternion" && new Rt().fromArray(m).normalize().conjugate().toArray(m);
    const p = l.times.length;
    for (let g = 0; g < p; ++g) {
      const _ = g * d + f;
      if (c === "quaternion")
        Rt.multiplyQuaternionsFlat(
          l.values,
          _,
          m,
          0,
          l.values,
          _
        );
      else {
        const b = d - f * 2;
        for (let y = 0; y < b; ++y)
          l.values[_ + y] -= m[y];
      }
    }
  }
  return s.blendMode = Yf, s;
}
const bC = {
  convertArray: bs,
  isTypedArray: J0,
  getKeyframeOrder: K0,
  sortedArray: Tf,
  flattenJSON: Ad,
  subclip: mC,
  makeClipAdditive: _C
};
class La {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], r = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i:
            if (!(e < i)) {
              for (let o = n + 2; ; ) {
                if (i === void 0) {
                  if (e < r)
                    break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === o)
                  break;
                if (r = i, i = t[++n], e < i)
                  break t;
              }
              a = t.length;
              break n;
            }
          if (!(e >= r)) {
            const o = t[1];
            e < o && (n = 2, r = o);
            for (let c = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === c)
                break;
              if (i = r, r = t[--n - 1], e >= r)
                break t;
            }
            a = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const o = n + a >>> 1;
          e < t[o] ? a = o : n = o + 1;
        }
        if (i = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
    for (let a = 0; a !== i; ++a)
      t[a] = n[r + a];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class Z0 extends La {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: gs,
      endingEnd: gs
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2, a = e + 1, o = i[r], c = i[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case ms:
          r = e, o = 2 * t - n;
          break;
        case To:
          r = i.length - 2, o = t + i[r] - i[r + 1];
          break;
        default:
          r = e, o = n;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case ms:
          a = e, c = 2 * n - t;
          break;
        case To:
          a = 1, c = n + i[1] - i[0];
          break;
        default:
          a = e - 1, c = t;
      }
    const l = (n - t) * 0.5, u = this.valueSize;
    this._weightPrev = l / (t - o), this._weightNext = l / (c - n), this._offsetPrev = r * u, this._offsetNext = a * u;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, u = this._offsetPrev, h = this._offsetNext, f = this._weightPrev, d = this._weightNext, A = (n - t) / (i - t), m = A * A, p = m * A, g = -f * p + 2 * f * m - f * A, _ = (1 + f) * p + (-1.5 - 2 * f) * m + (-0.5 + f) * A + 1, b = (-1 - d) * p + (1.5 + d) * m + 0.5 * A, y = d * p - d * m;
    for (let v = 0; v !== o; ++v)
      r[v] = g * a[u + v] + _ * a[l + v] + b * a[c + v] + y * a[h + v];
    return r;
  }
}
class gd extends La {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, u = (n - t) / (i - t), h = 1 - u;
    for (let f = 0; f !== o; ++f)
      r[f] = a[l + f] * h + a[c + f] * u;
    return r;
  }
}
class $0 extends La {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Fi {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = bs(t, this.TimeBufferType), this.values = bs(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: bs(e.times, Array),
        values: bs(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new $0(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new gd(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Z0(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case ya:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ss:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case hl:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ya;
      case this.InterpolantFactoryMethodLinear:
        return Ss;
      case this.InterpolantFactoryMethodSmooth:
        return hl;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let r = 0, a = i - 1;
    for (; r !== i && n[r] < e; )
      ++r;
    for (; a !== -1 && n[a] > t; )
      --a;
    if (++a, r !== 0 || a !== i) {
      r >= a && (a = Math.max(a, 1), r = a - 1);
      const o = this.getValueSize();
      this.times = n.slice(r, a), this.values = this.values.slice(r * o, a * o);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let a = null;
    for (let o = 0; o !== r; o++) {
      const c = n[o];
      if (typeof c == "number" && isNaN(c)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), e = !1;
        break;
      }
      if (a !== null && a > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), e = !1;
        break;
      }
      a = c;
    }
    if (i !== void 0 && J0(i))
      for (let o = 0, c = i.length; o !== c; ++o) {
        const l = i[o];
        if (isNaN(l)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === hl, r = e.length - 1;
    let a = 1;
    for (let o = 1; o < r; ++o) {
      let c = !1;
      const l = e[o], u = e[o + 1];
      if (l !== u && (o !== 1 || l !== e[0]))
        if (i)
          c = !0;
        else {
          const h = o * n, f = h - n, d = h + n;
          for (let A = 0; A !== n; ++A) {
            const m = t[h + A];
            if (m !== t[f + A] || m !== t[d + A]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (o !== a) {
          e[a] = e[o];
          const h = o * n, f = a * n;
          for (let d = 0; d !== n; ++d)
            t[f + d] = t[h + d];
        }
        ++a;
      }
    }
    if (r > 0) {
      e[a] = e[r];
      for (let o = r * n, c = a * n, l = 0; l !== n; ++l)
        t[c + l] = t[o + l];
      ++a;
    }
    return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Fi.prototype.TimeBufferType = Float32Array;
Fi.prototype.ValueBufferType = Float32Array;
Fi.prototype.DefaultInterpolation = Ss;
class Ps extends Fi {
}
Ps.prototype.ValueTypeName = "bool";
Ps.prototype.ValueBufferType = Array;
Ps.prototype.DefaultInterpolation = ya;
Ps.prototype.InterpolantFactoryMethodLinear = void 0;
Ps.prototype.InterpolantFactoryMethodSmooth = void 0;
class md extends Fi {
}
md.prototype.ValueTypeName = "color";
class Is extends Fi {
}
Is.prototype.ValueTypeName = "number";
class e_ extends La {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (n - t) / (i - t);
    let l = e * o;
    for (let u = l + o; l !== u; l += 4)
      Rt.slerpFlat(r, 0, a, l - o, a, l, c);
    return r;
  }
}
class Or extends Fi {
  InterpolantFactoryMethodLinear(e) {
    return new e_(this.times, this.values, this.getValueSize(), e);
  }
}
Or.prototype.ValueTypeName = "quaternion";
Or.prototype.DefaultInterpolation = Ss;
Or.prototype.InterpolantFactoryMethodSmooth = void 0;
class Us extends Fi {
}
Us.prototype.ValueTypeName = "string";
Us.prototype.ValueBufferType = Array;
Us.prototype.DefaultInterpolation = ya;
Us.prototype.InterpolantFactoryMethodLinear = void 0;
Us.prototype.InterpolantFactoryMethodSmooth = void 0;
class ws extends Fi {
}
ws.prototype.ValueTypeName = "vector";
class Ca {
  constructor(e, t = -1, n, i = Ol) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = di(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a)
      t.push(vC(n[a]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, a = n.length; r !== a; ++r)
      t.push(Fi.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length, a = [];
    for (let o = 0; o < r; o++) {
      let c = [], l = [];
      c.push(
        (o + r - 1) % r,
        o,
        (o + 1) % r
      ), l.push(0, 1, 0);
      const u = K0(c);
      c = Tf(c, 1, u), l = Tf(l, 1, u), !i && c[0] === 0 && (c.push(r), l.push(l[0])), a.push(
        new Is(
          ".morphTargetInfluences[" + t[o].name + "]",
          c,
          l
        ).scale(1 / n)
      );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, c = e.length; o < c; o++) {
      const l = e[o], u = l.name.match(r);
      if (u && u.length > 1) {
        const h = u[1];
        let f = i[h];
        f || (i[h] = f = []), f.push(l);
      }
    }
    const a = [];
    for (const o in i)
      a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
    return a;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(h, f, d, A, m) {
      if (d.length !== 0) {
        const p = [], g = [];
        Ad(d, p, g, A), p.length !== 0 && m.push(new h(f, p, g));
      }
    }, i = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
    let c = e.length || -1;
    const l = e.hierarchy || [];
    for (let h = 0; h < l.length; h++) {
      const f = l[h].keys;
      if (!(!f || f.length === 0))
        if (f[0].morphTargets) {
          const d = {};
          let A;
          for (A = 0; A < f.length; A++)
            if (f[A].morphTargets)
              for (let m = 0; m < f[A].morphTargets.length; m++)
                d[f[A].morphTargets[m]] = -1;
          for (const m in d) {
            const p = [], g = [];
            for (let _ = 0; _ !== f[A].morphTargets.length; ++_) {
              const b = f[A];
              p.push(b.time), g.push(b.morphTarget === m ? 1 : 0);
            }
            i.push(new Is(".morphTargetInfluence[" + m + "]", p, g));
          }
          c = d.length * a;
        } else {
          const d = ".bones[" + t[h].name + "]";
          n(
            ws,
            d + ".position",
            f,
            "pos",
            i
          ), n(
            Or,
            d + ".quaternion",
            f,
            "rot",
            i
          ), n(
            ws,
            d + ".scale",
            f,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(r, c, i, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function yC(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Is;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ws;
    case "color":
      return md;
    case "quaternion":
      return Or;
    case "bool":
    case "boolean":
      return Ps;
    case "string":
      return Us;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function vC(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = yC(s.type);
  if (s.times === void 0) {
    const t = [], n = [];
    Ad(s.keys, t, n, "value"), s.times = t, s.values = n;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const Ts = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class _d {
  constructor(e, t, n) {
    const i = this;
    let r = !1, a = 0, o = 0, c;
    const l = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
      o++, r === !1 && i.onStart !== void 0 && i.onStart(u, a, o), r = !0;
    }, this.itemEnd = function(u) {
      a++, i.onProgress !== void 0 && i.onProgress(u, a, o), a === o && (r = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(u) {
      i.onError !== void 0 && i.onError(u);
    }, this.resolveURL = function(u) {
      return c ? c(u) : u;
    }, this.setURLModifier = function(u) {
      return c = u, this;
    }, this.addHandler = function(u, h) {
      return l.push(u, h), this;
    }, this.removeHandler = function(u) {
      const h = l.indexOf(u);
      return h !== -1 && l.splice(h, 2), this;
    }, this.getHandler = function(u) {
      for (let h = 0, f = l.length; h < f; h += 2) {
        const d = l[h], A = l[h + 1];
        if (d.global && (d.lastIndex = 0), d.test(u))
          return A;
      }
      return null;
    };
  }
}
const t_ = /* @__PURE__ */ new _d();
class Tn {
  constructor(e) {
    this.manager = e !== void 0 ? e : t_, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Tn.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ir = {};
class EC extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class wn extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Ts.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (ir[e] !== void 0) {
      ir[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    ir[e] = [], ir[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const a = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), o = this.mimeType, c = this.responseType;
    fetch(a).then((l) => {
      if (l.status === 200 || l.status === 0) {
        if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0)
          return l;
        const u = ir[e], h = l.body.getReader(), f = l.headers.get("Content-Length") || l.headers.get("X-File-Size"), d = f ? parseInt(f) : 0, A = d !== 0;
        let m = 0;
        const p = new ReadableStream({
          start(g) {
            _();
            function _() {
              h.read().then(({ done: b, value: y }) => {
                if (b)
                  g.close();
                else {
                  m += y.byteLength;
                  const v = new ProgressEvent("progress", { lengthComputable: A, loaded: m, total: d });
                  for (let x = 0, S = u.length; x < S; x++) {
                    const I = u[x];
                    I.onProgress && I.onProgress(v);
                  }
                  g.enqueue(y), _();
                }
              });
            }
          }
        });
        return new Response(p);
      } else
        throw new EC(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
    }).then((l) => {
      switch (c) {
        case "arraybuffer":
          return l.arrayBuffer();
        case "blob":
          return l.blob();
        case "document":
          return l.text().then((u) => new DOMParser().parseFromString(u, o));
        case "json":
          return l.json();
        default:
          if (o === void 0)
            return l.text();
          {
            const h = /charset="?([^;"\s]*)"?/i.exec(o), f = h && h[1] ? h[1].toLowerCase() : void 0, d = new TextDecoder(f);
            return l.arrayBuffer().then((A) => d.decode(A));
          }
      }
    }).then((l) => {
      Ts.add(e, l);
      const u = ir[e];
      delete ir[e];
      for (let h = 0, f = u.length; h < f; h++) {
        const d = u[h];
        d.onLoad && d.onLoad(l);
      }
    }).catch((l) => {
      const u = ir[e];
      if (u === void 0)
        throw this.manager.itemError(e), l;
      delete ir[e];
      for (let h = 0, f = u.length; h < f; h++) {
        const d = u[h];
        d.onError && d.onError(l);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class xC extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new wn(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Ca.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class SC extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = [], o = new Ra(), c = new wn(this.manager);
    c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(r.withCredentials);
    let l = 0;
    function u(h) {
      c.load(e[h], function(f) {
        const d = r.parse(f, !0);
        a[h] = {
          width: d.width,
          height: d.height,
          format: d.format,
          mipmaps: d.mipmaps
        }, l += 1, l === 6 && (d.mipmapCount === 1 && (o.minFilter = wt), o.image = a, o.format = d.format, o.needsUpdate = !0, t && t(o));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let h = 0, f = e.length; h < f; ++h)
        u(h);
    else
      c.load(e, function(h) {
        const f = r.parse(h, !0);
        if (f.isCubemap) {
          const d = f.mipmaps.length / f.mipmapCount;
          for (let A = 0; A < d; A++) {
            a[A] = { mipmaps: [] };
            for (let m = 0; m < f.mipmapCount; m++)
              a[A].mipmaps.push(f.mipmaps[A * f.mipmapCount + m]), a[A].format = f.format, a[A].width = f.width, a[A].height = f.height;
          }
          o.image = a;
        } else
          o.image.width = f.width, o.image.height = f.height, o.mipmaps = f.mipmaps;
        f.mipmapCount === 1 && (o.minFilter = wt), o.format = f.format, o.needsUpdate = !0, t && t(o);
      }, n, i);
    return o;
  }
}
class Oo extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Ts.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = Po("img");
    function c() {
      u(), Ts.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function l(h) {
      u(), i && i(h), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function u() {
      o.removeEventListener("load", c, !1), o.removeEventListener("error", l, !1);
    }
    return o.addEventListener("load", c, !1), o.addEventListener("error", l, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
  }
}
class n_ extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Ta();
    r.colorSpace = Ot;
    const a = new Oo(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function c(l) {
      a.load(e[l], function(u) {
        r.images[l] = u, o++, o === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, i);
    }
    for (let l = 0; l < e.length; ++l)
      c(l);
    return r;
  }
}
class i_ extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new pr(), o = new wn(this.manager);
    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(e, function(c) {
      let l;
      try {
        l = r.parse(c);
      } catch (u) {
        if (i !== void 0)
          i(u);
        else {
          console.error(u);
          return;
        }
      }
      l.image !== void 0 ? a.image = l.image : l.data !== void 0 && (a.image.width = l.width, a.image.height = l.height, a.image.data = l.data), a.wrapS = l.wrapS !== void 0 ? l.wrapS : Ln, a.wrapT = l.wrapT !== void 0 ? l.wrapT : Ln, a.magFilter = l.magFilter !== void 0 ? l.magFilter : wt, a.minFilter = l.minFilter !== void 0 ? l.minFilter : wt, a.anisotropy = l.anisotropy !== void 0 ? l.anisotropy : 1, l.colorSpace !== void 0 ? a.colorSpace = l.colorSpace : l.encoding !== void 0 && (a.encoding = l.encoding), l.flipY !== void 0 && (a.flipY = l.flipY), l.format !== void 0 && (a.format = l.format), l.type !== void 0 && (a.type = l.type), l.mipmaps !== void 0 && (a.mipmaps = l.mipmaps, a.minFilter = _i), l.mipmapCount === 1 && (a.minFilter = wt), l.generateMipmaps !== void 0 && (a.generateMipmaps = l.generateMipmaps), a.needsUpdate = !0, t && t(a, l);
    }, n, i), a;
  }
}
class Qo extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Jt(), a = new Oo(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
      r.image = o, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, i), r;
  }
}
class Hr extends bt {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Pe(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class r_ extends Hr {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Pe(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const hh = /* @__PURE__ */ new Je(), hA = /* @__PURE__ */ new P(), fA = /* @__PURE__ */ new P();
class bd {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new xe(512, 512), this.map = null, this.mapPass = null, this.matrix = new Je(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Vo(), this._frameExtents = new xe(1, 1), this._viewportCount = 1, this._viewports = [
      new Dt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    hA.setFromMatrixPosition(e.matrixWorld), t.position.copy(hA), fA.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(fA), t.updateMatrixWorld(), hh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(hh), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(hh);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class CC extends bd {
  constructor() {
    super(new _n(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = xa * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class yd extends Hr {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, a = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new CC();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const dA = /* @__PURE__ */ new Je(), eo = /* @__PURE__ */ new P(), fh = /* @__PURE__ */ new P();
class MC extends bd {
  constructor() {
    super(new _n(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new xe(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Dt(2, 1, 1, 1),
      // negative X
      new Dt(0, 1, 1, 1),
      // positive Z
      new Dt(3, 1, 1, 1),
      // negative Z
      new Dt(1, 1, 1, 1),
      // positive Y
      new Dt(3, 0, 1, 1),
      // negative Y
      new Dt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new P(1, 0, 0),
      new P(-1, 0, 0),
      new P(0, 0, 1),
      new P(0, 0, -1),
      new P(0, 1, 0),
      new P(0, -1, 0)
    ], this._cubeUps = [
      new P(0, 1, 0),
      new P(0, 1, 0),
      new P(0, 1, 0),
      new P(0, 1, 0),
      new P(0, 0, 1),
      new P(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), eo.setFromMatrixPosition(e.matrixWorld), n.position.copy(eo), fh.copy(n.position), fh.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(fh), n.updateMatrixWorld(), i.makeTranslation(-eo.x, -eo.y, -eo.z), dA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dA);
  }
}
class vd extends Hr {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new MC();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class IC extends bd {
  constructor() {
    super(new Ls(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class fu extends Hr {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt(), this.shadow = new IC();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class s_ extends Hr {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class a_ extends Hr {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class o_ {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new P());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * i), t.addScaledVector(a[2], 0.488603 * r), t.addScaledVector(a[3], 0.488603 * n), t.addScaledVector(a[4], 1.092548 * (n * i)), t.addScaledVector(a[5], 1.092548 * (i * r)), t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (n * r)), t.addScaledVector(a[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, r = e.z, a = this.coefficients;
    return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 2 * 0.511664 * i), t.addScaledVector(a[2], 2 * 0.511664 * r), t.addScaledVector(a[3], 2 * 0.511664 * n), t.addScaledVector(a[4], 2 * 0.429043 * n * i), t.addScaledVector(a[5], 2 * 0.429043 * i * r), t.addScaledVector(a[6], 0.743125 * r * r - 0.247708), t.addScaledVector(a[7], 2 * 0.429043 * n * r), t.addScaledVector(a[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
  }
}
class c_ extends Hr {
  constructor(e = new o_(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class du extends Tn {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const r = this, a = new wn(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const i = du.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Pe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const a = e.uniforms[r];
        switch (i.uniforms[r] = {}, a.type) {
          case "t":
            i.uniforms[r].value = n(a.value);
            break;
          case "c":
            i.uniforms[r].value = new Pe().setHex(a.value);
            break;
          case "v2":
            i.uniforms[r].value = new xe().fromArray(a.value);
            break;
          case "v3":
            i.uniforms[r].value = new P().fromArray(a.value);
            break;
          case "v4":
            i.uniforms[r].value = new Dt().fromArray(a.value);
            break;
          case "m3":
            i.uniforms[r].value = new ft().fromArray(a.value);
            break;
          case "m4":
            i.uniforms[r].value = new Je().fromArray(a.value);
            break;
          default:
            i.uniforms[r].value = a.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        i.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), i.normalScale = new xe().fromArray(r);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new xe().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: z0,
      SpriteMaterial: Kl,
      RawShaderMaterial: H0,
      ShaderMaterial: Kn,
      PointsMaterial: eu,
      MeshPhysicalMaterial: Ui,
      MeshStandardMaterial: Ko,
      MeshPhongMaterial: V0,
      MeshToonMaterial: W0,
      MeshNormalMaterial: q0,
      MeshLambertMaterial: X0,
      MeshDepthMaterial: Wo,
      MeshDistanceMaterial: Xl,
      MeshBasicMaterial: In,
      MeshMatcapMaterial: Y0,
      LineDashedMaterial: j0,
      LineBasicMaterial: kn,
      Material: vn
    };
    return new t[e]();
  }
}
class Ur {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Ed extends ot {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class l_ extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new wn(r.manager);
    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function(o) {
      try {
        t(r.parse(JSON.parse(o)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(d, A) {
      if (t[A] !== void 0)
        return t[A];
      const p = d.interleavedBuffers[A], g = r(d, p.buffer), _ = ua(p.type, g), b = new qo(_, p.stride);
      return b.uuid = p.uuid, t[A] = b, b;
    }
    function r(d, A) {
      if (n[A] !== void 0)
        return n[A];
      const p = d.arrayBuffers[A], g = new Uint32Array(p).buffer;
      return n[A] = g, g;
    }
    const a = e.isInstancedBufferGeometry ? new Ed() : new ot(), o = e.data.index;
    if (o !== void 0) {
      const d = ua(o.type, o.array);
      a.setIndex(new ut(d, 1));
    }
    const c = e.data.attributes;
    for (const d in c) {
      const A = c[d];
      let m;
      if (A.isInterleavedBufferAttribute) {
        const p = i(e.data, A.data);
        m = new kr(p, A.itemSize, A.offset, A.normalized);
      } else {
        const p = ua(A.type, A.array), g = A.isInstancedBufferAttribute ? Nr : ut;
        m = new g(p, A.itemSize, A.normalized);
      }
      A.name !== void 0 && (m.name = A.name), A.usage !== void 0 && m.setUsage(A.usage), a.setAttribute(d, m);
    }
    const l = e.data.morphAttributes;
    if (l)
      for (const d in l) {
        const A = l[d], m = [];
        for (let p = 0, g = A.length; p < g; p++) {
          const _ = A[p];
          let b;
          if (_.isInterleavedBufferAttribute) {
            const y = i(e.data, _.data);
            b = new kr(y, _.itemSize, _.offset, _.normalized);
          } else {
            const y = ua(_.type, _.array);
            b = new ut(y, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (b.name = _.name), m.push(b);
        }
        a.morphAttributes[d] = m;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let d = 0, A = h.length; d !== A; ++d) {
        const m = h[d];
        a.addGroup(m.start, m.count, m.materialIndex);
      }
    const f = e.data.boundingSphere;
    if (f !== void 0) {
      const d = new P();
      f.center !== void 0 && d.fromArray(f.center), a.boundingSphere = new yn(d, f.radius);
    }
    return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a;
  }
}
class wC extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = this.path === "" ? Ur.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new wn(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(c) {
      let l = null;
      try {
        l = JSON.parse(c);
      } catch (h) {
        i !== void 0 && i(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
        return;
      }
      const u = l.metadata;
      if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(l, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? Ur.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const r = new wn(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const a = await r.loadAsync(e, t), o = JSON.parse(a), c = o.metadata;
    if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(o);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), a = this.parseImages(e.images, function() {
      t !== void 0 && t(l);
    }), o = this.parseTextures(e.textures, a), c = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, c, o, n), u = this.parseSkeletons(e.skeletons, l);
    if (this.bindSkeletons(l, u), t !== void 0) {
      let h = !1;
      for (const f in a)
        if (a[f].data instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && t(l);
    }
    return l;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, r), o = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, i, o, a, t), l = this.parseSkeletons(e.skeletons, c);
    return this.bindSkeletons(c, l), c;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const r = new Pr().fromJSON(e[n]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(r) {
      r.isBone && (i[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = new Xo().fromJSON(e[r], i);
        n[o.uuid] = o;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new l_();
      for (let r = 0, a = e.length; r < a; r++) {
        let o;
        const c = e[r];
        switch (c.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            o = i.parse(c);
            break;
          default:
            c.type in uA ? o = uA[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`);
        }
        o.uuid = c.uuid, c.name !== void 0 && (o.name = c.name), c.userData !== void 0 && (o.userData = c.userData), n[c.uuid] = o;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const r = new du();
      r.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const c = e[a];
        n[c.uuid] === void 0 && (n[c.uuid] = r.parse(c)), i[c.uuid] = n[c.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], r = Ca.parse(i);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let r;
    function a(c) {
      return n.manager.itemStart(c), r.load(c, function() {
        n.manager.itemEnd(c);
      }, void 0, function() {
        n.manager.itemError(c), n.manager.itemEnd(c);
      });
    }
    function o(c) {
      if (typeof c == "string") {
        const l = c, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : n.resourcePath + l;
        return a(u);
      } else
        return c.data ? {
          data: ua(c.type, c.data),
          width: c.width,
          height: c.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new _d(t);
      r = new Oo(c), r.setCrossOrigin(this.crossOrigin);
      for (let l = 0, u = e.length; l < u; l++) {
        const h = e[l], f = h.url;
        if (Array.isArray(f)) {
          const d = [];
          for (let A = 0, m = f.length; A < m; A++) {
            const p = f[A], g = o(p);
            g !== null && (g instanceof HTMLImageElement ? d.push(g) : d.push(new pr(g.data, g.width, g.height)));
          }
          i[h.uuid] = new _s(d);
        } else {
          const d = o(h.url);
          i[h.uuid] = new _s(d);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function r(a) {
      if (typeof a == "string") {
        const o = a, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await i.loadAsync(c);
      } else
        return a.data ? {
          data: ua(a.type, a.data),
          width: a.width,
          height: a.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Oo(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, o = e.length; a < o; a++) {
        const c = e[a], l = c.url;
        if (Array.isArray(l)) {
          const u = [];
          for (let h = 0, f = l.length; h < f; h++) {
            const d = l[h], A = await r(d);
            A !== null && (A instanceof HTMLImageElement ? u.push(A) : u.push(new pr(A.data, A.width, A.height)));
          }
          n[c.uuid] = new _s(u);
        } else {
          const u = await r(c.url);
          n[c.uuid] = new _s(u);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(r, a) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), a[r]);
    }
    const i = {};
    if (e !== void 0)
      for (let r = 0, a = e.length; r < a; r++) {
        const o = e[r];
        o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image);
        const c = t[o.image], l = c.data;
        let u;
        Array.isArray(l) ? (u = new Ta(), l.length === 6 && (u.needsUpdate = !0)) : (l && l.data ? u = new pr() : u = new Jt(), l && (u.needsUpdate = !0)), u.source = c, u.uuid = o.uuid, o.name !== void 0 && (u.name = o.name), o.mapping !== void 0 && (u.mapping = n(o.mapping, TC)), o.channel !== void 0 && (u.channel = o.channel), o.offset !== void 0 && u.offset.fromArray(o.offset), o.repeat !== void 0 && u.repeat.fromArray(o.repeat), o.center !== void 0 && u.center.fromArray(o.center), o.rotation !== void 0 && (u.rotation = o.rotation), o.wrap !== void 0 && (u.wrapS = n(o.wrap[0], pA), u.wrapT = n(o.wrap[1], pA)), o.format !== void 0 && (u.format = o.format), o.internalFormat !== void 0 && (u.internalFormat = o.internalFormat), o.type !== void 0 && (u.type = o.type), o.colorSpace !== void 0 && (u.colorSpace = o.colorSpace), o.encoding !== void 0 && (u.encoding = o.encoding), o.minFilter !== void 0 && (u.minFilter = n(o.minFilter, AA)), o.magFilter !== void 0 && (u.magFilter = n(o.magFilter, AA)), o.anisotropy !== void 0 && (u.anisotropy = o.anisotropy), o.flipY !== void 0 && (u.flipY = o.flipY), o.generateMipmaps !== void 0 && (u.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (u.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (u.compareFunction = o.compareFunction), o.userData !== void 0 && (u.userData = o.userData), i[o.uuid] = u;
      }
    return i;
  }
  parseObject(e, t, n, i, r) {
    let a;
    function o(f) {
      return t[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", f), t[f];
    }
    function c(f) {
      if (f !== void 0) {
        if (Array.isArray(f)) {
          const d = [];
          for (let A = 0, m = f.length; A < m; A++) {
            const p = f[A];
            n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), d.push(n[p]);
          }
          return d;
        }
        return n[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", f), n[f];
      }
    }
    function l(f) {
      return i[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", f), i[f];
    }
    let u, h;
    switch (e.type) {
      case "Scene":
        a = new Jl(), e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new Pe(e.background) : a.background = l(e.background)), e.environment !== void 0 && (a.environment = l(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new jl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new Yl(e.fog.color, e.fog.density)), e.fog.name !== "" && (a.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        a = new _n(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        a = new Ls(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new s_(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new fu(e.color, e.intensity);
        break;
      case "PointLight":
        a = new vd(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new a_(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new yd(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        a = new r_(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new c_().fromJSON(e);
        break;
      case "SkinnedMesh":
        u = o(e.geometry), h = c(e.material), a = new ad(u, h), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        u = o(e.geometry), h = c(e.material), a = new Ne(u, h);
        break;
      case "InstancedMesh":
        u = o(e.geometry), h = c(e.material);
        const f = e.count, d = e.instanceMatrix, A = e.instanceColor;
        a = new $l(u, h, f), a.instanceMatrix = new Nr(new Float32Array(d.array), 16), A !== void 0 && (a.instanceColor = new Nr(new Float32Array(A.array), A.itemSize));
        break;
      case "BatchedMesh":
        u = o(e.geometry), h = c(e.material), a = new w0(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, h), a.geometry = u, a.perObjectFrustumCulled = e.perObjectFrustumCulled, a.sortObjects = e.sortObjects, a._drawRanges = e.drawRanges, a._reservedRanges = e.reservedRanges, a._visibility = e.visibility, a._active = e.active, a._bounds = e.bounds.map((m) => {
          const p = new bn();
          p.min.fromArray(m.boxMin), p.max.fromArray(m.boxMax);
          const g = new yn();
          return g.radius = m.sphereRadius, g.center.fromArray(m.sphereCenter), {
            boxInitialized: m.boxInitialized,
            box: p,
            sphereInitialized: m.sphereInitialized,
            sphere: g
          };
        }), a._maxGeometryCount = e.maxGeometryCount, a._maxVertexCount = e.maxVertexCount, a._maxIndexCount = e.maxIndexCount, a._geometryInitialized = e.geometryInitialized, a._geometryCount = e.geometryCount, a._matricesTexture = l(e.matricesTexture.uuid);
        break;
      case "LOD":
        a = new I0();
        break;
      case "Line":
        a = new Dn(o(e.geometry), c(e.material));
        break;
      case "LineLoop":
        a = new od(o(e.geometry), c(e.material));
        break;
      case "LineSegments":
        a = new Li(o(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new cd(o(e.geometry), c(e.material));
        break;
      case "Sprite":
        a = new M0(c(e.material));
        break;
      case "Group":
        a = new Un();
        break;
      case "Bone":
        a = new Zl();
        break;
      default:
        a = new bt();
    }
    if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) {
      const f = e.children;
      for (let d = 0; d < f.length; d++)
        a.add(this.parseObject(f[d], t, n, i, r));
    }
    if (e.animations !== void 0) {
      const f = e.animations;
      for (let d = 0; d < f.length; d++) {
        const A = f[d];
        a.animations.push(r[A]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const f = e.levels;
      for (let d = 0; d < f.length; d++) {
        const A = f[d], m = a.getObjectByProperty("uuid", A.object);
        m !== void 0 && a.addLevel(m, A.distance, A.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
}
const TC = {
  UVMapping: Ul,
  CubeReflectionMapping: Xi,
  CubeRefractionMapping: Fr,
  EquirectangularReflectionMapping: _a,
  EquirectangularRefractionMapping: Mo,
  CubeUVReflectionMapping: Ia
}, pA = {
  RepeatWrapping: Ar,
  ClampToEdgeWrapping: Ln,
  MirroredRepeatWrapping: ba
}, AA = {
  NearestFilter: tn,
  NearestMipmapNearestFilter: Io,
  NearestMipmapLinearFilter: Aa,
  LinearFilter: wt,
  LinearMipmapNearestFilter: Fl,
  LinearMipmapLinearFilter: _i
};
class u_ extends Tn {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, a = Ts.get(e);
    if (a !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(a), r.manager.itemEnd(e);
      }, 0), a;
    const o = {};
    o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      Ts.add(e, c), t && t(c), r.manager.itemEnd(e);
    }).catch(function(c) {
      i && i(c), r.manager.itemError(e), r.manager.itemEnd(e);
    }), r.manager.itemStart(e);
  }
}
let qc;
class xd {
  static getContext() {
    return qc === void 0 && (qc = new (window.AudioContext || window.webkitAudioContext)()), qc;
  }
  static setContext(e) {
    qc = e;
  }
}
class h_ extends Tn {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, a = new wn(this.manager);
    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
      try {
        const l = c.slice(0);
        xd.getContext().decodeAudioData(l, function(h) {
          t(h);
        }).catch(o);
      } catch (l) {
        o(l);
      }
    }, n, i);
    function o(c) {
      i ? i(c) : console.error(c), r.manager.itemError(e);
    }
  }
}
const gA = /* @__PURE__ */ new Je(), mA = /* @__PURE__ */ new Je(), Zr = /* @__PURE__ */ new Je();
class BC {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new _n(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new _n(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Zr.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, r = i * t.near / t.focus, a = t.near * Math.tan(vs * t.fov * 0.5) / t.zoom;
      let o, c;
      mA.elements[12] = -i, gA.elements[12] = i, o = -a * t.aspect + r, c = a * t.aspect + r, Zr.elements[0] = 2 * t.near / (c - o), Zr.elements[8] = (c + o) / (c - o), this.cameraL.projectionMatrix.copy(Zr), o = -a * t.aspect - r, c = a * t.aspect - r, Zr.elements[0] = 2 * t.near / (c - o), Zr.elements[8] = (c + o) / (c - o), this.cameraR.projectionMatrix.copy(Zr);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(mA), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(gA);
  }
}
class f_ {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = _A(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = _A();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function _A() {
  return (typeof performance > "u" ? Date : performance).now();
}
const $r = /* @__PURE__ */ new P(), bA = /* @__PURE__ */ new Rt(), RC = /* @__PURE__ */ new P(), es = /* @__PURE__ */ new P();
let d_ = class extends bt {
  constructor() {
    super(), this.type = "AudioListener", this.context = xd.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new f_();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose($r, bA, RC), es.set(0, 0, -1).applyQuaternion(bA), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime($r.x, i), t.positionY.linearRampToValueAtTime($r.y, i), t.positionZ.linearRampToValueAtTime($r.z, i), t.forwardX.linearRampToValueAtTime(es.x, i), t.forwardY.linearRampToValueAtTime(es.y, i), t.forwardZ.linearRampToValueAtTime(es.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition($r.x, $r.y, $r.z), t.setOrientation(es.x, es.y, es.z, n.x, n.y, n.z);
  }
}, Sd = class extends bt {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
};
const ts = /* @__PURE__ */ new P(), yA = /* @__PURE__ */ new Rt(), DC = /* @__PURE__ */ new P(), ns = /* @__PURE__ */ new P();
let p_ = class extends Sd {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(ts, yA, DC), ns.set(0, 0, 1).applyQuaternion(yA);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(ts.x, n), t.positionY.linearRampToValueAtTime(ts.y, n), t.positionZ.linearRampToValueAtTime(ts.z, n), t.orientationX.linearRampToValueAtTime(ns.x, n), t.orientationY.linearRampToValueAtTime(ns.y, n), t.orientationZ.linearRampToValueAtTime(ns.z, n);
    } else
      t.setPosition(ts.x, ts.y, ts.z), t.setOrientation(ns.x, ns.y, ns.z);
  }
};
class LC {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class A_ {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, r, a;
    switch (t) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, r = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== i; ++o)
        n[r + o] = n[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(n, r, 0, o, i);
    }
    this.cumulativeWeight = a;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const c = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        c,
        1 - r,
        t
      );
    }
    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let c = t, l = t + t; c !== l; ++c)
      if (n[c] !== n[c + t]) {
        o.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let r = n, a = i; r !== a; ++r)
      t[r] = t[i + r % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, r) {
    if (i >= 0.5)
      for (let a = 0; a !== r; ++a)
        e[t + a] = e[n + a];
  }
  _slerp(e, t, n, i) {
    Rt.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, r) {
    const a = this._workIndex * r;
    Rt.multiplyQuaternionsFlat(e, a, e, t, e, n), Rt.slerpFlat(e, t, e, t, e, a, i);
  }
  _lerp(e, t, n, i, r) {
    const a = 1 - i;
    for (let o = 0; o !== r; ++o) {
      const c = t + o;
      e[c] = e[c] * a + e[n + o] * i;
    }
  }
  _lerpAdditive(e, t, n, i, r) {
    for (let a = 0; a !== r; ++a) {
      const o = t + a;
      e[o] = e[o] + e[n + a] * i;
    }
  }
}
const Cd = "\\[\\]\\.:\\/", PC = new RegExp("[" + Cd + "]", "g"), Md = "[^" + Cd + "]", UC = "[^" + Cd.replace("\\.", "") + "]", FC = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", Md), kC = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", UC), NC = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Md), OC = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Md), QC = new RegExp(
  "^" + FC + kC + NC + OC + "$"
), GC = ["material", "materials", "bones", "map"];
class zC {
  constructor(e, t, n) {
    const i = n || It.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class It {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || It.parseTrackName(t), this.node = It.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new It.Composite(e, t, n) : new It(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(PC, "");
  }
  static parseTrackName(e) {
    const t = QC.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      GC.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let a = 0; a < r.length; a++) {
          const o = r[a];
          if (o.name === t || o.uuid === t)
            return o;
          const c = n(o.children);
          if (c)
            return c;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = It.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let l = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === l) {
              l = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (l !== void 0) {
        if (e[l] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[l];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const l = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
It.Composite = zC;
It.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
It.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
It.prototype.GetterByBindingType = [
  It.prototype._getValue_direct,
  It.prototype._getValue_array,
  It.prototype._getValue_arrayElement,
  It.prototype._getValue_toArray
];
It.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    It.prototype._setValue_direct,
    It.prototype._setValue_direct_setNeedsUpdate,
    It.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    It.prototype._setValue_array,
    It.prototype._setValue_array_setNeedsUpdate,
    It.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    It.prototype._setValue_arrayElement,
    It.prototype._setValue_arrayElement_setNeedsUpdate,
    It.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    It.prototype._setValue_fromArray,
    It.prototype._setValue_fromArray_setNeedsUpdate,
    It.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class HC {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = di(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, a = r.length;
    let o, c = e.length, l = this.nCachedObjects_;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const f = arguments[u], d = f.uuid;
      let A = t[d];
      if (A === void 0) {
        A = c++, t[d] = A, e.push(f);
        for (let m = 0, p = a; m !== p; ++m)
          r[m].push(new It(f, n[m], i[m]));
      } else if (A < l) {
        o = e[A];
        const m = --l, p = e[m];
        t[p.uuid] = A, e[A] = p, t[d] = m, e[m] = f;
        for (let g = 0, _ = a; g !== _; ++g) {
          const b = r[g], y = b[m];
          let v = b[A];
          b[A] = y, v === void 0 && (v = new It(f, n[g], i[g])), b[m] = v;
        }
      } else
        e[A] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const c = arguments[a], l = c.uuid, u = t[l];
      if (u !== void 0 && u >= r) {
        const h = r++, f = e[h];
        t[f.uuid] = u, e[u] = f, t[l] = h, e[h] = c;
        for (let d = 0, A = i; d !== A; ++d) {
          const m = n[d], p = m[h], g = m[u];
          m[u] = p, m[h] = g;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_, a = e.length;
    for (let o = 0, c = arguments.length; o !== c; ++o) {
      const l = arguments[o], u = l.uuid, h = t[u];
      if (h !== void 0)
        if (delete t[u], h < r) {
          const f = --r, d = e[f], A = --a, m = e[A];
          t[d.uuid] = h, e[h] = d, t[m.uuid] = f, e[f] = m, e.pop();
          for (let p = 0, g = i; p !== g; ++p) {
            const _ = n[p], b = _[f], y = _[A];
            _[h] = b, _[f] = y, _.pop();
          }
        } else {
          const f = --a, d = e[f];
          f > 0 && (t[d.uuid] = h), e[h] = d, e.pop();
          for (let A = 0, m = i; A !== m; ++A) {
            const p = n[A];
            p[h] = p[f], p.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const r = this._bindings;
    if (i !== void 0)
      return r[i];
    const a = this._paths, o = this._parsedPaths, c = this._objects, l = c.length, u = this.nCachedObjects_, h = new Array(l);
    i = r.length, n[e] = i, a.push(e), o.push(t), r.push(h);
    for (let f = u, d = c.length; f !== d; ++f) {
      const A = c[f];
      h[f] = new It(A, e, t);
    }
    return h;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, c = a[o], l = e[o];
      t[l] = n, a[n] = c, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop();
    }
  }
}
class g_ {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const r = t.tracks, a = r.length, o = new Array(a), c = {
      endingStart: gs,
      endingEnd: gs
    };
    for (let l = 0; l !== a; ++l) {
      const u = r[l].createInterpolant(null);
      o[l] = u, u.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = $m, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, r = e._clip.duration, a = r / i, o = i / r;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, r = i.time, a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
    const c = o.parameterPositions, l = o.sampleValues;
    return c[0] = r, c[1] = r + n, l[0] = e / a, l[1] = t / a, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const c = (e - r) * n;
      c < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * c);
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t), o = this._updateWeight(e);
    if (o > 0) {
      const c = this._interpolants, l = this._propertyBindings;
      switch (this.blendMode) {
        case Yf:
          for (let u = 0, h = c.length; u !== h; ++u)
            c[u].evaluate(a), l[u].accumulateAdditive(o);
          break;
        case Ol:
        default:
          for (let u = 0, h = c.length; u !== h; ++u)
            c[u].evaluate(a), l[u].accumulate(i, o);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, r = this._loopCount;
    const a = n === e0;
    if (e === 0)
      return r === -1 ? i : a && (r & 1) === 1 ? t - i : i;
    if (n === Zm) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), i >= t || i < 0) {
        const o = Math.floor(i / t);
        i -= t * o, r += Math.abs(o);
        const c = this.repetitions - r;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const l = e < 0;
            this._setEndings(l, !l, a);
          } else
            this._setEndings(!1, !1, a);
          this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o
          });
        }
      } else
        this.time = i;
      if (a && (r & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = ms, i.endingEnd = ms) : (e ? i.endingStart = this.zeroSlopeAtStart ? ms : gs : i.endingStart = To, t ? i.endingEnd = this.zeroSlopeAtEnd ? ms : gs : i.endingEnd = To);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, r = i.time;
    let a = this._weightInterpolant;
    a === null && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
    const o = a.parameterPositions, c = a.sampleValues;
    return o[0] = r, c[0] = t, o[1] = r + e, c[1] = n, this;
  }
}
const VC = new Float32Array(1);
class m_ extends Yi {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, a = e._propertyBindings, o = e._interpolants, c = n.uuid, l = this._bindingsByRootAndName;
    let u = l[c];
    u === void 0 && (u = {}, l[c] = u);
    for (let h = 0; h !== r; ++h) {
      const f = i[h], d = f.name;
      let A = u[d];
      if (A !== void 0)
        ++A.referenceCount, a[h] = A;
      else {
        if (A = a[h], A !== void 0) {
          A._cacheIndex === null && (++A.referenceCount, this._addInactiveBinding(A, c, d));
          continue;
        }
        const m = t && t._propertyBindings[h].binding.parsedPath;
        A = new A_(
          It.create(n, d, m),
          f.ValueTypeName,
          f.getValueSize()
        ), ++A.referenceCount, this._addInactiveBinding(A, c, d), a[h] = A;
      }
      o[h].resultBuffer = A.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, r = this._actionsByClip;
    let a = r[t];
    if (a === void 0)
      a = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
    else {
      const o = a.knownActions;
      e._byClipCacheIndex = o.length, o.push(e);
    }
    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, a = this._actionsByClip, o = a[r], c = o.knownActions, l = c[c.length - 1], u = e._byClipCacheIndex;
    l._byClipCacheIndex = u, c[u] = l, c.pop(), e._byClipCacheIndex = null;
    const h = o.actionByRoot, f = (e._localRoot || this._root).uuid;
    delete h[f], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, r = this._bindings;
    let a = i[t];
    a === void 0 && (a = {}, i[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[i], c = t[t.length - 1], l = e._cacheIndex;
    c._cacheIndex = l, t[l] = c, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new gd(
      new Float32Array(2),
      new Float32Array(2),
      1,
      VC
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, r = i.uuid;
    let a = typeof e == "string" ? Ca.findByName(i, e) : e;
    const o = a !== null ? a.uuid : e, c = this._actionsByClip[o];
    let l = null;
    if (n === void 0 && (a !== null ? n = a.blendMode : n = Ol), c !== void 0) {
      const h = c.actionByRoot[r];
      if (h !== void 0 && h.blendMode === n)
        return h;
      l = c.knownActions[0], a === null && (a = l._clip);
    }
    if (a === null)
      return null;
    const u = new g_(this, a, t, n);
    return this._bindAction(u, l), this._addInactiveAction(u, o, r), u;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, r = typeof e == "string" ? Ca.findByName(n, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
    return o !== void 0 && o.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
    for (let l = 0; l !== n; ++l)
      t[l]._update(i, e, r, a);
    const o = this._bindings, c = this._nActiveBindings;
    for (let l = 0; l !== c; ++l)
      o[l].apply(a);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
    if (r !== void 0) {
      const a = r.knownActions;
      for (let o = 0, c = a.length; o !== c; ++o) {
        const l = a[o];
        this._deactivateAction(l);
        const u = l._cacheIndex, h = t[t.length - 1];
        l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(l);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const a in n) {
      const o = n[a].actionByRoot, c = o[t];
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const i = this._bindingsByRootAndName, r = i[t];
    if (r !== void 0)
      for (const a in r) {
        const o = r[a];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class Id {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Id(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let WC = 0;
class qC extends Yi {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: WC++ }), this.name = "", this.usage = Lo, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++)
      this.uniforms.push(t[n].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class XC extends qo {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class YC {
  constructor(e, t, n, i, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class Zo {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new Rs(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Hl(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return Bf(e, this, n, t), n.sort(vA), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, r = e.length; i < r; i++)
      Bf(e[i], this, n, t);
    return n.sort(vA), n;
  }
}
function vA(s, e) {
  return s.distance - e.distance;
}
function Bf(s, e, t, n) {
  if (s.layers.test(e.layers) && s.raycast(e, t), n === !0) {
    const i = s.children;
    for (let r = 0, a = i.length; r < a; r++)
      Bf(i[r], e, t, !0);
  }
}
class Rf {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(cn(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class jC {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const EA = /* @__PURE__ */ new xe();
class JC {
  constructor(e = new xe(1 / 0, 1 / 0), t = new xe(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = EA.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, EA).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const xA = /* @__PURE__ */ new P(), Xc = /* @__PURE__ */ new P();
class KC {
  constructor(e = new P(), t = new P()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    xA.subVectors(e, this.start), Xc.subVectors(this.end, this.start);
    const n = Xc.dot(Xc);
    let r = Xc.dot(xA) / n;
    return t && (r = cn(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const SA = /* @__PURE__ */ new P();
class ZC extends bt {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new ot(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, o = 1, c = 32; a < c; a++, o++) {
      const l = a / c * Math.PI * 2, u = o / c * Math.PI * 2;
      i.push(
        Math.cos(l),
        Math.sin(l),
        1,
        Math.cos(u),
        Math.sin(u),
        1
      );
    }
    n.setAttribute("position", new je(i, 3));
    const r = new kn({ fog: !1, toneMapped: !1 });
    this.cone = new Li(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), SA.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(SA), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Cr = /* @__PURE__ */ new P(), Yc = /* @__PURE__ */ new Je(), dh = /* @__PURE__ */ new Je();
class $C extends Li {
  constructor(e) {
    const t = __(e), n = new ot(), i = [], r = [], a = new Pe(0, 0, 1), o = new Pe(0, 1, 0);
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    n.setAttribute("position", new je(i, 3)), n.setAttribute("color", new je(r, 3));
    const c = new kn({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, c), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    dh.copy(this.root.matrixWorld).invert();
    for (let r = 0, a = 0; r < t.length; r++) {
      const o = t[r];
      o.parent && o.parent.isBone && (Yc.multiplyMatrices(dh, o.matrixWorld), Cr.setFromMatrixPosition(Yc), i.setXYZ(a, Cr.x, Cr.y, Cr.z), Yc.multiplyMatrices(dh, o.parent.matrixWorld), Cr.setFromMatrixPosition(Yc), i.setXYZ(a + 1, Cr.x, Cr.y, Cr.z), a += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function __(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, __(s.children[t]));
  return e;
}
class eM extends Ne {
  constructor(e, t, n) {
    const i = new Da(t, 4, 2), r = new In({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const tM = /* @__PURE__ */ new P(), CA = /* @__PURE__ */ new Pe(), MA = /* @__PURE__ */ new Pe();
class nM extends bt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new hr(t);
    i.rotateY(Math.PI * 0.5), this.material = new In({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = i.getAttribute("position"), a = new Float32Array(r.count * 3);
    i.setAttribute("color", new ut(a, 3)), this.add(new Ne(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      CA.copy(this.light.color), MA.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const r = n < i / 2 ? CA : MA;
        t.setXYZ(n, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(tM.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class iM extends Li {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new Pe(n), i = new Pe(i);
    const r = t / 2, a = e / t, o = e / 2, c = [], l = [];
    for (let f = 0, d = 0, A = -o; f <= t; f++, A += a) {
      c.push(-o, 0, A, o, 0, A), c.push(A, 0, -o, A, 0, o);
      const m = f === r ? n : i;
      m.toArray(l, d), d += 3, m.toArray(l, d), d += 3, m.toArray(l, d), d += 3, m.toArray(l, d), d += 3;
    }
    const u = new ot();
    u.setAttribute("position", new je(c, 3)), u.setAttribute("color", new je(l, 3));
    const h = new kn({ vertexColors: !0, toneMapped: !1 });
    super(u, h), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class rM extends Li {
  constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, a = 8947848) {
    r = new Pe(r), a = new Pe(a);
    const o = [], c = [];
    if (t > 1)
      for (let h = 0; h < t; h++) {
        const f = h / t * (Math.PI * 2), d = Math.sin(f) * e, A = Math.cos(f) * e;
        o.push(0, 0, 0), o.push(d, 0, A);
        const m = h & 1 ? r : a;
        c.push(m.r, m.g, m.b), c.push(m.r, m.g, m.b);
      }
    for (let h = 0; h < n; h++) {
      const f = h & 1 ? r : a, d = e - e / n * h;
      for (let A = 0; A < i; A++) {
        let m = A / i * (Math.PI * 2), p = Math.sin(m) * d, g = Math.cos(m) * d;
        o.push(p, 0, g), c.push(f.r, f.g, f.b), m = (A + 1) / i * (Math.PI * 2), p = Math.sin(m) * d, g = Math.cos(m) * d, o.push(p, 0, g), c.push(f.r, f.g, f.b);
      }
    }
    const l = new ot();
    l.setAttribute("position", new je(o, 3)), l.setAttribute("color", new je(c, 3));
    const u = new kn({ vertexColors: !0, toneMapped: !1 });
    super(l, u), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const IA = /* @__PURE__ */ new P(), jc = /* @__PURE__ */ new P(), wA = /* @__PURE__ */ new P();
class sM extends bt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new ot();
    i.setAttribute("position", new je([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new kn({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Dn(i, r), this.add(this.lightPlane), i = new ot(), i.setAttribute("position", new je([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Dn(i, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), IA.setFromMatrixPosition(this.light.matrixWorld), jc.setFromMatrixPosition(this.light.target.matrixWorld), wA.subVectors(jc, IA), this.lightPlane.lookAt(jc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(jc), this.targetLine.scale.z = wA.length();
  }
}
const Jc = /* @__PURE__ */ new P(), on = /* @__PURE__ */ new Wl();
class aM extends Li {
  constructor(e) {
    const t = new ot(), n = new kn({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], a = {};
    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4");
    function o(A, m) {
      c(A), c(m);
    }
    function c(A) {
      i.push(0, 0, 0), r.push(0, 0, 0), a[A] === void 0 && (a[A] = []), a[A].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new je(i, 3)), t.setAttribute("color", new je(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
    const l = new Pe(16755200), u = new Pe(16711680), h = new Pe(43775), f = new Pe(16777215), d = new Pe(3355443);
    this.setColors(l, u, h, f, d);
  }
  setColors(e, t, n, i, r) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, n.r, n.g, n.b), o.setXYZ(33, n.r, n.g, n.b), o.setXYZ(34, n.r, n.g, n.b), o.setXYZ(35, n.r, n.g, n.b), o.setXYZ(36, n.r, n.g, n.b), o.setXYZ(37, n.r, n.g, n.b), o.setXYZ(38, i.r, i.g, i.b), o.setXYZ(39, i.r, i.g, i.b), o.setXYZ(40, r.r, r.g, r.b), o.setXYZ(41, r.r, r.g, r.b), o.setXYZ(42, r.r, r.g, r.b), o.setXYZ(43, r.r, r.g, r.b), o.setXYZ(44, r.r, r.g, r.b), o.setXYZ(45, r.r, r.g, r.b), o.setXYZ(46, r.r, r.g, r.b), o.setXYZ(47, r.r, r.g, r.b), o.setXYZ(48, r.r, r.g, r.b), o.setXYZ(49, r.r, r.g, r.b), o.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    on.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ln("c", t, e, on, 0, 0, -1), ln("t", t, e, on, 0, 0, 1), ln("n1", t, e, on, -n, -i, -1), ln("n2", t, e, on, n, -i, -1), ln("n3", t, e, on, -n, i, -1), ln("n4", t, e, on, n, i, -1), ln("f1", t, e, on, -n, -i, 1), ln("f2", t, e, on, n, -i, 1), ln("f3", t, e, on, -n, i, 1), ln("f4", t, e, on, n, i, 1), ln("u1", t, e, on, n * 0.7, i * 1.1, -1), ln("u2", t, e, on, -n * 0.7, i * 1.1, -1), ln("u3", t, e, on, 0, i * 2, -1), ln("cf1", t, e, on, -n, 0, 1), ln("cf2", t, e, on, n, 0, 1), ln("cf3", t, e, on, 0, -i, 1), ln("cf4", t, e, on, 0, i, 1), ln("cn1", t, e, on, -n, 0, -1), ln("cn2", t, e, on, n, 0, -1), ln("cn3", t, e, on, 0, -i, -1), ln("cn4", t, e, on, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ln(s, e, t, n, i, r, a) {
  Jc.set(i, r, a).unproject(n);
  const o = e[s];
  if (o !== void 0) {
    const c = t.getAttribute("position");
    for (let l = 0, u = o.length; l < u; l++)
      c.setXYZ(o[l], Jc.x, Jc.y, Jc.z);
  }
}
const Kc = /* @__PURE__ */ new bn();
class oM extends Li {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), r = new ot();
    r.setIndex(new ut(n, 1)), r.setAttribute("position", new ut(i, 3)), super(r, new kn({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Kc.setFromObject(this.object), Kc.isEmpty())
      return;
    const t = Kc.min, n = Kc.max, i = this.geometry.attributes.position, r = i.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class cM extends Li {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new ot();
    r.setIndex(new ut(n, 1)), r.setAttribute("position", new je(i, 3)), super(r, new kn({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class lM extends Dn {
  constructor(e, t = 1, n = 16776960) {
    const i = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], a = new ot();
    a.setAttribute("position", new je(r, 3)), a.computeBoundingSphere(), super(a, new kn({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], c = new ot();
    c.setAttribute("position", new je(o, 3)), c.computeBoundingSphere(), this.add(new Ne(c, new In({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const TA = /* @__PURE__ */ new P();
let Zc, ph;
class uM extends bt {
  // dir is assumed to be normalized
  constructor(e = new P(0, 0, 1), t = new P(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, a = r * 0.2) {
    super(), this.type = "ArrowHelper", Zc === void 0 && (Zc = new ot(), Zc.setAttribute("position", new je([0, 0, 0, 0, 1, 0], 3)), ph = new hn(0, 0.5, 1, 5, 1), ph.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Dn(Zc, new kn({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ne(ph, new In({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      TA.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(TA, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class hM extends Li {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new ot();
    i.setAttribute("position", new je(t, 3)), i.setAttribute("color", new je(n, 3));
    const r = new kn({ vertexColors: !0, toneMapped: !1 });
    super(i, r), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new Pe(), r = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class fM {
  constructor() {
    this.type = "ShapePath", this.color = new Pe(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Uo(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, a) {
    return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const _ = [];
      for (let b = 0, y = g.length; b < y; b++) {
        const v = g[b], x = new Pr();
        x.curves = v.curves, _.push(x);
      }
      return _;
    }
    function n(g, _) {
      const b = _.length;
      let y = !1;
      for (let v = b - 1, x = 0; x < b; v = x++) {
        let S = _[v], I = _[x], E = I.x - S.x, M = I.y - S.y;
        if (Math.abs(M) > Number.EPSILON) {
          if (M < 0 && (S = _[x], E = -E, I = _[v], M = -M), g.y < S.y || g.y > I.y)
            continue;
          if (g.y === S.y) {
            if (g.x === S.x)
              return !0;
          } else {
            const T = M * (g.x - S.x) - E * (g.y - S.y);
            if (T === 0)
              return !0;
            if (T < 0)
              continue;
            y = !y;
          }
        } else {
          if (g.y !== S.y)
            continue;
          if (I.x <= g.x && g.x <= S.x || S.x <= g.x && g.x <= I.x)
            return !0;
        }
      }
      return y;
    }
    const i = qi.isClockWise, r = this.subPaths;
    if (r.length === 0)
      return [];
    let a, o, c;
    const l = [];
    if (r.length === 1)
      return o = r[0], c = new Pr(), c.curves = o.curves, l.push(c), l;
    let u = !i(r[0].getPoints());
    u = e ? !u : u;
    const h = [], f = [];
    let d = [], A = 0, m;
    f[A] = void 0, d[A] = [];
    for (let g = 0, _ = r.length; g < _; g++)
      o = r[g], m = o.getPoints(), a = i(m), a = e ? !a : a, a ? (!u && f[A] && A++, f[A] = { s: new Pr(), p: m }, f[A].s.curves = o.curves, u && A++, d[A] = []) : d[A].push({ h: o, p: m[0] });
    if (!f[0])
      return t(r);
    if (f.length > 1) {
      let g = !1, _ = 0;
      for (let b = 0, y = f.length; b < y; b++)
        h[b] = [];
      for (let b = 0, y = f.length; b < y; b++) {
        const v = d[b];
        for (let x = 0; x < v.length; x++) {
          const S = v[x];
          let I = !0;
          for (let E = 0; E < f.length; E++)
            n(S.p, f[E].p) && (b !== E && _++, I ? (I = !1, h[E].push(S)) : g = !0);
          I && h[b].push(S);
        }
      }
      _ > 0 && g === !1 && (d = h);
    }
    let p;
    for (let g = 0, _ = f.length; g < _; g++) {
      c = f[g].s, l.push(c), p = d[g];
      for (let b = 0, y = p.length; b < y; b++)
        c.holes.push(p[b].h);
    }
    return l;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Ma
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ma);
const dM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: Gf,
  AddEquation: Br,
  AddOperation: Qm,
  AdditiveAnimationBlendMode: Yf,
  AdditiveBlending: Yh,
  AlphaFormat: Ym,
  AlwaysCompare: u0,
  AlwaysDepth: Lm,
  AlwaysStencilFunc: yf,
  AmbientLight: s_,
  AnimationAction: g_,
  AnimationClip: Ca,
  AnimationLoader: xC,
  AnimationMixer: m_,
  AnimationObjectGroup: HC,
  AnimationUtils: bC,
  ArcCurve: D0,
  ArrayCamera: x0,
  ArrowHelper: uM,
  AttachedBindMode: $h,
  Audio: Sd,
  AudioAnalyser: LC,
  AudioContext: xd,
  AudioListener: d_,
  AudioLoader: h_,
  AxesHelper: hM,
  BackSide: Fn,
  BasicDepthPacking: n0,
  BasicShadowMap: Qb,
  BatchedMesh: w0,
  Bone: Zl,
  BooleanKeyframeTrack: Ps,
  Box2: JC,
  Box3: bn,
  Box3Helper: cM,
  BoxGeometry: en,
  BoxHelper: oM,
  BufferAttribute: ut,
  BufferGeometry: ot,
  BufferGeometryLoader: l_,
  ByteType: qm,
  Cache: Ts,
  Camera: Wl,
  CameraHelper: aM,
  CanvasTexture: R0,
  CapsuleGeometry: jo,
  CatmullRomCurve3: L0,
  CineonToneMapping: Hm,
  CircleGeometry: nu,
  ClampToEdgeWrapping: Ln,
  Clock: f_,
  Color: Pe,
  ColorKeyframeTrack: md,
  ColorManagement: Tt,
  CompressedArrayTexture: T0,
  CompressedCubeTexture: B0,
  CompressedTexture: Ra,
  CompressedTextureLoader: SC,
  ConeGeometry: iu,
  ConstantAlphaFactor: Bm,
  ConstantColorFactor: wm,
  CubeCamera: td,
  CubeReflectionMapping: Xi,
  CubeRefractionMapping: Fr,
  CubeTexture: Ta,
  CubeTextureLoader: n_,
  CubeUVReflectionMapping: Ia,
  CubicBezierCurve: ud,
  CubicBezierCurve3: P0,
  CubicInterpolant: Z0,
  CullFaceBack: Xh,
  CullFaceFront: Am,
  CullFaceFrontBack: Ob,
  CullFaceNone: pm,
  Curve: Pi,
  CurvePath: F0,
  CustomBlending: gm,
  CustomToneMapping: Vm,
  CylinderGeometry: hn,
  Cylindrical: jC,
  Data3DTexture: zl,
  DataArrayTexture: Gl,
  DataTexture: pr,
  DataTextureLoader: i_,
  DataUtils: uo,
  DecrementStencilOp: jb,
  DecrementWrapStencilOp: Kb,
  DefaultLoadingManager: t_,
  DepthFormat: Lr,
  DepthStencilFormat: xs,
  DepthTexture: rd,
  DetachedBindMode: Wm,
  DirectionalLight: fu,
  DirectionalLightHelper: sM,
  DiscreteInterpolant: $0,
  DisplayP3ColorSpace: Ho,
  DodecahedronGeometry: ru,
  DoubleSide: Mn,
  DstAlphaFactor: xm,
  DstColorFactor: Cm,
  DynamicCopyUsage: hy,
  DynamicDrawUsage: vf,
  DynamicReadUsage: cy,
  EdgesGeometry: k0,
  EllipseCurve: tu,
  EqualCompare: a0,
  EqualDepth: Um,
  EqualStencilFunc: ty,
  EquirectangularReflectionMapping: _a,
  EquirectangularRefractionMapping: Mo,
  Euler: Ds,
  EventDispatcher: Yi,
  ExtrudeGeometry: au,
  FileLoader: wn,
  Float16BufferAttribute: Jy,
  Float32BufferAttribute: je,
  Float64BufferAttribute: Ky,
  FloatType: pn,
  Fog: jl,
  FogExp2: Yl,
  FramebufferTexture: HS,
  FrontSide: mi,
  Frustum: Vo,
  GLBufferAttribute: YC,
  GLSL1: dy,
  GLSL3: Ef,
  GreaterCompare: o0,
  GreaterDepth: km,
  GreaterEqualCompare: l0,
  GreaterEqualDepth: Fm,
  GreaterEqualStencilFunc: sy,
  GreaterStencilFunc: iy,
  GridHelper: iM,
  Group: Un,
  HalfFloatType: Pn,
  HemisphereLight: r_,
  HemisphereLightHelper: nM,
  IcosahedronGeometry: Jo,
  ImageBitmapLoader: u_,
  ImageLoader: Oo,
  ImageUtils: Zf,
  IncrementStencilOp: Yb,
  IncrementWrapStencilOp: Jb,
  InstancedBufferAttribute: Nr,
  InstancedBufferGeometry: Ed,
  InstancedInterleavedBuffer: XC,
  InstancedMesh: $l,
  Int16BufferAttribute: Yy,
  Int32BufferAttribute: jy,
  Int8BufferAttribute: Wy,
  IntType: zf,
  InterleavedBuffer: qo,
  InterleavedBufferAttribute: kr,
  Interpolant: La,
  InterpolateDiscrete: ya,
  InterpolateLinear: Ss,
  InterpolateSmooth: hl,
  InvertStencilOp: Zb,
  KeepStencilOp: ls,
  KeyframeTrack: Fi,
  LOD: I0,
  LatheGeometry: Yo,
  Layers: Hl,
  LessCompare: s0,
  LessDepth: Pm,
  LessEqualCompare: Jf,
  LessEqualDepth: Co,
  LessEqualStencilFunc: ny,
  LessStencilFunc: ey,
  Light: Hr,
  LightProbe: c_,
  Line: Dn,
  Line3: KC,
  LineBasicMaterial: kn,
  LineCurve: hd,
  LineCurve3: U0,
  LineDashedMaterial: j0,
  LineLoop: od,
  LineSegments: Li,
  LinearDisplayP3ColorSpace: wa,
  LinearEncoding: va,
  LinearFilter: wt,
  LinearInterpolant: gd,
  LinearMipMapLinearFilter: Wb,
  LinearMipMapNearestFilter: Vb,
  LinearMipmapLinearFilter: _i,
  LinearMipmapNearestFilter: Fl,
  LinearSRGBColorSpace: rn,
  LinearToneMapping: Gm,
  LinearTransfer: Bo,
  Loader: Tn,
  LoaderUtils: Ur,
  LoadingManager: _d,
  LoopOnce: Zm,
  LoopPingPong: e0,
  LoopRepeat: $m,
  LuminanceAlphaFormat: Jm,
  LuminanceFormat: jm,
  MOUSE: os,
  Material: vn,
  MaterialLoader: du,
  MathUtils: Cs,
  Matrix3: ft,
  Matrix4: Je,
  MaxEquation: Zh,
  Mesh: Ne,
  MeshBasicMaterial: In,
  MeshDepthMaterial: Wo,
  MeshDistanceMaterial: Xl,
  MeshLambertMaterial: X0,
  MeshMatcapMaterial: Y0,
  MeshNormalMaterial: q0,
  MeshPhongMaterial: V0,
  MeshPhysicalMaterial: Ui,
  MeshStandardMaterial: Ko,
  MeshToonMaterial: W0,
  MinEquation: Kh,
  MirroredRepeatWrapping: ba,
  MixOperation: Om,
  MultiplyBlending: Jh,
  MultiplyOperation: zo,
  NearestFilter: tn,
  NearestMipMapLinearFilter: Hb,
  NearestMipMapNearestFilter: zb,
  NearestMipmapLinearFilter: Aa,
  NearestMipmapNearestFilter: Io,
  NeverCompare: r0,
  NeverDepth: Dm,
  NeverStencilFunc: $b,
  NoBlending: fr,
  NoColorSpace: jn,
  NoToneMapping: dr,
  NormalAnimationBlendMode: Ol,
  NormalBlending: ys,
  NotEqualCompare: c0,
  NotEqualDepth: Nm,
  NotEqualStencilFunc: ry,
  NumberKeyframeTrack: Is,
  Object3D: bt,
  ObjectLoader: wC,
  ObjectSpaceNormalMap: i0,
  OctahedronGeometry: hr,
  OneFactor: ym,
  OneMinusConstantAlphaFactor: Rm,
  OneMinusConstantColorFactor: Tm,
  OneMinusDstAlphaFactor: Sm,
  OneMinusDstColorFactor: Mm,
  OneMinusSrcAlphaFactor: El,
  OneMinusSrcColorFactor: Em,
  OrthographicCamera: Ls,
  P3Primaries: Do,
  PCFShadowMap: Qf,
  PCFSoftShadowMap: Pl,
  PMREMGenerator: Sf,
  Path: Uo,
  PerspectiveCamera: _n,
  Plane: ar,
  PlaneGeometry: ji,
  PlaneHelper: lM,
  PointLight: vd,
  PointLightHelper: eM,
  Points: cd,
  PointsMaterial: eu,
  PolarGridHelper: rM,
  PolyhedronGeometry: zr,
  PositionalAudio: p_,
  PropertyBinding: It,
  PropertyMixer: A_,
  QuadraticBezierCurve: fd,
  QuadraticBezierCurve3: dd,
  Quaternion: Rt,
  QuaternionKeyframeTrack: Or,
  QuaternionLinearInterpolant: e_,
  RED_GREEN_RGTC2_Format: _f,
  RED_RGTC1_Format: Km,
  REVISION: Ma,
  RGBADepthPacking: Ql,
  RGBAFormat: dn,
  RGBAIntegerFormat: Xf,
  RGBA_ASTC_10x10_Format: ff,
  RGBA_ASTC_10x5_Format: lf,
  RGBA_ASTC_10x6_Format: uf,
  RGBA_ASTC_10x8_Format: hf,
  RGBA_ASTC_12x10_Format: df,
  RGBA_ASTC_12x12_Format: pf,
  RGBA_ASTC_4x4_Format: Il,
  RGBA_ASTC_5x4_Format: nf,
  RGBA_ASTC_5x5_Format: rf,
  RGBA_ASTC_6x5_Format: sf,
  RGBA_ASTC_6x6_Format: wo,
  RGBA_ASTC_8x5_Format: af,
  RGBA_ASTC_8x6_Format: of,
  RGBA_ASTC_8x8_Format: cf,
  RGBA_BPTC_Format: mo,
  RGBA_ETC2_EAC_Format: Ml,
  RGBA_PVRTC_2BPPV1_Format: tf,
  RGBA_PVRTC_4BPPV1_Format: Sl,
  RGBA_S3TC_DXT1_Format: ll,
  RGBA_S3TC_DXT3_Format: ul,
  RGBA_S3TC_DXT5_Format: go,
  RGB_BPTC_SIGNED_Format: Af,
  RGB_BPTC_UNSIGNED_Format: gf,
  RGB_ETC1_Format: Nl,
  RGB_ETC2_Format: Cl,
  RGB_PVRTC_2BPPV1_Format: ef,
  RGB_PVRTC_4BPPV1_Format: xl,
  RGB_S3TC_DXT1_Format: Ao,
  RGFormat: As,
  RGIntegerFormat: qf,
  RawShaderMaterial: H0,
  Ray: Rs,
  Raycaster: Zo,
  Rec709Primaries: Ro,
  RectAreaLight: a_,
  RedFormat: ps,
  RedIntegerFormat: Wf,
  ReinhardToneMapping: zm,
  RenderTarget: d0,
  RepeatWrapping: Ar,
  ReplaceStencilOp: Xb,
  ReverseSubtractEquation: _m,
  RingGeometry: ou,
  SIGNED_RED_GREEN_RGTC2_Format: bf,
  SIGNED_RED_RGTC1_Format: mf,
  SRGBColorSpace: Ot,
  SRGBTransfer: zt,
  Scene: Jl,
  ShaderChunk: tt,
  ShaderLib: Ri,
  ShaderMaterial: Kn,
  ShadowMaterial: z0,
  Shape: Pr,
  ShapeGeometry: cu,
  ShapePath: fM,
  ShapeUtils: qi,
  ShortType: Xm,
  Skeleton: Xo,
  SkeletonHelper: $C,
  SkinnedMesh: ad,
  Source: _s,
  Sphere: yn,
  SphereGeometry: Da,
  Spherical: Rf,
  SphericalHarmonics3: o_,
  SplineCurve: pd,
  SpotLight: yd,
  SpotLightHelper: ZC,
  Sprite: M0,
  SpriteMaterial: Kl,
  SrcAlphaFactor: vl,
  SrcAlphaSaturateFactor: Im,
  SrcColorFactor: vm,
  StaticCopyUsage: uy,
  StaticDrawUsage: Lo,
  StaticReadUsage: oy,
  StereoCamera: BC,
  StreamCopyUsage: fy,
  StreamDrawUsage: ay,
  StreamReadUsage: ly,
  StringKeyframeTrack: Us,
  SubtractEquation: mm,
  SubtractiveBlending: jh,
  TOUCH: cs,
  TangentSpaceNormalMap: Gr,
  TetrahedronGeometry: lu,
  Texture: Jt,
  TextureLoader: Qo,
  TorusGeometry: cr,
  TorusKnotGeometry: uu,
  Triangle: ii,
  TriangleFanDrawMode: wl,
  TriangleStripDrawMode: jf,
  TrianglesDrawMode: t0,
  TubeGeometry: hu,
  TwoPassDoubleSide: Gb,
  UVMapping: Ul,
  Uint16BufferAttribute: $f,
  Uint32BufferAttribute: ed,
  Uint8BufferAttribute: qy,
  Uint8ClampedBufferAttribute: Xy,
  Uniform: Id,
  UniformsGroup: qC,
  UniformsLib: He,
  UniformsUtils: Vl,
  UnsignedByteType: fn,
  UnsignedInt248Type: Dr,
  UnsignedIntType: ur,
  UnsignedShort4444Type: Hf,
  UnsignedShort5551Type: Vf,
  UnsignedShortType: kl,
  VSMShadowMap: Oi,
  Vector2: xe,
  Vector3: P,
  Vector4: Dt,
  VectorKeyframeTrack: ws,
  VideoTexture: zS,
  WebGL1Renderer: S0,
  WebGL3DRenderTarget: Ly,
  WebGLArrayRenderTarget: Dy,
  WebGLCoordinateSystem: Di,
  WebGLCubeRenderTarget: nd,
  WebGLMultipleRenderTargets: Py,
  WebGLRenderTarget: pi,
  WebGLRenderer: sd,
  WebGLUtils: E0,
  WebGPUCoordinateSystem: Ea,
  WireframeGeometry: G0,
  WrapAroundEnding: To,
  ZeroCurvatureEnding: gs,
  ZeroFactor: bm,
  ZeroSlopeEnding: ms,
  ZeroStencilOp: qb,
  _SRGBAFormat: Tl,
  createCanvasElement: f0,
  sRGBEncoding: Wi
}, Symbol.toStringTag, { value: "Module" })), oa = [];
function wd(s, e) {
  return {
    subscribe: vt(s, e).subscribe
  };
}
function vt(s, e = si) {
  let t;
  const n = /* @__PURE__ */ new Set();
  function i(o) {
    if (pt(s, o) && (s = o, t)) {
      const c = !oa.length;
      for (const l of n)
        l[1](), oa.push(l, s);
      if (c) {
        for (let l = 0; l < oa.length; l += 2)
          oa[l][0](oa[l + 1]);
        oa.length = 0;
      }
    }
  }
  function r(o) {
    i(o(s));
  }
  function a(o, c = si) {
    const l = [o, c];
    return n.add(l), n.size === 1 && (t = e(i, r) || si), o(s), () => {
      n.delete(l), n.size === 0 && t && (t(), t = null);
    };
  }
  return { set: i, update: r, subscribe: a };
}
function Vn(s, e, t) {
  const n = !Array.isArray(s), i = n ? [s] : s;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const r = e.length < 2;
  return wd(t, (a, o) => {
    let c = !1;
    const l = [];
    let u = 0, h = si;
    const f = () => {
      if (u)
        return;
      h();
      const A = e(n ? l[0] : l, a, o);
      r ? a(A) : h = Dl(A) ? A : si;
    }, d = i.map(
      (A, m) => Go(
        A,
        (p) => {
          l[m] = p, u &= ~(1 << m), c && f();
        },
        () => {
          u |= 1 << m;
        }
      )
    );
    return c = !0, f(), function() {
      Bs(d), h(), c = !1;
    };
  });
}
class wr {
  constructor() {
    Bt(this, "allVertices", {});
    /** Nodes that are fully unlinked */
    Bt(this, "isolatedVertices", {});
    Bt(this, "connectedVertices", {});
    Bt(this, "sortedConnectedValues", []);
    Bt(this, "needsSort", !1);
    Bt(this, "getKey", (e) => typeof e == "object" ? e.key : e);
  }
  moveToIsolated(e) {
    const t = this.connectedVertices[e];
    t && (this.isolatedVertices[e] = t, delete this.connectedVertices[e]);
  }
  moveToConnected(e) {
    const t = this.isolatedVertices[e];
    t && (this.connectedVertices[e] = t, delete this.isolatedVertices[e]);
  }
  add(e, t, n) {
    if (this.allVertices[e] && this.allVertices[e].value !== void 0)
      throw new Error(`A node with the key ${e.toString()} already exists`);
    let i = this.allVertices[e];
    i ? i.value === void 0 && (i.value = t) : (i = {
      value: t,
      previous: /* @__PURE__ */ new Set(),
      next: /* @__PURE__ */ new Set()
    }, this.allVertices[e] = i);
    const r = i.next.size > 0 || i.previous.size > 0;
    if (!(n != null && n.after) && !(n != null && n.before) && !r) {
      this.isolatedVertices[e] = i;
      return;
    } else
      this.connectedVertices[e] = i;
    if (n != null && n.after) {
      const a = Array.isArray(n.after) ? n.after : [n.after];
      a.forEach((o) => {
        i.previous.add(this.getKey(o));
      }), a.forEach((o) => {
        const c = this.getKey(o), l = this.allVertices[c];
        l ? (l.next.add(e), this.moveToConnected(c)) : (this.allVertices[c] = {
          value: void 0,
          previous: /* @__PURE__ */ new Set(),
          next: /* @__PURE__ */ new Set([e])
        }, this.connectedVertices[c] = this.allVertices[c]);
      });
    }
    if (n != null && n.before) {
      const a = Array.isArray(n.before) ? n.before : [n.before];
      a.forEach((o) => {
        i.next.add(this.getKey(o));
      }), a.forEach((o) => {
        const c = this.getKey(o), l = this.allVertices[c];
        l ? (l.previous.add(e), this.moveToConnected(c)) : (this.allVertices[c] = {
          value: void 0,
          previous: /* @__PURE__ */ new Set([e]),
          next: /* @__PURE__ */ new Set()
        }, this.connectedVertices[c] = this.allVertices[c]);
      });
    }
    this.needsSort = !0;
  }
  remove(e) {
    const t = this.getKey(e);
    if (this.isolatedVertices[t]) {
      delete this.isolatedVertices[t], delete this.allVertices[t];
      return;
    }
    const i = this.connectedVertices[t];
    i && (i.next.forEach((r) => {
      const a = this.connectedVertices[r];
      a && (a.previous.delete(t), a.previous.size === 0 && a.next.size === 0 && this.moveToIsolated(r));
    }), i.previous.forEach((r) => {
      const a = this.connectedVertices[r];
      a && (a.next.delete(t), a.previous.size === 0 && a.next.size === 0 && this.moveToIsolated(r));
    }), delete this.connectedVertices[t], delete this.allVertices[t], this.needsSort = !0);
  }
  mapNodes(e) {
    this.needsSort && this.sort();
    const t = [];
    return this.forEachNode((n, i) => {
      t.push(e(n, i));
    }), t;
  }
  forEachNode(e) {
    this.needsSort && this.sort();
    let t = 0;
    for (; t < this.sortedConnectedValues.length; t++)
      e(this.sortedConnectedValues[t], t);
    Reflect.ownKeys(this.isolatedVertices).forEach((n) => {
      const i = this.isolatedVertices[n];
      i.value !== void 0 && e(i.value, t++);
    });
  }
  getValueByKey(e) {
    var t;
    return (t = this.allVertices[e]) == null ? void 0 : t.value;
  }
  getKeyByValue(e) {
    return Reflect.ownKeys(this.connectedVertices).find((t) => this.connectedVertices[t].value === e) ?? Reflect.ownKeys(this.isolatedVertices).find((t) => this.isolatedVertices[t].value === e);
  }
  sort() {
    var a;
    const e = /* @__PURE__ */ new Map(), t = [], n = [], i = Reflect.ownKeys(this.connectedVertices).filter((o) => this.connectedVertices[o].value !== void 0);
    for (i.forEach((o) => {
      e.set(o, 0);
    }), i.forEach((o) => {
      this.connectedVertices[o].next.forEach((l) => {
        this.connectedVertices[l] && e.set(l, (e.get(l) || 0) + 1);
      });
    }), e.forEach((o, c) => {
      o === 0 && t.push(c);
    }); t.length > 0; ) {
      const o = t.shift();
      n.push(o);
      const c = i.find((l) => l === o);
      c && ((a = this.connectedVertices[c]) == null || a.next.forEach((l) => {
        const u = (e.get(l) || 0) - 1;
        e.set(l, u), u === 0 && t.push(l);
      }));
    }
    if (n.length !== i.length)
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    const r = (o) => o !== void 0;
    this.sortedConnectedValues = n.map((o) => this.connectedVertices[o].value).filter(r), this.needsSort = !1;
  }
  clear() {
    this.allVertices = {}, this.isolatedVertices = {}, this.connectedVertices = {}, this.sortedConnectedValues = [], this.needsSort = !1;
  }
  static isKey(e) {
    return typeof e == "string" || typeof e == "symbol";
  }
  static isValue(e) {
    return typeof e == "object" && "key" in e;
  }
}
class pM {
  constructor(e, t, n) {
    Bt(this, "key");
    Bt(this, "stage");
    Bt(this, "callback");
    Bt(this, "runTask", !0);
    this.stage = e, this.key = t, this.callback = n;
  }
  stop() {
    this.runTask = !1;
  }
  start() {
    this.runTask = !0;
  }
  run(e) {
    this.runTask && this.callback(e);
  }
}
class AM extends wr {
  constructor(t, n, i) {
    super();
    Bt(this, "key");
    Bt(this, "scheduler");
    Bt(this, "callback", (t, n) => n());
    Bt(this, "removeTask", this.remove.bind(this));
    this.scheduler = t, this.key = n, i && (this.callback = i.bind(this));
  }
  createTask(t, n, i) {
    const r = new pM(this, t, n);
    return this.add(t, r, i), r;
  }
  getTask(t) {
    return this.getValueByKey(t);
  }
  run(t) {
    this.callback(t, (n) => {
      this.forEachNode((i) => {
        i.run(n ?? t);
      });
    });
  }
  runWithTiming(t) {
    const n = {};
    return this.callback(t, (i) => {
      this.forEachNode((r) => {
        const a = performance.now();
        r.run(i ?? t);
        const o = performance.now() - a;
        n[r.key] = o;
      });
    }), n;
  }
  getSchedule() {
    return this.mapNodes((t) => t.key.toString());
  }
}
class gM extends wr {
  constructor(t) {
    super();
    Bt(this, "lastTime", performance.now());
    Bt(this, "clampDeltaTo", 0.1);
    Bt(this, "removeStage", this.remove.bind(this));
    t != null && t.clampDeltaTo && (this.clampDeltaTo = t.clampDeltaTo), this.run = this.run.bind(this);
  }
  createStage(t, n) {
    const i = new AM(this, t, n == null ? void 0 : n.callback);
    return this.add(t, i, {
      after: n == null ? void 0 : n.after,
      before: n == null ? void 0 : n.before
    }), i;
  }
  getStage(t) {
    return this.getValueByKey(t);
  }
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(t) {
    const n = t - this.lastTime;
    this.forEachNode((i) => {
      i.run(Math.min(n / 1e3, this.clampDeltaTo));
    }), this.lastTime = t;
  }
  runWithTiming(t) {
    const n = t - this.lastTime, i = {}, r = performance.now();
    return this.forEachNode((a) => {
      const o = performance.now(), c = a.runWithTiming(Math.min(n / 1e3, this.clampDeltaTo)), l = performance.now() - o;
      i[a.key.toString()] = {
        duration: l,
        tasks: c
      };
    }), {
      total: performance.now() - r,
      stages: i
    };
  }
  getSchedule(t = {
    tasks: !0
  }) {
    return {
      stages: this.mapNodes((n) => {
        if (n === void 0)
          throw new Error("Stage not found");
        return {
          key: n.key.toString(),
          tasks: t.tasks ? n.getSchedule() : void 0
        };
      })
    };
  }
}
const mM = Symbol("use-legacy-frame-compatibility-context"), _M = () => {
  const s = {
    useFrameOrders: [],
    useRenderOrders: []
  };
  return Jn(mM, s), s;
}, Ft = (s, e) => {
  const t = Vn(s, (r) => r);
  let n;
  const i = t.subscribe(async (r) => {
    n && n();
    const a = await e(r);
    a && (n = a);
  });
  Wt(() => {
    i(), n && n();
  });
};
function b_(s, e) {
  const t = {
    current: void 0
  };
  return Ft(s, (n) => {
    t.current = e ? e(n) : n;
  }), t;
}
const Ht = (s) => {
  const e = vt(s), t = {
    set: (n) => {
      t.current = n, e.set(n);
    },
    subscribe: e.subscribe,
    update: (n) => {
      const i = n(t.current);
      t.current = i, e.set(i);
    },
    current: s
  };
  return t;
}, Td = typeof window < "u", bM = () => {
  const s = Ht({ width: 0, height: 0 });
  if (!Td)
    return {
      parentSize: s,
      parentSizeAction: () => {
      }
    };
  const e = { childList: !0, subtree: !1, attributes: !1 };
  let t;
  const n = (o) => {
    i.disconnect(), r.disconnect(), i.observe(o), r.observe(o, e);
  }, i = new ResizeObserver(([o]) => {
    const { width: c, height: l } = o.contentRect;
    c === s.current.width && l === s.current.height || s.set({ width: c, height: l });
  }), r = new MutationObserver((o) => {
    for (const c of o)
      for (const l of c.removedNodes)
        if (t === l && t.parentElement) {
          n(t.parentElement);
          return;
        }
  }), a = (o) => {
    t = o;
    const c = t.parentElement;
    c && (s.set({
      width: c.clientWidth,
      height: c.clientHeight
    }), n(c));
  };
  return Wt(() => {
    i.disconnect(), r.disconnect();
  }), {
    parentSize: s,
    parentSizeAction: a
  };
};
function yM(s, e) {
  const t = vt(s);
  let n = s;
  const i = t.subscribe((o) => n = o);
  return Wt(i), {
    ...t,
    set: (o) => {
      if ((o == null ? void 0 : o.uuid) === (n == null ? void 0 : n.uuid))
        return;
      const c = n;
      t.set(o), e == null || e(o, c);
    },
    update: (o) => {
      const c = o(n);
      if ((c == null ? void 0 : c.uuid) === (n == null ? void 0 : n.uuid))
        return;
      const l = n;
      t.set(c), e == null || e(c, l);
    }
  };
}
const sn = () => {
  const s = Wn("threlte");
  if (s === void 0)
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  return s;
}, Fs = () => Wn("threlte-hierarchical-parent-context");
function vM(s) {
  let e;
  const t = (
    /*#slots*/
    s[8].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[7],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, [r]) {
      n && n.p && (!e || r & /*$$scope*/
      128) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? gt(
          t,
          /*$$scope*/
          i[7],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[7]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
const EM = () => ({
  onChildMount: Wn("threlte-hierarchical-object-on-mount"),
  onChildDestroy: Wn("threlte-hierarchical-object-on-destroy")
});
function xM(s, e, t) {
  var g;
  let n, { $$slots: i = {}, $$scope: r } = e, { object: a = void 0 } = e, { children: o = [] } = e, { onChildMount: c = void 0 } = e;
  const l = (_) => {
    o.push(_), t(1, o), c == null || c(_);
  };
  let { onChildDestroy: u = void 0 } = e;
  const h = (_) => {
    const b = o.findIndex((y) => y.uuid === _.uuid);
    b !== -1 && o.splice(b, 1), t(1, o), u == null || u(_);
  }, { invalidate: f } = sn(), d = Fs();
  $e(s, d, (_) => t(6, n = _));
  let { parent: A = n } = e;
  const m = EM();
  a && ((g = m.onChildMount) == null || g.call(m, a), f());
  const p = yM(a, (_, b) => {
    var y, v;
    b && ((y = m.onChildDestroy) == null || y.call(m, b), f()), _ && ((v = m.onChildMount) == null || v.call(m, _), f());
  });
  return Wt(() => {
    var _;
    a && ((_ = m.onChildDestroy) == null || _.call(m, a), f());
  }), Jn("threlte-hierarchical-object-on-mount", l), Jn("threlte-hierarchical-object-on-destroy", h), Jn("threlte-hierarchical-parent-context", p), s.$$set = (_) => {
    "object" in _ && t(3, a = _.object), "children" in _ && t(1, o = _.children), "onChildMount" in _ && t(4, c = _.onChildMount), "onChildDestroy" in _ && t(5, u = _.onChildDestroy), "parent" in _ && t(2, A = _.parent), "$$scope" in _ && t(7, r = _.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*$parentStore*/
    64 && t(2, A = n), s.$$.dirty & /*object*/
    8 && p.set(a);
  }, [
    d,
    o,
    A,
    a,
    c,
    u,
    n,
    r,
    i
  ];
}
class Pa extends St {
  constructor(e) {
    super(), Et(this, e, xM, vM, pt, {
      object: 3,
      children: 1,
      onChildMount: 4,
      onChildDestroy: 5,
      parent: 2
    });
  }
  get object() {
    return this.$$.ctx[3];
  }
  set object(e) {
    this.$$set({ object: e }), Y();
  }
  get children() {
    return this.$$.ctx[1];
  }
  set children(e) {
    this.$$set({ children: e }), Y();
  }
  get onChildMount() {
    return this.$$.ctx[4];
  }
  set onChildMount(e) {
    this.$$set({ onChildMount: e }), Y();
  }
  get onChildDestroy() {
    return this.$$.ctx[5];
  }
  set onChildDestroy(e) {
    this.$$set({ onChildDestroy: e }), Y();
  }
  get parent() {
    return this.$$.ctx[2];
  }
  set parent(e) {
    this.$$set({ parent: e }), Y();
  }
}
xt(Pa, { object: {}, children: {}, onChildMount: {}, onChildDestroy: {}, parent: {} }, ["default"], [], !0);
function SM(s) {
  let e;
  const t = (
    /*#slots*/
    s[1].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[4],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      16) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[4],
        e ? gt(
          t,
          /*$$scope*/
          i[4],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[4]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function CM(s) {
  let e, t;
  return e = new Pa({
    props: {
      object: (
        /*object*/
        s[0]
      ),
      onChildMount: (
        /*func*/
        s[2]
      ),
      onChildDestroy: (
        /*func_1*/
        s[3]
      ),
      $$slots: { default: [SM] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, [i]) {
      const r = {};
      i & /*object*/
      1 && (r.object = /*object*/
      n[0]), i & /*object*/
      1 && (r.onChildMount = /*func*/
      n[2]), i & /*object*/
      1 && (r.onChildDestroy = /*func_1*/
      n[3]), i & /*$$scope*/
      16 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function MM(s, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { object: r } = e;
  const a = (c) => r.add(c), o = (c) => r.remove(c);
  return s.$$set = (c) => {
    "object" in c && t(0, r = c.object), "$$scope" in c && t(4, i = c.$$scope);
  }, [r, n, a, o, i];
}
class Bd extends St {
  constructor(e) {
    super(), Et(this, e, MM, CM, pt, { object: 0 });
  }
  get object() {
    return this.$$.ctx[0];
  }
  set object(e) {
    this.$$set({ object: e }), Y();
  }
}
xt(Bd, { object: {} }, ["default"], [], !0);
const BA = (s, e) => {
  if (s === e)
    return !0;
  if (!s || !e)
    return !1;
  const t = s.length;
  if (e.length !== t)
    return !1;
  for (let n = 0; n < t; n++)
    if (s[n] !== e[n])
      return !1;
  return !0;
}, IM = () => {
  Jn("threlte-cache", []);
}, y_ = () => {
  const s = Wn("threlte-cache");
  if (!s)
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  return {
    remember: (n, i) => {
      for (const a of s)
        if (BA(i, a.keys)) {
          if (a.error)
            throw a.error;
          if (a.promise)
            return a.promise;
        }
      const r = {
        promise: n(),
        keys: i,
        value: void 0
      };
      return s.push(r), r.promise.catch((a) => {
        r.error = a;
      }), r.promise;
    },
    clear: (n) => {
      const i = s.findIndex((r) => BA(n, r.keys));
      i !== -1 && s.splice(i, 1);
    }
  };
}, v_ = (s) => s.userData, wM = () => {
  const s = new _n(75, 0, 0.1, 1e3);
  return v_(s).threlteDefaultCamera = !0, s.position.z = 5, s.lookAt(0, 0, 0), s;
}, TM = (s) => {
  Ft(s.size, (e) => {
    v_(vb(s.camera)).threlteDefaultCamera && s.camera.update((t) => {
      const n = t;
      return n.aspect = e.width / e.height, n.updateProjectionMatrix(), s.invalidate(), n;
    });
  });
}, BM = (s) => {
  const e = {
    frameInvalidated: !0,
    advance: !1,
    autoInvalidations: /* @__PURE__ */ new Set(),
    resetFrameInvalidation: () => {
      e.frameInvalidated = !1, e.advance = !1;
    },
    dispose: async (a = !1) => {
      await Ll(), !(!e.shouldDispose && !a) && (e.disposableObjects.forEach((o, c) => {
        var l;
        (o === 0 || a) && ((l = c == null ? void 0 : c.dispose) == null || l.call(c), e.disposableObjects.delete(c));
      }), e.shouldDispose = !1);
    },
    collectDisposableObjects: (a, o) => {
      const c = o ?? [];
      return a && (a != null && a.dispose && typeof a.dispose == "function" && a.type !== "Scene" && c.push(a), Object.entries(a).forEach(([l, u]) => {
        if (l === "parent" || l === "children" || typeof u != "object")
          return;
        const h = u;
        h != null && h.dispose && e.collectDisposableObjects(h, c);
      })), c;
    },
    addDisposableObjects: (a) => {
      a.forEach((o) => {
        const c = e.disposableObjects.get(o);
        c ? e.disposableObjects.set(o, c + 1) : e.disposableObjects.set(o, 1);
      });
    },
    removeDisposableObjects: (a) => {
      a.length !== 0 && (a.forEach((o) => {
        const c = e.disposableObjects.get(o);
        c && c > 0 && e.disposableObjects.set(o, c - 1);
      }), e.shouldDispose = !0);
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: !1
  }, t = {
    size: Vn([s.userSize, s.parentSize], ([a, o]) => a || o),
    camera: Ht(wM()),
    scene: new Jl(),
    renderer: void 0,
    invalidate: () => {
      e.frameInvalidated = !0;
    },
    advance: () => {
      e.advance = !0;
    },
    colorSpace: Ht(s.colorSpace),
    toneMapping: Ht(s.toneMapping),
    dpr: Ht(s.dpr),
    useLegacyLights: Ht(s.useLegacyLights),
    shadows: Ht(s.shadows),
    colorManagementEnabled: Ht(s.colorManagementEnabled),
    renderMode: Ht(s.renderMode),
    autoRender: Ht(s.autoRender),
    scheduler: void 0,
    mainStage: void 0,
    renderStage: void 0,
    autoRenderTask: void 0,
    shouldRender: () => t.renderMode.current === "always" || t.renderMode.current === "on-demand" && (e.frameInvalidated || e.autoInvalidations.size > 0) || t.renderMode.current === "manual" && e.advance
  }, n = Ht({});
  return Jn("threlte", t), Jn("threlte-internal-context", e), Jn("threlte-user-context", n), {
    ctx: t,
    internalCtx: e,
    getCtx: () => t,
    getInternalCtx: () => e
  };
}, dl = Number.parseInt(Ma.replace("dev", "")), RM = {
  srgb: Wi,
  "srgb-linear": va,
  "": va
}, DM = (s) => s.outputColorSpace !== void 0, LM = (s) => {
  const e = vt(void 0), t = (n, i) => {
    s.renderer = new sd({
      powerPreference: "high-performance",
      canvas: n,
      antialias: !0,
      alpha: !0,
      ...i
    }), e.set(s.renderer);
  };
  return Ft([s.colorManagementEnabled], ([n]) => {
    dl >= 150 ? Tt.enabled = n : Tt.legacyMode = !n;
  }), Ft([e, s.colorSpace], ([n, i]) => {
    if (n)
      if (DM(n))
        n.outputColorSpace = i;
      else {
        const r = RM[i];
        r ? n.outputEncoding = r : console.warn("No encoding found for colorSpace", i);
      }
  }), Ft([e, s.dpr], ([n, i]) => {
    n == null || n.setPixelRatio(i);
  }), Ft([e, s.size], ([n, i]) => {
    var r;
    (r = n == null ? void 0 : n.xr) != null && r.isPresenting || n == null || n.setSize(i.width, i.height);
  }), Ft([e, s.shadows], ([n, i]) => {
    n && (n.shadowMap.enabled = !!i, i && i !== !0 ? n.shadowMap.type = i : i === !0 && (n.shadowMap.type = Pl));
  }), Ft([e, s.toneMapping], ([n, i]) => {
    n && (n.toneMapping = i);
  }), Ft([e, s.useLegacyLights], ([n, i]) => {
    n && (dl >= 150 && i ? n.useLegacyLights = i : dl < 150 && (n.physicallyCorrectLights = !i));
  }), {
    createRenderer: t
  };
};
function PM(s) {
  Eb(s, "svelte-o3oskp", "canvas.svelte-o3oskp{display:block}");
}
function RA(s) {
  let e, t;
  return e = new Bd({
    props: {
      object: (
        /*contexts*/
        s[4].ctx.scene
      ),
      $$slots: { default: [UM] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      262144 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function UM(s) {
  let e;
  const t = (
    /*#slots*/
    s[16].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[18],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      262144) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[18],
        e ? gt(
          t,
          /*$$scope*/
          i[18],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[18]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function FM(s) {
  let e, t, n, i, r = (
    /*$initialized*/
    s[1] && RA(s)
  );
  return {
    c() {
      e = Rr("canvas"), r && r.c(), Hi(e, "class", "svelte-o3oskp");
    },
    m(a, o) {
      st(a, e, o), r && r.m(e, null), s[17](e), t = !0, n || (i = _l(
        /*parentSizeAction*/
        s[3].call(null, e)
      ), n = !0);
    },
    p(a, [o]) {
      /*$initialized*/
      a[1] ? r ? (r.p(a, o), o & /*$initialized*/
      2 && ae(r, 1)) : (r = RA(a), r.c(), ae(r, 1), r.m(e, null)) : r && (ai(), ue(r, 1, 1, () => {
        r = null;
      }), oi());
    },
    i(a) {
      t || (ae(r), t = !0);
    },
    o(a) {
      ue(r), t = !1;
    },
    d(a) {
      a && rt(e), r && r.d(), s[17](null), n = !1, i();
    }
  };
}
function kM(s, e, t) {
  let n, { $$slots: i = {}, $$scope: r } = e, { colorManagementEnabled: a = !0 } = e, { colorSpace: o = "srgb" } = e, { dpr: c = Td ? window.devicePixelRatio : 1 } = e, { renderMode: l = "on-demand" } = e, { rendererParameters: u = void 0 } = e, { shadows: h = Pl } = e, { size: f = void 0 } = e, { toneMapping: d = Gf } = e, { useLegacyLights: A = !(dl >= 155) } = e, { autoRender: m = !0 } = e, p, g = vt(!1);
  $e(s, g, (T) => t(1, n = T));
  const _ = vt(f), { parentSize: b, parentSizeAction: y } = bM(), { useRenderOrders: v } = _M(), x = BM({
    colorManagementEnabled: a,
    colorSpace: o,
    dpr: c,
    renderMode: l,
    parentSize: b,
    autoRender: m,
    shadows: h,
    toneMapping: d,
    useLegacyLights: A,
    userSize: _
  }), S = new gM();
  x.getCtx().mainStage = S.createStage(Symbol("threlte-main-stage")), x.getCtx().renderStage = S.createStage(Symbol("threlte-render-stage"), {
    after: x.ctx.mainStage,
    callback(T, D) {
      x.ctx.shouldRender() && D();
    }
  }), x.getCtx().autoRenderTask = x.ctx.renderStage.createTask(Symbol("threlte-auto-render-task"), (T) => {
    v.length > 0 || x.ctx.renderer.render(I.scene, I.camera.current);
  }), Ft([g, x.ctx.autoRender], ([T, D]) => (T && D ? x.getCtx().autoRenderTask.start() : x.getCtx().autoRenderTask.stop(), () => {
    x.getCtx().autoRenderTask.stop();
  })), x.getCtx().scheduler = S, IM();
  const I = x.ctx;
  TM(I);
  const { createRenderer: E } = LM(I);
  Qr(() => {
    E(p, u), x.getCtx().renderer.setAnimationLoop((T) => {
      x.getInternalCtx().dispose(), S.run(T), x.getInternalCtx().resetFrameInvalidation();
    }), g.set(!0);
  }), Wt(() => {
    var T;
    x.internalCtx.dispose(!0), x.ctx.scheduler.clear(), (T = x.ctx.renderer) == null || T.dispose();
  });
  function M(T) {
    Mt[T ? "unshift" : "push"](() => {
      p = T, t(0, p);
    });
  }
  return s.$$set = (T) => {
    "colorManagementEnabled" in T && t(5, a = T.colorManagementEnabled), "colorSpace" in T && t(6, o = T.colorSpace), "dpr" in T && t(7, c = T.dpr), "renderMode" in T && t(8, l = T.renderMode), "rendererParameters" in T && t(9, u = T.rendererParameters), "shadows" in T && t(10, h = T.shadows), "size" in T && t(11, f = T.size), "toneMapping" in T && t(12, d = T.toneMapping), "useLegacyLights" in T && t(13, A = T.useLegacyLights), "autoRender" in T && t(14, m = T.autoRender), "$$scope" in T && t(18, r = T.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*size*/
    2048 && _.set(f), s.$$.dirty & /*colorSpace*/
    64 && x.ctx.colorSpace.set(o), s.$$.dirty & /*dpr*/
    128 && x.ctx.dpr.set(c), s.$$.dirty & /*renderMode*/
    256 && x.ctx.renderMode.set(l), s.$$.dirty & /*autoRender*/
    16384 && x.ctx.autoRender.set(m), s.$$.dirty & /*shadows*/
    1024 && x.ctx.shadows.set(h), s.$$.dirty & /*toneMapping*/
    4096 && x.ctx.toneMapping.set(d);
  }, [
    p,
    n,
    g,
    y,
    x,
    a,
    o,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    m,
    I,
    i,
    M,
    r
  ];
}
class NM extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      kM,
      FM,
      pt,
      {
        colorManagementEnabled: 5,
        colorSpace: 6,
        dpr: 7,
        renderMode: 8,
        rendererParameters: 9,
        shadows: 10,
        size: 11,
        toneMapping: 12,
        useLegacyLights: 13,
        autoRender: 14,
        ctx: 15
      },
      PM
    );
  }
  get colorManagementEnabled() {
    return this.$$.ctx[5];
  }
  set colorManagementEnabled(e) {
    this.$$set({ colorManagementEnabled: e }), Y();
  }
  get colorSpace() {
    return this.$$.ctx[6];
  }
  set colorSpace(e) {
    this.$$set({ colorSpace: e }), Y();
  }
  get dpr() {
    return this.$$.ctx[7];
  }
  set dpr(e) {
    this.$$set({ dpr: e }), Y();
  }
  get renderMode() {
    return this.$$.ctx[8];
  }
  set renderMode(e) {
    this.$$set({ renderMode: e }), Y();
  }
  get rendererParameters() {
    return this.$$.ctx[9];
  }
  set rendererParameters(e) {
    this.$$set({ rendererParameters: e }), Y();
  }
  get shadows() {
    return this.$$.ctx[10];
  }
  set shadows(e) {
    this.$$set({ shadows: e }), Y();
  }
  get size() {
    return this.$$.ctx[11];
  }
  set size(e) {
    this.$$set({ size: e }), Y();
  }
  get toneMapping() {
    return this.$$.ctx[12];
  }
  set toneMapping(e) {
    this.$$set({ toneMapping: e }), Y();
  }
  get useLegacyLights() {
    return this.$$.ctx[13];
  }
  set useLegacyLights(e) {
    this.$$set({ useLegacyLights: e }), Y();
  }
  get autoRender() {
    return this.$$.ctx[14];
  }
  set autoRender(e) {
    this.$$set({ autoRender: e }), Y();
  }
  get ctx() {
    return this.$$.ctx[15];
  }
}
xt(NM, { colorManagementEnabled: { type: "Boolean" }, colorSpace: {}, dpr: {}, renderMode: {}, rendererParameters: {}, shadows: {}, size: {}, toneMapping: {}, useLegacyLights: {}, autoRender: { type: "Boolean" } }, ["default"], ["ctx"], !0);
const OM = () => Wn("threlte-internal-context");
function QM(s) {
  let e;
  const t = (
    /*#slots*/
    s[9].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, [r]) {
      n && n.p && (!e || r & /*$$scope*/
      256) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? gt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
const DA = "threlte-disposable-object-context";
function GM(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e;
  const { collectDisposableObjects: o, addDisposableObjects: c, removeDisposableObjects: l } = OM();
  let { object: u = void 0 } = e, h = u, { dispose: f = void 0 } = e;
  const d = Wn(DA);
  $e(s, d, (p) => t(7, i = p));
  const A = vt(f ?? i ?? !0);
  $e(s, A, (p) => t(6, n = p)), Jn(DA, A);
  let m = n ? o(u) : [];
  return c(m), Wt(() => {
    l(m);
  }), s.$$set = (p) => {
    "object" in p && t(2, u = p.object), "dispose" in p && t(3, f = p.dispose), "$$scope" in p && t(8, a = p.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*dispose, $parentDispose*/
    136 && A.set(f ?? i ?? !0), s.$$.dirty & /*object, previousObject, disposables, $mergedDispose*/
    116 && u !== h && (l(m), t(5, m = n ? o(u) : []), c(m), t(4, h = u));
  }, [
    d,
    A,
    u,
    f,
    h,
    m,
    n,
    i,
    a,
    r
  ];
}
class E_ extends St {
  constructor(e) {
    super(), Et(this, e, GM, QM, pt, { object: 2, dispose: 3 });
  }
  get object() {
    return this.$$.ctx[2];
  }
  set object(e) {
    this.$$set({ object: e }), Y();
  }
  get dispose() {
    return this.$$.ctx[3];
  }
  set dispose(e) {
    this.$$set({ dispose: e }), Y();
  }
}
xt(E_, { object: {}, dispose: {} }, ["default"], [], !0);
const x_ = (s, e) => {
  if (e.includes(".")) {
    const t = e.split("."), n = t.pop();
    for (let i = 0; i < t.length; i += 1)
      s = s[t[i]];
    return {
      target: s,
      key: n
    };
  } else
    return {
      target: s,
      key: e
    };
}, Ah = Symbol("initialValueBeforeAttach"), zM = () => {
  const { invalidate: s } = sn();
  let e = !1, t = Ah, n, i, r;
  const a = (c, l, u) => {
    if (o(), !u) {
      const h = c;
      ((h == null ? void 0 : h.isMaterial) || !1) && (u = "material"), ((h == null ? void 0 : h.isBufferGeometry) || (h == null ? void 0 : h.isGeometry) || !1) && (u = "geometry");
    }
    if (u) {
      if (typeof u == "function")
        n = u(l, c);
      else {
        const { target: h, key: f } = x_(l, u);
        t = h[f], h[f] = c, i = h, r = f;
      }
      e = !0, s();
    }
  }, o = () => {
    e && (n ? (n(), n = void 0) : i && r && t !== Ah && (i[r] = t, t = Ah, i = void 0, r = void 0), e = !1, s());
  };
  return Wt(() => {
    o();
  }), {
    update: a
  };
}, HM = (s) => s && s.isCamera, S_ = (s) => s && s.isOrthographicCamera, C_ = (s) => s && s.isPerspectiveCamera, VM = (s) => C_(s) || S_(s), WM = () => {
  const { invalidate: s, size: e, camera: t } = sn();
  let n, i;
  Wt(() => {
    i == null || i();
  });
  const r = (c) => {
    n && (S_(n) ? (n.left = c.width / -2, n.right = c.width / 2, n.top = c.height / 2, n.bottom = c.height / -2, n.updateProjectionMatrix(), n.updateMatrixWorld(), s()) : C_(n) && (n.aspect = c.width / c.height, n.updateProjectionMatrix(), n.updateMatrixWorld(), s()));
  };
  return {
    update: (c, l) => {
      if (i == null || i(), l || !VM(c)) {
        n = void 0;
        return;
      }
      n = c, i = e.subscribe(r);
    },
    makeDefaultCamera: (c, l) => {
      !HM(c) || !l || (t.set(c), s());
    }
  };
}, Ji = () => {
  const s = vi(), e = (n, i) => {
    const r = s.$$.callbacks[n];
    r && r.forEach((a) => {
      a(i);
    });
  };
  return Object.defineProperty(e, "hasEventListener", {
    value: (n) => !!s.$$.callbacks[n],
    enumerable: !0
  }), e;
}, qM = () => {
  const s = Ji(), e = [];
  let t, n = !1;
  const i = () => {
    e.forEach((o) => o()), e.length = 0, s("create", { ref: t, cleanup: (o) => {
      e.push(o);
    } });
  }, r = (a) => {
    t = a, n && i();
  };
  return Qr(() => {
    i(), n = !0;
  }), Wt(() => {
    e.forEach((a) => a());
  }), {
    updateRef: r
  };
}, LA = (s) => !!(s != null && s.addEventListener), XM = () => {
  const s = Ji(), e = vi(), t = (f) => {
    f != null && f.type && s(f.type, f);
  }, n = (f, d) => {
    LA(f) && d.forEach((A) => {
      f.removeEventListener(A, t);
    });
  }, i = (f, d) => {
    LA(f) && d.forEach((A) => {
      f.addEventListener(A, t);
    });
  };
  let r = [], a;
  const o = vt([]), c = o.subscribe((f) => {
    n(a, r), i(a, f), r = f;
  });
  Wt(c);
  const l = vt(), u = l.subscribe((f) => {
    n(a, r), i(f, r), a = f;
  });
  return Wt(u), Wt(() => {
    n(a, r);
  }), Qr(() => {
    o.set(Object.keys(e.$$.callbacks));
  }), {
    updateRef: (f) => {
      l.set(f);
    }
  };
}, YM = (s) => {
  const t = Wn("threlte-plugin-context");
  if (!t)
    return;
  const n = Object.values(t).map((l) => l(s)).filter(Boolean), i = n.flatMap((l) => l.pluginProps ?? []);
  let r = [];
  return Wt(() => {
    r.forEach((l) => l());
  }), {
    updateRef: (l) => {
      r.forEach((u) => u()), r = [], n.forEach((u) => {
        var f;
        const h = (f = u.onRefChange) == null ? void 0 : f.call(u, l);
        h && r.push(h);
      });
    },
    updateProps: (l) => {
      n.forEach((u) => {
        var h;
        (h = u.onPropsChange) == null || h.call(u, l);
      });
    },
    updateRestProps: (l) => {
      n.forEach((u) => {
        var h;
        (h = u.onRestPropsChange) == null || h.call(u, l);
      });
    },
    pluginsProps: i
  };
}, jM = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]), JM = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]), KM = (s) => typeof s == "string" || typeof s == "number" || typeof s == "boolean" || typeof s > "u" || s === null, PA = (s, e, t) => {
  var n, i, r;
  return !Array.isArray(t) && typeof t == "number" && typeof ((n = s[e]) == null ? void 0 : n.setScalar) == "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !((i = s[e]) != null && i.isColor) ? (a, o, c) => {
    a[o].setScalar(c);
  } : typeof ((r = s[e]) == null ? void 0 : r.set) == "function" ? Array.isArray(t) ? (a, o, c) => {
    a[o].set(...c);
  } : (a, o, c) => {
    a[o].set(c);
  } : (a, o, c) => {
    a[o] = c;
  };
}, ZM = () => {
  const { invalidate: s } = sn(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = (r, a, o, c) => {
    if (KM(o)) {
      const h = e.get(a);
      if (h && h.instance === r && h.value === o)
        return;
      e.set(a, {
        instance: r,
        value: o
      });
    }
    const { key: l, target: u } = x_(r, a);
    if (o != null) {
      const h = t.get(a);
      if (h)
        h(u, l, o);
      else {
        const f = PA(u, l, o);
        t.set(a, f), f(u, l, o);
      }
    } else
      PA(u, l, o)(u, l, o);
    c.manualCamera || JM.has(l) && (u.isPerspectiveCamera || u.isOrthographicCamera) && u.updateProjectionMatrix();
  };
  return {
    updateProps: (r, a, o) => {
      var c;
      for (const l in a)
        !jM.has(l) && !((c = o.pluginsProps) != null && c.includes(l)) && n(r, l, a[l], o), s();
    }
  };
}, $M = (s) => ({ ref: s & /*ref*/
2 }), UA = (s) => ({ ref: (
  /*ref*/
  s[1]
) }), eI = (s) => ({ ref: s & /*ref*/
2 }), FA = (s) => ({ ref: (
  /*ref*/
  s[1]
) });
function kA(s) {
  let e, t;
  return e = new E_({
    props: {
      object: (
        /*ref*/
        s[1]
      ),
      dispose: (
        /*dispose*/
        s[0]
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*ref*/
      2 && (r.object = /*ref*/
      n[1]), i & /*dispose*/
      1 && (r.dispose = /*dispose*/
      n[0]), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function tI(s) {
  let e;
  const t = (
    /*#slots*/
    s[12].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[13],
    UA
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      8194) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[13],
        e ? gt(
          t,
          /*$$scope*/
          i[13],
          r,
          $M
        ) : _t(
          /*$$scope*/
          i[13]
        ),
        UA
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function nI(s) {
  let e, t;
  return e = new Bd({
    props: {
      object: (
        /*ref*/
        s[1]
      ),
      $$slots: { default: [iI] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*ref*/
      2 && (r.object = /*ref*/
      n[1]), i & /*$$scope, ref*/
      8194 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function iI(s) {
  let e;
  const t = (
    /*#slots*/
    s[12].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[13],
    FA
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      8194) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[13],
        e ? gt(
          t,
          /*$$scope*/
          i[13],
          r,
          eI
        ) : _t(
          /*$$scope*/
          i[13]
        ),
        FA
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function rI(s) {
  let e = (
    /*isDisposableObject*/
    s[4](
      /*ref*/
      s[1]
    )
  ), t, n, i, r, a, o, c = e && kA(s);
  const l = [nI, tI], u = [];
  function h(f, d) {
    return d & /*ref*/
    2 && (n = null), n == null && (n = !!/*extendsObject3D*/
    f[3](
      /*ref*/
      f[1]
    )), n ? 0 : 1;
  }
  return i = h(s, -1), r = u[i] = l[i](s), {
    c() {
      c && c.c(), t = Pt(), r.c(), a = yi();
    },
    m(f, d) {
      c && c.m(f, d), st(f, t, d), u[i].m(f, d), st(f, a, d), o = !0;
    },
    p(f, [d]) {
      d & /*ref*/
      2 && (e = /*isDisposableObject*/
      f[4](
        /*ref*/
        f[1]
      )), e ? c ? (c.p(f, d), d & /*ref*/
      2 && ae(c, 1)) : (c = kA(f), c.c(), ae(c, 1), c.m(t.parentNode, t)) : c && (ai(), ue(c, 1, 1, () => {
        c = null;
      }), oi());
      let A = i;
      i = h(f, d), i === A ? u[i].p(f, d) : (ai(), ue(u[A], 1, 1, () => {
        u[A] = null;
      }), oi(), r = u[i], r ? r.p(f, d) : (r = u[i] = l[i](f), r.c()), ae(r, 1), r.m(a.parentNode, a));
    },
    i(f) {
      o || (ae(c), ae(r), o = !0);
    },
    o(f) {
      ue(c), ue(r), o = !1;
    },
    d(f) {
      f && (rt(t), rt(a)), c && c.d(f), u[i].d(f);
    }
  };
}
function sI(s, e, t) {
  const n = ["is", "args", "attach", "manual", "makeDefault", "dispose", "ref"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { is: c } = e, { args: l = void 0 } = e, { attach: u = void 0 } = e, { manual: h = void 0 } = e, { makeDefault: f = void 0 } = e, { dispose: d = void 0 } = e;
  const A = Wn("threlte-hierarchical-parent-context");
  $e(s, A, (R) => t(11, r = R));
  const m = (R) => typeof R == "function" && /^\s*class\s+/.test(R.toString()), p = (R) => Array.isArray(R), g = qM();
  let _ = m(c) && p(l) ? new c(...l) : m(
    c
  ) ? new c() : c;
  g.updateRef(_);
  let b = !1;
  const y = () => {
    if (!b) {
      b = !0;
      return;
    }
    t(1, _ = m(c) && p(l) ? new c(...l) : m(
      c
    ) ? new c() : c), g.updateRef(_);
  };
  let { ref: v = _ } = e;
  const x = vt(_);
  Jn("threlte-hierarchical-parent-context", x);
  const S = YM({ ref: _, props: e }), I = (S == null ? void 0 : S.pluginsProps) ?? [], E = ZM(), M = WM(), T = zM(), D = XM(), F = (R) => !!R.isObject3D, C = (R) => R.dispose !== void 0;
  return s.$$set = (R) => {
    t(27, e = Ve(Ve({}, e), Kt(R))), t(26, i = at(e, n)), "is" in R && t(6, c = R.is), "args" in R && t(7, l = R.args), "attach" in R && t(8, u = R.attach), "manual" in R && t(9, h = R.manual), "makeDefault" in R && t(10, f = R.makeDefault), "dispose" in R && t(0, d = R.dispose), "ref" in R && t(5, v = R.ref), "$$scope" in R && t(13, o = R.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*is, args*/
    192 && y(), s.$$.dirty & /*ref*/
    2 && t(5, v = _), s.$$.dirty & /*ref*/
    2 && x.set(_), E.updateProps(_, i, { manualCamera: h, pluginsProps: I }), s.$$.dirty & /*ref, manual*/
    514 && M.update(_, h), s.$$.dirty & /*ref, makeDefault*/
    1026 && M.makeDefaultCamera(_, f), s.$$.dirty & /*ref, $parent, attach*/
    2306 && T.update(_, r, u), s.$$.dirty & /*ref*/
    2 && D.updateRef(_), s.$$.dirty & /*ref*/
    2 && (S == null || S.updateRef(_)), S == null || S.updateProps(e), S == null || S.updateRestProps(i);
  }, e = Kt(e), [
    d,
    _,
    A,
    F,
    C,
    v,
    c,
    l,
    u,
    h,
    f,
    r,
    a,
    o
  ];
}
let Rd = class extends St {
  constructor(e) {
    super(), Et(this, e, sI, rI, pt, {
      is: 6,
      args: 7,
      attach: 8,
      manual: 9,
      makeDefault: 10,
      dispose: 0,
      ref: 5
    });
  }
  get is() {
    return this.$$.ctx[6];
  }
  set is(e) {
    this.$$set({ is: e }), Y();
  }
  get args() {
    return this.$$.ctx[7];
  }
  set args(e) {
    this.$$set({ args: e }), Y();
  }
  get attach() {
    return this.$$.ctx[8];
  }
  set attach(e) {
    this.$$set({ attach: e }), Y();
  }
  get manual() {
    return this.$$.ctx[9];
  }
  set manual(e) {
    this.$$set({ manual: e }), Y();
  }
  get makeDefault() {
    return this.$$.ctx[10];
  }
  set makeDefault(e) {
    this.$$set({ makeDefault: e }), Y();
  }
  get dispose() {
    return this.$$.ctx[0];
  }
  set dispose(e) {
    this.$$set({ dispose: e }), Y();
  }
  get ref() {
    return this.$$.ctx[5];
  }
  set ref(e) {
    this.$$set({ ref: e }), Y();
  }
};
xt(Rd, { is: {}, args: {}, attach: {}, manual: {}, makeDefault: {}, dispose: {}, ref: {} }, ["default"], [], !0);
const aI = {}, oI = (s, e) => {
  const t = aI[e] || dM[e];
  if (!t)
    throw new Error(`No Three.js module found for ${e}. Did you forget to extend the catalogue?`);
  return {
    ...s,
    props: {
      ...s.props,
      is: t
    }
  };
}, cI = (s) => new Proxy(class {
}, {
  construct(e, [t]) {
    const n = t;
    return new Rd(oI(n, s));
  }
}), qe = new Proxy(class {
}, {
  construct(s, [e]) {
    const t = e;
    return new Rd(t);
  },
  get(s, e) {
    return cI(e);
  }
});
function Dd(s, e) {
  const t = "threlte-plugin-context";
  if (Array.isArray(s)) {
    const [n, i] = s;
    Jn(t, {
      ...Wn(t),
      [n]: i
    });
  } else {
    const n = s, i = e;
    if (!i)
      return;
    Jn(t, {
      ...Wn(t),
      [n]: i
    });
  }
}
function bi(s, e, t) {
  if (!Td)
    return {
      task: void 0,
      start: () => {
      },
      stop: () => {
      },
      started: wd(!1)
    };
  let n, i, r;
  wr.isKey(s) ? (n = s, i = e, r = t) : (n = Symbol("useTask"), i = s, r = e);
  const a = sn();
  let o = a.mainStage;
  if (r) {
    if (r.stage)
      if (wr.isValue(r.stage))
        o = r.stage;
      else {
        const d = a.scheduler.getStage(r.stage);
        if (!d)
          throw new Error(`No stage found with key ${r.stage.toString()}`);
        o = d;
      }
    else if (r.after)
      if (Array.isArray(r.after))
        for (let d = 0; d < r.after.length; d++) {
          const A = r.after[d];
          if (wr.isValue(A)) {
            o = A.stage;
            break;
          }
        }
      else
        wr.isValue(r.after) && (o = r.after.stage);
    else if (r.before)
      if (Array.isArray(r.before))
        for (let d = 0; d < r.before.length; d++) {
          const A = r.before[d];
          if (wr.isValue(A)) {
            o = A.stage;
            break;
          }
        }
      else
        wr.isValue(r.before) && (o = r.before.stage);
  }
  const { autoInvalidations: c } = Wn("threlte-internal-context"), l = vt(!1), u = o.createTask(n, i, r), h = () => {
    l.set(!0), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && c.add(i), u.start();
  }, f = () => {
    l.set(!0), ((r == null ? void 0 : r.autoInvalidate) ?? !0) && c.delete(i), u.stop();
  };
  return (t == null ? void 0 : t.autoStart) ?? !0 ? h() : f(), Wt(() => {
    o && o.removeTask(n);
  }), {
    task: u,
    start: h,
    stop: f,
    started: {
      subscribe: l.subscribe
    }
  };
}
function Ld(s, e, t) {
  const n = Wn("threlte-user-context");
  if (!n)
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  return s ? s && !e ? Vn(n, (i) => i[s]) : (n.update((i) => {
    if (s in i) {
      if (!t || t.existing === "skip")
        return i;
      if (t.existing === "merge")
        return Object.assign(i[s], e), i;
    }
    return i[s] = e, i;
  }), n.current[s]) : {
    subscribe: n.subscribe
  };
}
const pl = (s) => {
  const e = vt(void 0), t = vt(void 0);
  return s.then((n) => {
    e.set(n);
  }).catch((n) => {
    console.error("Error in asyncWritable:", n.message), t.set(n);
  }), Object.assign(Object.assign(s, e), { error: t, promise: s });
}, pu = (s, e = {}) => {
  var o;
  const { remember: t, clear: n } = y_(), i = new s();
  return (o = e.extend) == null || o.call(e, i), {
    load: (c, l) => {
      const u = async (h) => {
        var f;
        if ("loadAsync" in i) {
          const d = await i.loadAsync(h, l == null ? void 0 : l.onProgress);
          return ((f = l == null ? void 0 : l.transform) == null ? void 0 : f.call(l, d)) ?? d;
        } else
          return new Promise((d, A) => {
            i.load(h, (m) => {
              var p;
              return d(((p = l == null ? void 0 : l.transform) == null ? void 0 : p.call(l, m)) ?? m);
            }, (m) => {
              var p;
              return (p = l == null ? void 0 : l.onProgress) == null ? void 0 : p.call(l, m);
            }, A);
          });
      };
      if (Array.isArray(c)) {
        const h = c.map((d) => t(() => u(d), [s, d]));
        return pl(Promise.all(h));
      } else if (typeof c == "string") {
        const h = t(() => u(c), [s, c]);
        return pl(h);
      } else {
        const h = Object.values(c).map((d) => t(() => u(d), [s, d]));
        return pl(Promise.all(h).then((d) => Object.fromEntries(Object.entries(c).map(([A], m) => [A, d[m]]))));
      }
    },
    clear: (c) => {
      Array.isArray(c) ? c.forEach((l) => {
        n([s, l]);
      }) : typeof c == "string" ? n([s, c]) : Object.entries(c).forEach(([l, u]) => {
        n([s, l, u]);
      });
    },
    loader: i
  };
}, An = () => {
  const s = vi(), e = vt(void 0);
  return Ft(e, (t) => {
    t && Object.entries(s.$$.callbacks).forEach((n) => {
      const [i, r] = n;
      i in t.$$.callbacks && Array.isArray(t.$$.callbacks[i]) ? t.$$.callbacks[i].push(...r) : t.$$.callbacks[i] = r;
    });
  }), e;
};
var lI = function() {
  var s = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), n = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var i = WebAssembly.validate(t) ? e : s, r, a = WebAssembly.instantiate(o(i), {}).then(function(g) {
    r = g.instance, r.exports.__wasm_call_ctors();
  });
  function o(g) {
    for (var _ = new Uint8Array(g.length), b = 0; b < g.length; ++b) {
      var y = g.charCodeAt(b);
      _[b] = y > 96 ? y - 97 : y > 64 ? y - 39 : y + 4;
    }
    for (var v = 0, b = 0; b < g.length; ++b)
      _[v++] = _[b] < 60 ? n[_[b]] : (_[b] - 60) * 64 + _[++b];
    return _.buffer.slice(0, v);
  }
  function c(g, _, b, y, v, x) {
    var S = r.exports.sbrk, I = b + 3 & -4, E = S(I * y), M = S(v.length), T = new Uint8Array(r.exports.memory.buffer);
    T.set(v, M);
    var D = g(E, b, y, M, v.length);
    if (D == 0 && x && x(E, I, y), _.set(T.subarray(E, E + b * y)), S(E - S(0)), D != 0)
      throw new Error("Malformed buffer data: " + D);
  }
  var l = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, u = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, h = [], f = 0;
  function d(g) {
    var _ = {
      object: new Worker(g),
      pending: 0,
      requests: {}
    };
    return _.object.onmessage = function(b) {
      var y = b.data;
      _.pending -= y.count, _.requests[y.id][y.action](y.value), delete _.requests[y.id];
    }, _;
  }
  function A(g) {
    for (var _ = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + c.toString() + p.toString(), b = new Blob([_], { type: "text/javascript" }), y = URL.createObjectURL(b), v = 0; v < g; ++v)
      h[v] = d(y);
    URL.revokeObjectURL(y);
  }
  function m(g, _, b, y, v) {
    for (var x = h[0], S = 1; S < h.length; ++S)
      h[S].pending < x.pending && (x = h[S]);
    return new Promise(function(I, E) {
      var M = new Uint8Array(b), T = f++;
      x.pending += g, x.requests[T] = { resolve: I, reject: E }, x.object.postMessage({ id: T, count: g, size: _, source: M, mode: y, filter: v }, [M.buffer]);
    });
  }
  function p(g) {
    a.then(function() {
      var _ = g.data;
      try {
        var b = new Uint8Array(_.count * _.size);
        c(r.exports[_.mode], b, _.count, _.size, _.source, r.exports[_.filter]), self.postMessage({ id: _.id, count: _.count, action: "resolve", value: b }, [b.buffer]);
      } catch (y) {
        self.postMessage({ id: _.id, count: _.count, action: "reject", value: y });
      }
    });
  }
  return {
    ready: a,
    supported: !0,
    useWorkers: function(g) {
      A(g);
    },
    decodeVertexBuffer: function(g, _, b, y, v) {
      c(r.exports.meshopt_decodeVertexBuffer, g, _, b, y, r.exports[l[v]]);
    },
    decodeIndexBuffer: function(g, _, b, y) {
      c(r.exports.meshopt_decodeIndexBuffer, g, _, b, y);
    },
    decodeIndexSequence: function(g, _, b, y) {
      c(r.exports.meshopt_decodeIndexSequence, g, _, b, y);
    },
    decodeGltfBuffer: function(g, _, b, y, v, x) {
      c(r.exports[u[v]], g, _, b, y, r.exports[l[x]]);
    },
    decodeGltfBufferAsync: function(g, _, b, y, v) {
      return h.length > 0 ? m(g, _, b, u[y], l[v]) : a.then(function() {
        var x = new Uint8Array(g * _);
        return c(r.exports[u[y]], x, g, _, b, r.exports[l[v]]), x;
      });
    }
  };
}();
const gh = /* @__PURE__ */ new WeakMap();
class uI extends Tn {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, i) {
    const r = new wn(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      this.parse(a, t, i);
    }, n, i);
  }
  parse(e, t, n) {
    this.decodeDracoFile(e, t, null, null, Ot).catch(n);
  }
  decodeDracoFile(e, t, n, i, r = rn) {
    const a = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: r
    };
    return this.decodeGeometry(e, a).then(t);
  }
  decodeGeometry(e, t) {
    const n = JSON.stringify(t);
    if (gh.has(e)) {
      const c = gh.get(e);
      if (c.key === n)
        return c.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(r, a).then((c) => (i = c, new Promise((l, u) => {
      i._callbacks[r] = { resolve: l, reject: u }, i.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((c) => this._createGeometry(c.geometry));
    return o.catch(() => !0).then(() => {
      i && r && this._releaseTask(i, r);
    }), gh.set(e, {
      key: n,
      promise: o
    }), o;
  }
  _createGeometry(e) {
    const t = new ot();
    e.index && t.setIndex(new ut(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n], r = i.name, a = i.array, o = i.itemSize, c = new ut(a, o);
      r === "color" && (this._assignVertexColorSpace(c, i.vertexColorSpace), c.normalized = !(a instanceof Float32Array)), t.setAttribute(r, c);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== Ot)
      return;
    const n = new Pe();
    for (let i = 0, r = e.count; i < r; i++)
      n.fromBufferAttribute(e, i).convertSRGBToLinear(), e.setXYZ(i, n.r, n.g, n.b);
  }
  _loadLibrary(e, t) {
    const n = new wn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, r) => {
      n.load(e, i, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const i = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const r = hI.toString(), a = [
        "/* draco decoder */",
        i,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([a]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function(r) {
          const a = r.data;
          switch (a.type) {
            case "decode":
              i._callbacks[a.id].resolve(a);
              break;
            case "error":
              i._callbacks[a.id].reject(a);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
          }
        }, this.workerPool.push(i);
      } else
        this.workerPool.sort(function(i, r) {
          return i._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function hI() {
  let s, e;
  onmessage = function(a) {
    const o = a.data;
    switch (o.type) {
      case "init":
        s = o.decoderConfig, e = new Promise(function(u) {
          s.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(s);
        });
        break;
      case "decode":
        const c = o.buffer, l = o.taskConfig;
        e.then((u) => {
          const h = u.draco, f = new h.Decoder();
          try {
            const d = t(h, f, new Int8Array(c), l), A = d.attributes.map((m) => m.array.buffer);
            d.index && A.push(d.index.array.buffer), self.postMessage({ type: "decode", id: o.id, geometry: d }, A);
          } catch (d) {
            console.error(d), self.postMessage({ type: "error", id: o.id, error: d.message });
          } finally {
            h.destroy(f);
          }
        });
        break;
    }
  };
  function t(a, o, c, l) {
    const u = l.attributeIDs, h = l.attributeTypes;
    let f, d;
    const A = o.GetEncodedGeometryType(c);
    if (A === a.TRIANGULAR_MESH)
      f = new a.Mesh(), d = o.DecodeArrayToMesh(c, c.byteLength, f);
    else if (A === a.POINT_CLOUD)
      f = new a.PointCloud(), d = o.DecodeArrayToPointCloud(c, c.byteLength, f);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!d.ok() || f.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
    const m = { index: null, attributes: [] };
    for (const p in u) {
      const g = self[h[p]];
      let _, b;
      if (l.useUniqueIDs)
        b = u[p], _ = o.GetAttributeByUniqueId(f, b);
      else {
        if (b = o.GetAttributeId(f, a[u[p]]), b === -1)
          continue;
        _ = o.GetAttribute(f, b);
      }
      const y = i(a, o, f, p, g, _);
      p === "color" && (y.vertexColorSpace = l.vertexColorSpace), m.attributes.push(y);
    }
    return A === a.TRIANGULAR_MESH && (m.index = n(a, o, f)), a.destroy(f), m;
  }
  function n(a, o, c) {
    const u = c.num_faces() * 3, h = u * 4, f = a._malloc(h);
    o.GetTrianglesUInt32Array(c, h, f);
    const d = new Uint32Array(a.HEAPF32.buffer, f, u).slice();
    return a._free(f), { array: d, itemSize: 1 };
  }
  function i(a, o, c, l, u, h) {
    const f = h.num_components(), A = c.num_points() * f, m = A * u.BYTES_PER_ELEMENT, p = r(a, u), g = a._malloc(m);
    o.GetAttributeDataArrayForAllPoints(c, h, p, m, g);
    const _ = new u(a.HEAPF32.buffer, g, A).slice();
    return a._free(g), {
      name: l,
      array: _,
      itemSize: f
    };
  }
  function r(a, o) {
    switch (o) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
function NA(s, e) {
  if (e === t0)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === wl || e === jf) {
    let t = s.getIndex();
    if (t === null) {
      const a = [], o = s.getAttribute("position");
      if (o !== void 0) {
        for (let c = 0; c < o.count; c++)
          a.push(c);
        s.setIndex(a), t = s.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
    }
    const n = t.count - 2, i = [];
    if (e === wl)
      for (let a = 1; a <= n; a++)
        i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0 ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2))) : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
class fI extends Tn {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new mI(t);
    }), this.register(function(t) {
      return new MI(t);
    }), this.register(function(t) {
      return new II(t);
    }), this.register(function(t) {
      return new wI(t);
    }), this.register(function(t) {
      return new bI(t);
    }), this.register(function(t) {
      return new yI(t);
    }), this.register(function(t) {
      return new vI(t);
    }), this.register(function(t) {
      return new EI(t);
    }), this.register(function(t) {
      return new gI(t);
    }), this.register(function(t) {
      return new xI(t);
    }), this.register(function(t) {
      return new _I(t);
    }), this.register(function(t) {
      return new CI(t);
    }), this.register(function(t) {
      return new SI(t);
    }), this.register(function(t) {
      return new pI(t);
    }), this.register(function(t) {
      return new TI(t);
    }), this.register(function(t) {
      return new BI(t);
    });
  }
  load(e, t, n, i) {
    const r = this;
    let a;
    if (this.resourcePath !== "")
      a = this.resourcePath;
    else if (this.path !== "") {
      const l = Ur.extractUrlBase(e);
      a = Ur.resolveURL(l, this.path);
    } else
      a = Ur.extractUrlBase(e);
    this.manager.itemStart(e);
    const o = function(l) {
      i ? i(l) : console.error(l), r.manager.itemError(e), r.manager.itemEnd(e);
    }, c = new wn(this.manager);
    c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(l) {
      try {
        r.parse(l, a, function(u) {
          t(u), r.manager.itemEnd(e);
        }, o);
      } catch (u) {
        o(u);
      }
    }, n, o);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, i) {
    let r;
    const a = {}, o = {}, c = new TextDecoder();
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (c.decode(new Uint8Array(e, 0, 4)) === M_) {
        try {
          a[Ct.KHR_BINARY_GLTF] = new RI(e);
        } catch (h) {
          i && i(h);
          return;
        }
        r = JSON.parse(a[Ct.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(c.decode(e));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new VI(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[h.name] = h, a[h.name] = !0;
    }
    if (r.extensionsUsed)
      for (let u = 0; u < r.extensionsUsed.length; ++u) {
        const h = r.extensionsUsed[u], f = r.extensionsRequired || [];
        switch (h) {
          case Ct.KHR_MATERIALS_UNLIT:
            a[h] = new AI();
            break;
          case Ct.KHR_DRACO_MESH_COMPRESSION:
            a[h] = new DI(r, this.dracoLoader);
            break;
          case Ct.KHR_TEXTURE_TRANSFORM:
            a[h] = new LI();
            break;
          case Ct.KHR_MESH_QUANTIZATION:
            a[h] = new PI();
            break;
          default:
            f.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(a), l.setPlugins(o), l.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function dI() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const Ct = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class pI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let i = t.cache.get(n);
    if (i)
      return i;
    const r = t.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let l;
    const u = new Pe(16777215);
    c.color !== void 0 && u.setRGB(c.color[0], c.color[1], c.color[2], rn);
    const h = c.range !== void 0 ? c.range : 0;
    switch (c.type) {
      case "directional":
        l = new fu(u), l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      case "point":
        l = new vd(u), l.distance = h;
        break;
      case "spot":
        l = new yd(u), l.distance = h, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
    }
    return l.position.set(0, 0, 0), l.decay = 2, Tr(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = t.createUniqueName(c.name || "light_" + e), i = Promise.resolve(l), t.cache.add(n, i), i;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
    return o === void 0 ? null : this._loadLight(o).then(function(c) {
      return n._getNodeRef(t.cache, o, c);
    });
  }
}
class AI {
  constructor() {
    this.name = Ct.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return In;
  }
  extendParams(e, t, n) {
    const i = [];
    e.color = new Pe(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const a = r.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], rn), e.opacity = a[3];
      }
      r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, Ot));
    }
    return Promise.all(i);
  }
}
class gI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class mI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new xe(o, o);
    }
    return Promise.all(r);
  }
}
class _I {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
  }
}
class bI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new Pe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const a = i.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const o = a.sheenColorFactor;
      t.sheenColor.setRGB(o[0], o[1], o[2], rn);
    }
    return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ot)), a.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
  }
}
class yI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
  }
}
class vI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
    const o = a.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Pe().setRGB(o[0], o[1], o[2], rn), Promise.all(r);
  }
}
class EI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class xI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Pe().setRGB(o[0], o[1], o[2], rn), a.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Ot)), Promise.all(r);
  }
}
class SI {
  constructor(e) {
    this.parser = e, this.name = Ct.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
  }
}
class CI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ui;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], a = i.extensions[this.name];
    return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
  }
}
class MI {
  constructor(e) {
    this.parser = e, this.name = Ct.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name])
      return null;
    const r = i.extensions[this.name], a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, a);
  }
}
class II {
  constructor(e) {
    this.parser = e, this.name = Ct.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = i.images[a.source];
    let c = n.textureLoader;
    if (o.uri) {
      const l = n.options.manager.getHandler(o.uri);
      l !== null && (c = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return n.loadTextureImage(e, a.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class wI {
  constructor(e) {
    this.parser = e, this.name = Ct.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const a = r.extensions[t], o = i.images[a.source];
    let c = n.textureLoader;
    if (o.uri) {
      const l = n.options.manager.getHandler(o.uri);
      l !== null && (c = l);
    }
    return this.detectSupport().then(function(l) {
      if (l)
        return n.loadTextureImage(e, a.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class TI {
  constructor(e) {
    this.name = Ct.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name], r = this.parser.getDependency("buffer", i.buffer), a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(o) {
        const c = i.byteOffset || 0, l = i.byteLength || 0, u = i.count, h = i.byteStride, f = new Uint8Array(o, c, l);
        return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(u, h, f, i.mode, i.filter).then(function(d) {
          return d.buffer;
        }) : a.ready.then(function() {
          const d = new ArrayBuffer(u * h);
          return a.decodeGltfBuffer(new Uint8Array(d), u, h, f, i.mode, i.filter), d;
        });
      });
    } else
      return null;
  }
}
class BI {
  constructor(e) {
    this.name = Ct.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const l of i.primitives)
      if (l.mode !== gi.TRIANGLES && l.mode !== gi.TRIANGLE_STRIP && l.mode !== gi.TRIANGLE_FAN && l.mode !== void 0)
        return null;
    const a = n.extensions[this.name].attributes, o = [], c = {};
    for (const l in a)
      o.push(this.parser.getDependency("accessor", a[l]).then((u) => (c[l] = u, c[l])));
    return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((l) => {
      const u = l.pop(), h = u.isGroup ? u.children : [u], f = l[0].count, d = [];
      for (const A of h) {
        const m = new Je(), p = new P(), g = new Rt(), _ = new P(1, 1, 1), b = new $l(A.geometry, A.material, f);
        for (let y = 0; y < f; y++)
          c.TRANSLATION && p.fromBufferAttribute(c.TRANSLATION, y), c.ROTATION && g.fromBufferAttribute(c.ROTATION, y), c.SCALE && _.fromBufferAttribute(c.SCALE, y), b.setMatrixAt(y, m.compose(p, g, _));
        for (const y in c)
          if (y === "_COLOR_0") {
            const v = c[y];
            b.instanceColor = new Nr(v.array, v.itemSize, v.normalized);
          } else
            y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && A.geometry.setAttribute(y, c[y]);
        bt.prototype.copy.call(b, A), this.parser.assignFinalMaterial(b), d.push(b);
      }
      return u.isGroup ? (u.clear(), u.add(...d), u) : d[0];
    }));
  }
}
const M_ = "glTF", to = 12, OA = { JSON: 1313821514, BIN: 5130562 };
class RI {
  constructor(e) {
    this.name = Ct.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, to), n = new TextDecoder();
    if (this.header = {
      magic: n.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== M_)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - to, r = new DataView(e, to);
    let a = 0;
    for (; a < i; ) {
      const o = r.getUint32(a, !0);
      a += 4;
      const c = r.getUint32(a, !0);
      if (a += 4, c === OA.JSON) {
        const l = new Uint8Array(e, to + a, o);
        this.content = n.decode(l);
      } else if (c === OA.BIN) {
        const l = to + a;
        this.body = e.slice(l, l + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class DI {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ct.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, c = {}, l = {};
    for (const u in a) {
      const h = Df[u] || u.toLowerCase();
      o[h] = a[u];
    }
    for (const u in e.attributes) {
      const h = Df[u] || u.toLowerCase();
      if (a[u] !== void 0) {
        const f = n.accessors[e.attributes[u]], d = ma[f.componentType];
        l[h] = d.name, c[h] = f.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(u) {
      return new Promise(function(h) {
        i.decodeDracoFile(u, function(f) {
          for (const d in f.attributes) {
            const A = f.attributes[d], m = c[d];
            m !== void 0 && (A.normalized = m);
          }
          h(f);
        }, o, l);
      });
    });
  }
}
class LI {
  constructor() {
    this.name = Ct.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class PI {
  constructor() {
    this.name = Ct.KHR_MESH_QUANTIZATION;
  }
}
class I_ extends La {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
    for (let a = 0; a !== i; a++)
      t[a] = n[r + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, u = i - t, h = (n - t) / u, f = h * h, d = f * h, A = e * l, m = A - l, p = -2 * d + 3 * f, g = d - f, _ = 1 - p, b = g - f + h;
    for (let y = 0; y !== o; y++) {
      const v = a[m + y + o], x = a[m + y + c] * u, S = a[A + y + o], I = a[A + y] * u;
      r[y] = _ * v + b * x + p * S + g * I;
    }
    return r;
  }
}
const UI = new Rt();
class FI extends I_ {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return UI.fromArray(r).normalize().toArray(r), r;
  }
}
const gi = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, ma = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, QA = {
  9728: tn,
  9729: wt,
  9984: Io,
  9985: Fl,
  9986: Aa,
  9987: _i
}, GA = {
  33071: Ln,
  33648: ba,
  10497: Ar
}, mh = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Df = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, Mr = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, kI = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Ss,
  STEP: ya
}, _h = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function NI(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Ko({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: mi
  })), s.DefaultMaterial;
}
function is(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function Tr(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function OI(s, e, t) {
  let n = !1, i = !1, r = !1;
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (h.POSITION !== void 0 && (n = !0), h.NORMAL !== void 0 && (i = !0), h.COLOR_0 !== void 0 && (r = !0), n && i && r)
      break;
  }
  if (!n && !i && !r)
    return Promise.resolve(s);
  const a = [], o = [], c = [];
  for (let l = 0, u = e.length; l < u; l++) {
    const h = e[l];
    if (n) {
      const f = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : s.attributes.position;
      a.push(f);
    }
    if (i) {
      const f = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : s.attributes.normal;
      o.push(f);
    }
    if (r) {
      const f = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : s.attributes.color;
      c.push(f);
    }
  }
  return Promise.all([
    Promise.all(a),
    Promise.all(o),
    Promise.all(c)
  ]).then(function(l) {
    const u = l[0], h = l[1], f = l[2];
    return n && (s.morphAttributes.position = u), i && (s.morphAttributes.normal = h), r && (s.morphAttributes.color = f), s.morphTargetsRelative = !0, s;
  });
}
function QI(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function GI(s) {
  let e;
  const t = s.extensions && s.extensions[Ct.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + bh(t.attributes) : e = s.indices + ":" + bh(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + bh(s.targets[n]);
  return e;
}
function bh(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++)
    e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function Lf(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function zI(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const HI = new Je();
class VI {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new dI(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, i = !1, r = -1;
    typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && r < 98 ? this.textureLoader = new Qo(this.options.manager) : this.textureLoader = new u_(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new wn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, i = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
      return a._markDefs && a._markDefs();
    }), Promise.all(this._invokeAll(function(a) {
      return a.beforeRoot && a.beforeRoot();
    })).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(a) {
      const o = {
        scene: a[0][i.scene || 0],
        scenes: a[0],
        animations: a[1],
        cameras: a[2],
        asset: i.asset,
        parser: n,
        userData: {}
      };
      return is(r, o, i), Tr(o, i), Promise.all(n._invokeAll(function(c) {
        return c.afterRoot && c.afterRoot(o);
      })).then(function() {
        e(o);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const a = t[i].joints;
      for (let o = 0, c = a.length; o < c; o++)
        e[a[o]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const a = e[i];
      a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const i = n.clone(), r = (a, o) => {
      const c = this.associations.get(a);
      c != null && this.associations.set(o, c);
      for (const [l, u] of a.children.entries())
        r(u, o.children[l]);
    };
    return r(n, i), i.name += "_instance_" + e.uses[t]++, i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i)
        return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (i = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !i)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(i.map(function(r, a) {
        return n.getDependency(e, a);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ct.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function(r, a) {
      n.load(Ur.resolveURL(t.uri, i.path), r, void 0, function() {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const i = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = mh[i.type], o = ma[i.componentType], c = i.normalized === !0, l = new o(i.count * a);
      return Promise.resolve(new ut(l, a, c));
    }
    const r = [];
    return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(a) {
      const o = a[0], c = mh[i.type], l = ma[i.componentType], u = l.BYTES_PER_ELEMENT, h = u * c, f = i.byteOffset || 0, d = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, A = i.normalized === !0;
      let m, p;
      if (d && d !== h) {
        const g = Math.floor(f / d), _ = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + g + ":" + i.count;
        let b = t.cache.get(_);
        b || (m = new l(o, g * d, i.count * d / u), b = new qo(m, d / u), t.cache.add(_, b)), p = new kr(b, c, f % d / u, A);
      } else
        o === null ? m = new l(i.count * c) : m = new l(o, f, i.count * c), p = new ut(m, c, A);
      if (i.sparse !== void 0) {
        const g = mh.SCALAR, _ = ma[i.sparse.indices.componentType], b = i.sparse.indices.byteOffset || 0, y = i.sparse.values.byteOffset || 0, v = new _(a[1], b, i.sparse.count * g), x = new l(a[2], y, i.sparse.count * c);
        o !== null && (p = new ut(p.array.slice(), p.itemSize, p.normalized));
        for (let S = 0, I = v.length; S < I; S++) {
          const E = v[S];
          if (p.setX(E, x[S * c]), c >= 2 && p.setY(E, x[S * c + 1]), c >= 3 && p.setZ(E, x[S * c + 2]), c >= 4 && p.setW(E, x[S * c + 3]), c >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, a = t.images[r];
    let o = this.textureLoader;
    if (a.uri) {
      const c = n.manager.getHandler(a.uri);
      c !== null && (o = c);
    }
    return this.loadTextureImage(e, r, o);
  }
  loadTextureImage(e, t, n) {
    const i = this, r = this.json, a = r.textures[e], o = r.images[t], c = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[c])
      return this.textureCache[c];
    const l = this.loadImageSource(t, n).then(function(u) {
      u.flipY = !1, u.name = a.name || o.name || "", u.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (u.name = o.uri);
      const f = (r.samplers || {})[a.sampler] || {};
      return u.magFilter = QA[f.magFilter] || wt, u.minFilter = QA[f.minFilter] || _i, u.wrapS = GA[f.wrapS] || Ar, u.wrapT = GA[f.wrapT] || Ar, i.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[c] = l, l;
  }
  loadImageSource(e, t) {
    const n = this, i = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const a = i.images[e], o = self.URL || self.webkitURL;
    let c = a.uri || "", l = !1;
    if (a.bufferView !== void 0)
      c = n.getDependency("bufferView", a.bufferView).then(function(h) {
        l = !0;
        const f = new Blob([h], { type: a.mimeType });
        return c = o.createObjectURL(f), c;
      });
    else if (a.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(c).then(function(h) {
      return new Promise(function(f, d) {
        let A = f;
        t.isImageBitmapLoader === !0 && (A = function(m) {
          const p = new Jt(m);
          p.needsUpdate = !0, f(p);
        }), t.load(Ur.resolveURL(h, r.path), A, void 0, d);
      });
    }).then(function(h) {
      return l === !0 && o.revokeObjectURL(c), h.userData.mimeType = a.mimeType || zI(a.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", c), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(a) {
      if (!a)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (a = a.clone(), a.channel = n.texCoord), r.extensions[Ct.KHR_TEXTURE_TRANSFORM]) {
        const o = n.extensions !== void 0 ? n.extensions[Ct.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o) {
          const c = r.associations.get(a);
          a = r.extensions[Ct.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, c);
        }
      }
      return i !== void 0 && (a.colorSpace = i), e[t] = a, a;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let c = this.cache.get(o);
      c || (c = new eu(), vn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = !1, this.cache.add(o, c)), n = c;
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let c = this.cache.get(o);
      c || (c = new kn(), vn.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(o, c)), n = c;
    }
    if (i || r || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      i && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
      let c = this.cache.get(o);
      c || (c = n.clone(), r && (c.vertexColors = !0), a && (c.flatShading = !0), i && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(n))), n = c;
    }
    e.material = n;
  }
  getMaterialType() {
    return Ko;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, i = this.extensions, r = n.materials[e];
    let a;
    const o = {}, c = r.extensions || {}, l = [];
    if (c[Ct.KHR_MATERIALS_UNLIT]) {
      const h = i[Ct.KHR_MATERIALS_UNLIT];
      a = h.getMaterialType(), l.push(h.extendParams(o, r, t));
    } else {
      const h = r.pbrMetallicRoughness || {};
      if (o.color = new Pe(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const f = h.baseColorFactor;
        o.color.setRGB(f[0], f[1], f[2], rn), o.opacity = f[3];
      }
      h.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", h.baseColorTexture, Ot)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(f) {
        return f.getMaterialType && f.getMaterialType(e);
      }), l.push(Promise.all(this._invokeAll(function(f) {
        return f.extendMaterialParams && f.extendMaterialParams(e, o);
      })));
    }
    r.doubleSided === !0 && (o.side = Mn);
    const u = r.alphaMode || _h.OPAQUE;
    if (u === _h.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, u === _h.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== In && (l.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new xe(1, 1), r.normalTexture.scale !== void 0)) {
      const h = r.normalTexture.scale;
      o.normalScale.set(h, h);
    }
    if (r.occlusionTexture !== void 0 && a !== In && (l.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== In) {
      const h = r.emissiveFactor;
      o.emissive = new Pe().setRGB(h[0], h[1], h[2], rn);
    }
    return r.emissiveTexture !== void 0 && a !== In && l.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Ot)), Promise.all(l).then(function() {
      const h = new a(o);
      return r.name && (h.name = r.name), Tr(h, r), t.associations.set(h, { materials: e }), r.extensions && is(i, h, r), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = It.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, i = this.primitiveCache;
    function r(o) {
      return n[Ct.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(c) {
        return zA(c, o, t);
      });
    }
    const a = [];
    for (let o = 0, c = e.length; o < c; o++) {
      const l = e[o], u = GI(l), h = i[u];
      if (h)
        a.push(h.promise);
      else {
        let f;
        l.extensions && l.extensions[Ct.KHR_DRACO_MESH_COMPRESSION] ? f = r(l) : f = zA(new ot(), l, t), i[u] = { primitive: l, promise: f }, a.push(f);
      }
    }
    return Promise.all(a);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, i = this.extensions, r = n.meshes[e], a = r.primitives, o = [];
    for (let c = 0, l = a.length; c < l; c++) {
      const u = a[c].material === void 0 ? NI(this.cache) : this.getDependency("material", a[c].material);
      o.push(u);
    }
    return o.push(t.loadGeometries(a)), Promise.all(o).then(function(c) {
      const l = c.slice(0, c.length - 1), u = c[c.length - 1], h = [];
      for (let d = 0, A = u.length; d < A; d++) {
        const m = u[d], p = a[d];
        let g;
        const _ = l[d];
        if (p.mode === gi.TRIANGLES || p.mode === gi.TRIANGLE_STRIP || p.mode === gi.TRIANGLE_FAN || p.mode === void 0)
          g = r.isSkinnedMesh === !0 ? new ad(m, _) : new Ne(m, _), g.isSkinnedMesh === !0 && g.normalizeSkinWeights(), p.mode === gi.TRIANGLE_STRIP ? g.geometry = NA(g.geometry, jf) : p.mode === gi.TRIANGLE_FAN && (g.geometry = NA(g.geometry, wl));
        else if (p.mode === gi.LINES)
          g = new Li(m, _);
        else if (p.mode === gi.LINE_STRIP)
          g = new Dn(m, _);
        else if (p.mode === gi.LINE_LOOP)
          g = new od(m, _);
        else if (p.mode === gi.POINTS)
          g = new cd(m, _);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
        Object.keys(g.geometry.morphAttributes).length > 0 && QI(g, r), g.name = t.createUniqueName(r.name || "mesh_" + e), Tr(g, r), p.extensions && is(i, g, p), t.assignFinalMaterial(g), h.push(g);
      }
      for (let d = 0, A = h.length; d < A; d++)
        t.associations.set(h[d], {
          meshes: e,
          primitives: d
        });
      if (h.length === 1)
        return r.extensions && is(i, h[0], r), h[0];
      const f = new Un();
      r.extensions && is(i, f, r), t.associations.set(f, { meshes: e });
      for (let d = 0, A = h.length; d < A; d++)
        f.add(h[d]);
      return f;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new _n(Cs.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Ls(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Tr(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
      const r = i.pop(), a = i, o = [], c = [];
      for (let l = 0, u = a.length; l < u; l++) {
        const h = a[l];
        if (h) {
          o.push(h);
          const f = new Je();
          r !== null && f.fromArray(r.array, l * 16), c.push(f);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
      }
      return new Xo(o, c);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, a = [], o = [], c = [], l = [], u = [];
    for (let h = 0, f = i.channels.length; h < f; h++) {
      const d = i.channels[h], A = i.samplers[d.sampler], m = d.target, p = m.node, g = i.parameters !== void 0 ? i.parameters[A.input] : A.input, _ = i.parameters !== void 0 ? i.parameters[A.output] : A.output;
      m.node !== void 0 && (a.push(this.getDependency("node", p)), o.push(this.getDependency("accessor", g)), c.push(this.getDependency("accessor", _)), l.push(A), u.push(m));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(o),
      Promise.all(c),
      Promise.all(l),
      Promise.all(u)
    ]).then(function(h) {
      const f = h[0], d = h[1], A = h[2], m = h[3], p = h[4], g = [];
      for (let _ = 0, b = f.length; _ < b; _++) {
        const y = f[_], v = d[_], x = A[_], S = m[_], I = p[_];
        if (y === void 0)
          continue;
        y.updateMatrix && y.updateMatrix();
        const E = n._createAnimationTracks(y, v, x, S, I);
        if (E)
          for (let M = 0; M < E.length; M++)
            g.push(E[M]);
      }
      return new Ca(r, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, i = t.nodes[e];
    return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
      const a = n._getNodeRef(n.meshCache, i.mesh, r);
      return i.weights !== void 0 && a.traverse(function(o) {
        if (o.isMesh)
          for (let c = 0, l = i.weights.length; c < l; c++)
            o.morphTargetInfluences[c] = i.weights[c];
      }), a;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, i = t.nodes[e], r = n._loadNodeShallow(e), a = [], o = i.children || [];
    for (let l = 0, u = o.length; l < u; l++)
      a.push(n.getDependency("node", o[l]));
    const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
    return Promise.all([
      r,
      Promise.all(a),
      c
    ]).then(function(l) {
      const u = l[0], h = l[1], f = l[2];
      f !== null && u.traverse(function(d) {
        d.isSkinnedMesh && d.bind(f, HI);
      });
      for (let d = 0, A = h.length; d < A; d++)
        u.add(h[d]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, i = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], a = r.name ? i.createUniqueName(r.name) : "", o = [], c = i._invokeOne(function(l) {
      return l.createNodeMesh && l.createNodeMesh(e);
    });
    return c && o.push(c), r.camera !== void 0 && o.push(i.getDependency("camera", r.camera).then(function(l) {
      return i._getNodeRef(i.cameraCache, r.camera, l);
    })), i._invokeAll(function(l) {
      return l.createNodeAttachment && l.createNodeAttachment(e);
    }).forEach(function(l) {
      o.push(l);
    }), this.nodeCache[e] = Promise.all(o).then(function(l) {
      let u;
      if (r.isBone === !0 ? u = new Zl() : l.length > 1 ? u = new Un() : l.length === 1 ? u = l[0] : u = new bt(), u !== l[0])
        for (let h = 0, f = l.length; h < f; h++)
          u.add(l[h]);
      if (r.name && (u.userData.name = r.name, u.name = a), Tr(u, r), r.extensions && is(n, u, r), r.matrix !== void 0) {
        const h = new Je();
        h.fromArray(r.matrix), u.applyMatrix4(h);
      } else
        r.translation !== void 0 && u.position.fromArray(r.translation), r.rotation !== void 0 && u.quaternion.fromArray(r.rotation), r.scale !== void 0 && u.scale.fromArray(r.scale);
      return i.associations.has(u) || i.associations.set(u, {}), i.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], i = this, r = new Un();
    n.name && (r.name = i.createUniqueName(n.name)), Tr(r, n), n.extensions && is(t, r, n);
    const a = n.nodes || [], o = [];
    for (let c = 0, l = a.length; c < l; c++)
      o.push(i.getDependency("node", a[c]));
    return Promise.all(o).then(function(c) {
      for (let u = 0, h = c.length; u < h; u++)
        r.add(c[u]);
      const l = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [f, d] of i.associations)
          (f instanceof vn || f instanceof Jt) && h.set(f, d);
        return u.traverse((f) => {
          const d = i.associations.get(f);
          d != null && h.set(f, d);
        }), h;
      };
      return i.associations = l(r), r;
    });
  }
  _createAnimationTracks(e, t, n, i, r) {
    const a = [], o = e.name ? e.name : e.uuid, c = [];
    Mr[r.path] === Mr.weights ? e.traverse(function(f) {
      f.morphTargetInfluences && c.push(f.name ? f.name : f.uuid);
    }) : c.push(o);
    let l;
    switch (Mr[r.path]) {
      case Mr.weights:
        l = Is;
        break;
      case Mr.rotation:
        l = Or;
        break;
      case Mr.position:
      case Mr.scale:
        l = ws;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            l = Is;
            break;
          case 2:
          case 3:
          default:
            l = ws;
            break;
        }
        break;
    }
    const u = i.interpolation !== void 0 ? kI[i.interpolation] : Ss, h = this._getArrayFromAccessor(n);
    for (let f = 0, d = c.length; f < d; f++) {
      const A = new l(
        c[f] + "." + Mr[r.path],
        t.array,
        h,
        u
      );
      i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(A), a.push(A);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Lf(t.constructor), i = new Float32Array(t.length);
      for (let r = 0, a = t.length; r < a; r++)
        i[r] = t[r] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const i = this instanceof Or ? FI : I_;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function WI(s, e, t) {
  const n = e.attributes, i = new bn();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION], c = o.min, l = o.max;
    if (c !== void 0 && l !== void 0) {
      if (i.set(
        new P(c[0], c[1], c[2]),
        new P(l[0], l[1], l[2])
      ), o.normalized) {
        const u = Lf(ma[o.componentType]);
        i.min.multiplyScalar(u), i.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const o = new P(), c = new P();
    for (let l = 0, u = r.length; l < u; l++) {
      const h = r[l];
      if (h.POSITION !== void 0) {
        const f = t.json.accessors[h.POSITION], d = f.min, A = f.max;
        if (d !== void 0 && A !== void 0) {
          if (c.setX(Math.max(Math.abs(d[0]), Math.abs(A[0]))), c.setY(Math.max(Math.abs(d[1]), Math.abs(A[1]))), c.setZ(Math.max(Math.abs(d[2]), Math.abs(A[2]))), f.normalized) {
            const m = Lf(ma[f.componentType]);
            c.multiplyScalar(m);
          }
          o.max(c);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    i.expandByVector(o);
  }
  s.boundingBox = i;
  const a = new yn();
  i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, s.boundingSphere = a;
}
function zA(s, e, t) {
  const n = e.attributes, i = [];
  function r(a, o) {
    return t.getDependency("accessor", a).then(function(c) {
      s.setAttribute(o, c);
    });
  }
  for (const a in n) {
    const o = Df[a] || a.toLowerCase();
    o in s.attributes || i.push(r(n[a], o));
  }
  if (e.indices !== void 0 && !s.index) {
    const a = t.getDependency("accessor", e.indices).then(function(o) {
      s.setIndex(o);
    });
    i.push(a);
  }
  return Tt.workingColorSpace !== rn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Tt.workingColorSpace}" not supported.`), Tr(s, e), WI(s, e, t), Promise.all(i).then(function() {
    return e.targets !== void 0 ? OI(s, e.targets, t) : s;
  });
}
class qI {
  constructor(e = 4) {
    this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & 1 << e))
        return e;
    return -1;
  }
  _onMessage(e, t) {
    const n = this.workersResolve[e];
    if (n && n(t), this.queue.length) {
      const { resolve: i, msg: r, transfer: a } = this.queue.shift();
      this.workersResolve[e] = i, this.workers[e].postMessage(r, a);
    } else
      this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((n) => {
      const i = this._getIdleWorker();
      i !== -1 ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(e, t)) : this.queue.push({ resolve: n, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const XI = 0, HA = 2, YI = 1, VA = 2, jI = 0, JI = 1, KI = 10, ZI = 0, w_ = 9, T_ = 15, B_ = 16, R_ = 22, D_ = 37, L_ = 43, P_ = 76, U_ = 83, F_ = 97, k_ = 100, N_ = 103, O_ = 109, Q_ = 165, G_ = 166;
class $I {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class no {
  constructor(e, t, n, i) {
    this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return this._offset += 1, e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _nextUint64() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, e;
  }
  _skip(e) {
    return this._offset += e, this;
  }
  _scan(e, t = 0) {
    const n = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== t && i < e; )
      i++, this._offset++;
    return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);
  }
}
const Xn = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function WA(s) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(s) : Buffer.from(s).toString("utf8");
}
function ew(s) {
  const e = new Uint8Array(s.buffer, s.byteOffset, Xn.length);
  if (e[0] !== Xn[0] || e[1] !== Xn[1] || e[2] !== Xn[2] || e[3] !== Xn[3] || e[4] !== Xn[4] || e[5] !== Xn[5] || e[6] !== Xn[6] || e[7] !== Xn[7] || e[8] !== Xn[8] || e[9] !== Xn[9] || e[10] !== Xn[10] || e[11] !== Xn[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const t = new $I(), n = 17 * Uint32Array.BYTES_PER_ELEMENT, i = new no(s, Xn.length, n, !0);
  t.vkFormat = i._nextUint32(), t.typeSize = i._nextUint32(), t.pixelWidth = i._nextUint32(), t.pixelHeight = i._nextUint32(), t.pixelDepth = i._nextUint32(), t.layerCount = i._nextUint32(), t.faceCount = i._nextUint32();
  const r = i._nextUint32();
  t.supercompressionScheme = i._nextUint32();
  const a = i._nextUint32(), o = i._nextUint32(), c = i._nextUint32(), l = i._nextUint32(), u = i._nextUint64(), h = i._nextUint64(), f = new no(s, Xn.length + n, 3 * r * 8, !0);
  for (let V = 0; V < r; V++)
    t.levels.push({ levelData: new Uint8Array(s.buffer, s.byteOffset + f._nextUint64(), f._nextUint64()), uncompressedByteLength: f._nextUint64() });
  const d = new no(s, a, o, !0), A = { vendorId: d._skip(4)._nextUint16(), descriptorType: d._nextUint16(), versionNumber: d._nextUint16(), descriptorBlockSize: d._nextUint16(), colorModel: d._nextUint8(), colorPrimaries: d._nextUint8(), transferFunction: d._nextUint8(), flags: d._nextUint8(), texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], samples: [] }, m = (A.descriptorBlockSize / 4 - 6) / 4;
  for (let V = 0; V < m; V++) {
    const q = { bitOffset: d._nextUint16(), bitLength: d._nextUint8(), channelType: d._nextUint8(), samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & q.channelType ? (q.sampleLower = d._nextInt32(), q.sampleUpper = d._nextInt32()) : (q.sampleLower = d._nextUint32(), q.sampleUpper = d._nextUint32()), A.samples[V] = q;
  }
  t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(A);
  const p = new no(s, c, l, !0);
  for (; p._offset < l; ) {
    const V = p._nextUint32(), q = p._scan(V), z = WA(q), X = p._scan(V - q.byteLength);
    t.keyValue[z] = z.match(/^ktx/i) ? WA(X) : X, p._offset % 4 && p._skip(4 - p._offset % 4);
  }
  if (h <= 0)
    return t;
  const g = new no(s, u, h, !0), _ = g._nextUint16(), b = g._nextUint16(), y = g._nextUint32(), v = g._nextUint32(), x = g._nextUint32(), S = g._nextUint32(), I = [];
  for (let V = 0; V < r; V++)
    I.push({ imageFlags: g._nextUint32(), rgbSliceByteOffset: g._nextUint32(), rgbSliceByteLength: g._nextUint32(), alphaSliceByteOffset: g._nextUint32(), alphaSliceByteLength: g._nextUint32() });
  const E = u + g._offset, M = E + y, T = M + v, D = T + x, F = new Uint8Array(s.buffer, s.byteOffset + E, y), C = new Uint8Array(s.buffer, s.byteOffset + M, v), R = new Uint8Array(s.buffer, s.byteOffset + T, x), O = new Uint8Array(s.buffer, s.byteOffset + D, S);
  return t.globalData = { endpointCount: _, selectorCount: b, imageDescs: I, endpointsData: F, selectorsData: C, tablesData: R, extendedData: O }, t;
}
let yh, sr, Pf;
const vh = { env: { emscripten_notify_memory_growth: function(s) {
  Pf = new Uint8Array(sr.exports.memory.buffer);
} } };
class tw {
  init() {
    return yh || (yh = typeof fetch < "u" ? fetch("data:application/wasm;base64," + qA).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, vh)).then(this._init) : WebAssembly.instantiate(Buffer.from(qA, "base64"), vh).then(this._init), yh);
  }
  _init(e) {
    sr = e.instance, vh.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!sr)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const n = e.byteLength, i = sr.exports.malloc(n);
    Pf.set(e, i), t = t || Number(sr.exports.ZSTD_findDecompressedSize(i, n));
    const r = sr.exports.malloc(t), a = sr.exports.ZSTD_decompress(r, t, i, n), o = Pf.slice(r, r + a);
    return sr.exports.free(i), sr.exports.free(r), o;
  }
}
const qA = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Eh = /* @__PURE__ */ new WeakMap();
let xh = 0, Sh;
class Vi extends Tn {
  constructor(e) {
    super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new qI(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(e) {
    return this.transcoderPath = e, this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  detectSupport(e) {
    return e.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: e.hasFeature("texture-compression-astc"),
      etc1Supported: !1,
      etc2Supported: e.hasFeature("texture-compression-etc2"),
      dxtSupported: e.hasFeature("texture-compression-bc"),
      bptcSupported: !1,
      pvrtcSupported: !1
    } : (this.workerConfig = {
      astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)), this;
  }
  init() {
    if (!this.transcoderPending) {
      const e = new wn(this.manager);
      e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"), n = new wn(this.manager);
      n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
      const i = n.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([t, i]).then(([r, a]) => {
        const o = Vi.BasisWorker.toString(), c = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(Vi.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(Vi.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(Vi.BasisFormat),
          "/* basis_transcoder.js */",
          r,
          "/* worker */",
          o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([c])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
          const l = new Worker(this.workerSourceURL), u = this.transcoderBinary.slice(0);
          return l.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: u }, [u]), l;
        });
      }), xh > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), xh++;
    }
    return this.transcoderPending;
  }
  load(e, t, n, i) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const r = new wn(this.manager);
    r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
      if (Eh.has(a))
        return Eh.get(a).promise.then(t).catch(i);
      this._createTexture(a).then((o) => t ? t(o) : null).catch(i);
    }, n, i);
  }
  _createTextureFrom(e, t) {
    const { faces: n, width: i, height: r, format: a, type: o, error: c, dfdFlags: l } = e;
    if (o === "error")
      return Promise.reject(c);
    let u;
    if (t.faceCount === 6)
      u = new B0(n, a, fn);
    else {
      const h = n[0].mipmaps;
      u = t.layerCount > 1 ? new T0(h, i, r, t.layerCount, a, fn) : new Ra(h, i, r, a, fn);
    }
    return u.minFilter = n[0].mipmaps.length === 1 ? wt : _i, u.magFilter = wt, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = z_(t), u.premultiplyAlpha = !!(l & YI), u;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(e, t = {}) {
    const n = ew(new Uint8Array(e));
    if (n.vkFormat !== ZI)
      return iw(n);
    const i = t, r = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: i }, [e])).then((a) => this._createTextureFrom(a.data, n));
    return Eh.set(e, { promise: r }), r;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), xh--, this;
  }
}
Vi.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
Vi.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
Vi.EngineFormat = {
  RGBAFormat: dn,
  RGBA_ASTC_4x4_Format: Il,
  RGBA_BPTC_Format: mo,
  RGBA_ETC2_EAC_Format: Ml,
  RGBA_PVRTC_4BPPV1_Format: Sl,
  RGBA_S3TC_DXT5_Format: go,
  RGB_ETC1_Format: Nl,
  RGB_ETC2_Format: Cl,
  RGB_PVRTC_4BPPV1_Format: xl,
  RGB_S3TC_DXT1_Format: Ao
};
Vi.BasisWorker = function() {
  let s, e, t;
  const n = _EngineFormat, i = _TranscoderFormat, r = _BasisFormat;
  self.addEventListener("message", function(A) {
    const m = A.data;
    switch (m.type) {
      case "init":
        s = m.config, a(m.transcoderBinary);
        break;
      case "transcode":
        e.then(() => {
          try {
            const { faces: p, buffers: g, width: _, height: b, hasAlpha: y, format: v, dfdFlags: x } = o(m.buffer);
            self.postMessage({ type: "transcode", id: m.id, faces: p, width: _, height: b, hasAlpha: y, format: v, dfdFlags: x }, g);
          } catch (p) {
            console.error(p), self.postMessage({ type: "error", id: m.id, error: p.message });
          }
        });
        break;
    }
  });
  function a(A) {
    e = new Promise((m) => {
      t = { wasmBinary: A, onRuntimeInitialized: m }, BASIS(t);
    }).then(() => {
      t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function o(A) {
    const m = new t.KTX2File(new Uint8Array(A));
    function p() {
      m.close(), m.delete();
    }
    if (!m.isValid())
      throw p(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    const g = m.isUASTC() ? r.UASTC_4x4 : r.ETC1S, _ = m.getWidth(), b = m.getHeight(), y = m.getLayers() || 1, v = m.getLevels(), x = m.getFaces(), S = m.getHasAlpha(), I = m.getDFDFlags(), { transcoderFormat: E, engineFormat: M } = h(g, _, b, S);
    if (!_ || !b || !v)
      throw p(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!m.startTranscoding())
      throw p(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const T = [], D = [];
    for (let F = 0; F < x; F++) {
      const C = [];
      for (let R = 0; R < v; R++) {
        const O = [];
        let V, q;
        for (let X = 0; X < y; X++) {
          const w = m.getImageLevelInfo(R, X, F);
          F === 0 && R === 0 && X === 0 && (w.origWidth % 4 !== 0 || w.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), v > 1 ? (V = w.origWidth, q = w.origHeight) : (V = w.width, q = w.height);
          const N = new Uint8Array(m.getImageTranscodedSizeInBytes(R, X, 0, E));
          if (!m.transcodeImage(N, R, X, F, E, 0, -1, -1))
            throw p(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          O.push(N);
        }
        const z = d(O);
        C.push({ data: z, width: V, height: q }), D.push(z.buffer);
      }
      T.push({ mipmaps: C, width: _, height: b, format: M });
    }
    return p(), { faces: T, buffers: D, width: _, height: b, hasAlpha: S, format: M, dfdFlags: I };
  }
  const c = [
    {
      if: "astcSupported",
      basisFormat: [r.UASTC_4x4],
      transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
      engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.BC7_M5, i.BC7_M5],
      engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.BC1, i.BC3],
      engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.ETC1, i.ETC2],
      engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.ETC1],
      engineFormat: [n.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [r.ETC1S, r.UASTC_4x4],
      transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
      engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }
  ], l = c.sort(function(A, m) {
    return A.priorityETC1S - m.priorityETC1S;
  }), u = c.sort(function(A, m) {
    return A.priorityUASTC - m.priorityUASTC;
  });
  function h(A, m, p, g) {
    let _, b;
    const y = A === r.ETC1S ? l : u;
    for (let v = 0; v < y.length; v++) {
      const x = y[v];
      if (s[x.if] && x.basisFormat.includes(A) && !(g && x.transcoderFormat.length < 2) && !(x.needsPowerOfTwo && !(f(m) && f(p))))
        return _ = x.transcoderFormat[g ? 1 : 0], b = x.engineFormat[g ? 1 : 0], { transcoderFormat: _, engineFormat: b };
    }
    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), _ = i.RGBA32, b = n.RGBAFormat, { transcoderFormat: _, engineFormat: b };
  }
  function f(A) {
    return A <= 2 ? !0 : (A & A - 1) === 0 && A !== 0;
  }
  function d(A) {
    if (A.length === 1)
      return A[0];
    let m = 0;
    for (let _ = 0; _ < A.length; _++) {
      const b = A[_];
      m += b.byteLength;
    }
    const p = new Uint8Array(m);
    let g = 0;
    for (let _ = 0; _ < A.length; _++) {
      const b = A[_];
      p.set(b, g), g += b.byteLength;
    }
    return p;
  }
};
const nw = /* @__PURE__ */ new Set([dn, As, ps]), Ch = {
  [O_]: dn,
  [F_]: dn,
  [D_]: dn,
  [L_]: dn,
  [N_]: As,
  [U_]: As,
  [B_]: As,
  [R_]: As,
  [k_]: ps,
  [P_]: ps,
  [T_]: ps,
  [w_]: ps,
  [G_]: wo,
  [Q_]: wo
}, Mh = {
  [O_]: pn,
  [F_]: Pn,
  [D_]: fn,
  [L_]: fn,
  [N_]: pn,
  [U_]: Pn,
  [B_]: fn,
  [R_]: fn,
  [k_]: pn,
  [P_]: Pn,
  [T_]: fn,
  [w_]: fn,
  [G_]: fn,
  [Q_]: fn
};
async function iw(s) {
  const { vkFormat: e } = s;
  if (Ch[e] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let t;
  s.supercompressionScheme === HA && (Sh || (Sh = new Promise(async (r) => {
    const a = new tw();
    await a.init(), r(a);
  })), t = await Sh);
  const n = [];
  for (let r = 0; r < s.levels.length; r++) {
    const a = Math.max(1, s.pixelWidth >> r), o = Math.max(1, s.pixelHeight >> r), c = s.pixelDepth ? Math.max(1, s.pixelDepth >> r) : 0, l = s.levels[r];
    let u;
    if (s.supercompressionScheme === XI)
      u = l.levelData;
    else if (s.supercompressionScheme === HA)
      u = t.decode(l.levelData, l.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let h;
    Mh[e] === pn ? h = new Float32Array(
      u.buffer,
      u.byteOffset,
      u.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : Mh[e] === Pn ? h = new Uint16Array(
      u.buffer,
      u.byteOffset,
      u.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : h = u, n.push({
      data: h,
      width: a,
      height: o,
      depth: c
    });
  }
  let i;
  if (nw.has(Ch[e]))
    i = s.pixelDepth === 0 ? new pr(n[0].data, s.pixelWidth, s.pixelHeight) : new zl(n[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
  else {
    if (s.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    i = new Ra(n, s.pixelWidth, s.pixelHeight);
  }
  return i.mipmaps = n, i.type = Mh[e], i.format = Ch[e], i.colorSpace = z_(s), i.needsUpdate = !0, Promise.resolve(i);
}
function z_(s) {
  const e = s.dataFormatDescriptor[0];
  return e.colorPrimaries === JI ? e.transferFunction === VA ? Ot : rn : e.colorPrimaries === KI ? e.transferFunction === VA ? Ho : wa : (e.colorPrimaries === jI || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), jn);
}
const rw = (s) => {
  const e = { nodes: {}, materials: {} };
  return s && s.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material);
  }), e;
}, Ih = {};
function H_(s, e) {
  const { renderer: t } = sn(), n = typeof s == "string" ? e : s, i = pu(fI, {
    extend(o) {
      if (n != null && n.useDraco)
        if (typeof n.useDraco == "string" || typeof n.useDraco == "boolean") {
          const c = typeof n.useDraco == "string" ? n.useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
          Ih[c] || (Ih[c] = new uI().setDecoderPath(c)), o.setDRACOLoader(Ih[c]);
        } else
          o.setDRACOLoader(n.useDraco);
      if (n != null && n.useMeshopt && o.setMeshoptDecoder(lI), n != null && n.ktxTranscoderPath) {
        const c = new Vi();
        c.setTranscoderPath(n == null ? void 0 : n.ktxTranscoderPath), c.detectSupport(t), o.setKTX2Loader(c);
      }
    }
  }), r = (o) => i.load(o, {
    transform(c) {
      return {
        ...c,
        ...rw(c.scene)
      };
    }
  }), a = typeof s == "string" ? s : void 0;
  return a ? r(a) : {
    load: r
  };
}
const XA = (s) => !!(s != null && s.isObject3D), sw = (s) => !!(s != null && s.subscribe) && typeof s.subscribe == "function";
function aw(s, e) {
  const t = sw(s) ? s : vt(void 0), n = Ht(XA(s) ? s : XA(e) ? e : void 0), i = Vn([n, t], ([l, u]) => l ?? (u == null ? void 0 : u.scene)), r = Ht({}), a = new m_(void 0);
  Ft([t, i], async ([l, u]) => {
    if (!l || !l.animations.length || !u)
      return;
    await Ll();
    const h = l.animations.reduce((f, d) => {
      const A = a.clipAction(d, u);
      return {
        ...f,
        [d.name]: A
      };
    }, {});
    return r.set(h), () => {
      Object.values(h).forEach((f) => {
        const d = f;
        d.stop(), a.uncacheClip(d.getClip());
      });
    };
  });
  const { start: o, stop: c } = bi((l) => {
    a.update(l);
  }, { autoStart: !1 });
  return Ft(r, (l) => {
    Object.keys(l).length ? o() : c();
  }), {
    gltf: t,
    root: n,
    mixer: a,
    actions: r
  };
}
const ow = (s, e) => {
  const t = pu(Qo, e), { renderer: n } = sn();
  return t.load(s, {
    ...e,
    transform: (i) => {
      var r;
      return "colorSpace" in i ? i.colorSpace = n.outputColorSpace : i.encoding = n.outputEncoding, i.needsUpdate = !0, ((r = e == null ? void 0 : e.transform) == null ? void 0 : r.call(e, i)) ?? i;
    }
  });
}, V_ = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER"), cw = (s) => {
  const e = Ji(), t = Ht(/* @__PURE__ */ new Map()), n = Ht(/* @__PURE__ */ new Map()), i = vt(!1), r = () => {
    t.current.size === 0 && n.current.size === 0 && i.set(!0);
  }, a = vt((s == null ? void 0 : s.final) ?? !1), o = (d, A) => {
    t.update((m) => {
      var p;
      return m.has(d) ? (p = m.get(d)) == null || p.add(A) : m.set(d, /* @__PURE__ */ new Set([A])), m;
    });
  }, c = (d, A) => {
    t.update((m) => {
      var p, g;
      return m.has(d) && ((p = m.get(d)) == null || p.delete(A)), ((g = m.get(d)) == null ? void 0 : g.size) === 0 && m.delete(d), m;
    });
  }, l = (d, A) => {
    n.update((m) => {
      var p;
      return m.has(d) ? (p = m.get(d)) == null || p.push(A) : m.set(d, [A]), m;
    });
  }, u = Vn([t, n, a, i], ([d, A, m, p]) => m && p ? !1 : A.size > 0 ? !0 : d.size > 0), h = {
    suspend(d, A) {
      o(d, A), A.then(() => {
        var m;
        (m = t.current.get(d)) != null && m.has(A) && c(d, A);
      }).catch((m) => {
        var p;
        (p = t.current.get(d)) != null && p.has(A) && (c(d, A), l(d, m), e("error", m));
      }).finally(() => {
        r();
      });
    },
    onComponentDestroy(d) {
      t.update((A) => (A.delete(d), A)), n.update((A) => (A.delete(d), A)), r();
    },
    suspended: u
  }, f = Vn(n, (d) => Array.from(d.values()).flat());
  return Jn(V_, h), {
    promises: t,
    suspended: u,
    errors: f,
    setFinal: (d) => a.set(d ?? !1)
  };
}, Au = () => {
  const s = Wn(V_), e = vi(), t = (i) => (s == null || s.suspend(e, i), i), n = {
    suspended: Vn((s == null ? void 0 : s.suspended) ?? wd(!1), (i) => i)
  };
  return Wt(() => {
    s == null || s.onComponentDestroy(e);
  }), Object.assign(t, n);
};
function lw(s) {
  let e, t, n;
  const i = [
    { is: (
      /*is*/
      s[3]
    ) },
    { map: (
      /*texture*/
      s[4]
    ) },
    { toneMapped: !1 },
    { transparent: (
      /*transparent*/
      s[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      s[1]
    ) },
    /*$$restProps*/
    s[7]
  ];
  function r(o) {
    s[26](o);
  }
  let a = {};
  for (let o = 0; o < i.length; o += 1)
    a = Ve(a, i[o]);
  return (
    /*ref*/
    s[0] !== void 0 && (a.ref = /*ref*/
    s[0]), e = new qe({ props: a }), Mt.push(() => Gi(e, "ref", r)), {
      c() {
        ze(e.$$.fragment);
      },
      m(o, c) {
        Oe(e, o, c), n = !0;
      },
      p(o, c) {
        const l = c[0] & /*is, texture, transparent, alphaTest, $$restProps*/
        158 ? Qt(i, [
          c[0] & /*is*/
          8 && { is: (
            /*is*/
            o[3]
          ) },
          c[0] & /*texture*/
          16 && { map: (
            /*texture*/
            o[4]
          ) },
          i[2],
          c[0] & /*transparent*/
          4 && { transparent: (
            /*transparent*/
            o[2]
          ) },
          c[0] & /*alphaTest*/
          2 && { alphaTest: (
            /*alphaTest*/
            o[1]
          ) },
          c[0] & /*$$restProps*/
          128 && qt(
            /*$$restProps*/
            o[7]
          )
        ]) : {};
        !t && c[0] & /*ref*/
        1 && (t = !0, l.ref = /*ref*/
        o[0], Qi(() => t = !1)), e.$set(l);
      },
      i(o) {
        n || (ae(e.$$.fragment, o), n = !0);
      },
      o(o) {
        ue(e.$$.fragment, o), n = !1;
      },
      d(o) {
        Qe(e, o);
      }
    }
  );
}
function uw(s) {
  let e, t, n, i, r;
  const a = [
    { is: (
      /*is*/
      s[3]
    ) },
    { map: (
      /*texture*/
      s[4]
    ) },
    { toneMapped: !1 },
    { side: Mn },
    { shadowSide: Mn },
    { transparent: (
      /*transparent*/
      s[2]
    ) },
    { alphaTest: (
      /*alphaTest*/
      s[1]
    ) },
    /*$$restProps*/
    s[7]
  ];
  function o(l) {
    s[25](l);
  }
  let c = {};
  for (let l = 0; l < a.length; l += 1)
    c = Ve(c, a[l]);
  return (
    /*ref*/
    s[0] !== void 0 && (c.ref = /*ref*/
    s[0]), e = new qe({ props: c }), Mt.push(() => Gi(e, "ref", o)), i = new qe.MeshDepthMaterial({
      props: {
        attach: "customDepthMaterial",
        depthPacking: Ql,
        map: (
          /*texture*/
          s[4]
        ),
        alphaTest: (
          /*alphaTest*/
          s[1]
        )
      }
    }), {
      c() {
        ze(e.$$.fragment), n = Pt(), ze(i.$$.fragment);
      },
      m(l, u) {
        Oe(e, l, u), st(l, n, u), Oe(i, l, u), r = !0;
      },
      p(l, u) {
        const h = u[0] & /*is, texture, transparent, alphaTest, $$restProps*/
        158 ? Qt(a, [
          u[0] & /*is*/
          8 && { is: (
            /*is*/
            l[3]
          ) },
          u[0] & /*texture*/
          16 && { map: (
            /*texture*/
            l[4]
          ) },
          a[2],
          a[3],
          a[4],
          u[0] & /*transparent*/
          4 && { transparent: (
            /*transparent*/
            l[2]
          ) },
          u[0] & /*alphaTest*/
          2 && { alphaTest: (
            /*alphaTest*/
            l[1]
          ) },
          u[0] & /*$$restProps*/
          128 && qt(
            /*$$restProps*/
            l[7]
          )
        ]) : {};
        !t && u[0] & /*ref*/
        1 && (t = !0, h.ref = /*ref*/
        l[0], Qi(() => t = !1)), e.$set(h);
        const f = {};
        u[0] & /*texture*/
        16 && (f.map = /*texture*/
        l[4]), u[0] & /*alphaTest*/
        2 && (f.alphaTest = /*alphaTest*/
        l[1]), i.$set(f);
      },
      i(l) {
        r || (ae(e.$$.fragment, l), ae(i.$$.fragment, l), r = !0);
      },
      o(l) {
        ue(e.$$.fragment, l), ue(i.$$.fragment, l), r = !1;
      },
      d(l) {
        l && rt(n), Qe(e, l), Qe(i, l);
      }
    }
  );
}
function hw(s) {
  let e, t, n, i;
  const r = [uw, lw], a = [];
  function o(c, l) {
    return (
      /*texture*/
      c[4] && /*isMesh*/
      c[5] ? 0 : (
        /*texture*/
        c[4] ? 1 : -1
      )
    );
  }
  return ~(e = o(s)) && (t = a[e] = r[e](s)), {
    c() {
      t && t.c(), n = yi();
    },
    m(c, l) {
      ~e && a[e].m(c, l), st(c, n, l), i = !0;
    },
    p(c, l) {
      let u = e;
      e = o(c), e === u ? ~e && a[e].p(c, l) : (t && (ai(), ue(a[u], 1, 1, () => {
        a[u] = null;
      }), oi()), ~e ? (t = a[e], t ? t.p(c, l) : (t = a[e] = r[e](c), t.c()), ae(t, 1), t.m(n.parentNode, n)) : t = null);
    },
    i(c) {
      i || (ae(t), i = !0);
    },
    o(c) {
      ue(t), i = !1;
    },
    d(c) {
      c && rt(n), ~e && a[e].d(c);
    }
  };
}
function fw(s, e, t) {
  let n;
  const i = [
    "textureUrl",
    "dataUrl",
    "animation",
    "loop",
    "autoplay",
    "fps",
    "filter",
    "alphaTest",
    "delay",
    "transparent",
    "flipX",
    "startFrame",
    "endFrame",
    "rows",
    "columns",
    "totalFrames",
    "is",
    "ref",
    "play",
    "pause"
  ];
  let r = at(e, i), a, { textureUrl: o } = e, { dataUrl: c = "" } = e, { animation: l = "" } = e, { loop: u = !0 } = e, { autoplay: h = !0 } = e, { fps: f = 10 } = e, { filter: d = "nearest" } = e, { alphaTest: A = 0.1 } = e, { delay: m = 0 } = e, { transparent: p = !0 } = e, { flipX: g = !1 } = e, { startFrame: _ = 0 } = e, { endFrame: b = void 0 } = e, { rows: y = 1 } = e, { columns: v = void 0 } = e, { totalFrames: x = 0 } = e;
  const S = Fs();
  $e(s, S, (K) => t(24, a = K));
  const I = Ji(), E = ["forward", "reverse"], M = (K) => {
    const ve = E.includes(K);
    return ve || console.warn(`Unsupported sprite animation direction "${K}"`), ve;
  };
  let T = 0, D = _, F = 0, C = g ? -1 : 1, R = 0, O = 0, V, q, z = [], X = "forward", w, N = { w: 0, h: 0 }, H = "isMesh" in a, { is: j = H ? new In() : new Kl() } = e, { ref: $ } = e;
  const ce = Au(), ee = ce(ow(o, {
    transform: (K) => (K.matrixAutoUpdate = !1, K.generateMipmaps = !1, K.premultiplyAlpha = !1, K.wrapS = K.wrapT = Ar, K.magFilter = K.minFilter = d === "nearest" ? tn : wt, K)
  })), le = ce(c ? pu(wn).load(c, {
    transform: (K) => {
      if (typeof K == "string")
        try {
          return JSON.parse(K);
        } catch {
          return;
        }
    }
  }) : pl(new Promise((K) => {
    const ve = ee.subscribe((fe) => {
      fe && (ve(), K(Z(fe)));
    });
  }))), Z = (K) => {
    const { width: ve, height: fe } = K.image, oe = v ?? x;
    F = x;
    const L = ve / oe, B = fe / y, W = {
      frames: {},
      meta: {
        app: "",
        image: "",
        format: "",
        frameTags: [],
        version: "1.0",
        size: { w: ve, h: fe },
        scale: 1
      }
    };
    for (let de = 0; de < F; de += 1) {
      const Ae = Math.floor(de / oe), Ce = de % oe * L, Se = Ae * B;
      W.frames[`${de}`] = {
        frame: { x: Ce, y: Se, w: L, h: B },
        spriteSourceSize: {
          x: 0,
          y: 0,
          w: L,
          h: B
        },
        sourceSize: { w: L, h: B }
      };
    }
    return W;
  }, he = (K) => {
    const ve = N.w / R, fe = N.h / O, oe = 1 / ve, L = 1 / fe, B = C > 0 ? oe * (K.x / R) : oe * (K.x / O) - V.repeat.x, W = Math.abs(1 - L) - L * (K.y / O);
    V == null || V.offset.set(B, W), V == null || V.updateMatrix();
  }, _e = (K) => {
    q && (w = q == null ? void 0 : q.meta.frameTags.find((ve) => ve.name === K), X = M(w == null ? void 0 : w.direction) ? w.direction : "forward", D = X === "forward" ? (w == null ? void 0 : w.from) ?? 0 : (w == null ? void 0 : w.to) ?? F - 1, he(q.frames[z[D]].frame), I.hasEventListener("start") && I("start"));
  };
  let U = !1;
  const ye = async () => {
    U = !0, await Promise.all([ee, le]), U && (T = performance.now() - m, re());
  }, ie = () => {
    U = !1, te();
  }, { start: re, stop: te } = bi(
    () => {
      if (!q)
        return;
      const K = performance.now(), ve = K - T, fe = z[D], { frame: oe, duration: L } = q.frames[fe], B = L ?? n;
      if (ve <= B)
        return;
      T = K - ve % B;
      const W = X === "forward" ? (w == null ? void 0 : w.from) ?? _ ?? 0 : (w == null ? void 0 : w.to) ?? b ?? F - 1, de = X === "forward" ? (w == null ? void 0 : w.to) ?? b ?? F - 1 : (w == null ? void 0 : w.from) ?? _ ?? 0;
      switch (he(oe), X) {
        case "forward":
          D += 1;
          break;
        case "reverse":
          D -= 1;
          break;
      }
      (X === "forward" && D > de || X === "reverse" && D < de) && (D = W, u ? I.hasEventListener("loop") && I("loop") : (ie(), I.hasEventListener("end") && I("end")));
    },
    { autoStart: !1 }
  );
  Ft([ee, le], ([K, ve]) => {
    if (K === void 0 || ve === void 0)
      return;
    t(4, V = K.clone()), q = ve, z = Object.keys(q.frames), F = z.length, N = q.meta.size;
    const { sourceSize: fe } = Object.values(q.frames)[0];
    R = fe.w, O = fe.h, V.repeat.set(1 * C / (N.w / R), 1 / (N.h / O)), _e(l), I("load"), h && ye();
  });
  function Ie(K) {
    $ = K, t(0, $);
  }
  function se(K) {
    $ = K, t(0, $);
  }
  return s.$$set = (K) => {
    e = Ve(Ve({}, e), Kt(K)), t(7, r = at(e, i)), "textureUrl" in K && t(8, o = K.textureUrl), "dataUrl" in K && t(9, c = K.dataUrl), "animation" in K && t(10, l = K.animation), "loop" in K && t(11, u = K.loop), "autoplay" in K && t(12, h = K.autoplay), "fps" in K && t(13, f = K.fps), "filter" in K && t(14, d = K.filter), "alphaTest" in K && t(1, A = K.alphaTest), "delay" in K && t(15, m = K.delay), "transparent" in K && t(2, p = K.transparent), "flipX" in K && t(16, g = K.flipX), "startFrame" in K && t(17, _ = K.startFrame), "endFrame" in K && t(18, b = K.endFrame), "rows" in K && t(19, y = K.rows), "columns" in K && t(20, v = K.columns), "totalFrames" in K && t(21, x = K.totalFrames), "is" in K && t(3, j = K.is), "ref" in K && t(0, $ = K.ref);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*$parent*/
    16777216 && t(5, H = "isMesh" in a), s.$$.dirty[0] & /*fps*/
    8192 && (n = 1e3 / f), s.$$.dirty[0] & /*animation, autoplay*/
    5120 && (_e(l), h && ye());
  }, [
    $,
    A,
    p,
    j,
    V,
    H,
    S,
    r,
    o,
    c,
    l,
    u,
    h,
    f,
    d,
    m,
    g,
    _,
    b,
    y,
    v,
    x,
    ye,
    ie,
    a,
    Ie,
    se
  ];
}
class dw extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      fw,
      hw,
      pt,
      {
        textureUrl: 8,
        dataUrl: 9,
        animation: 10,
        loop: 11,
        autoplay: 12,
        fps: 13,
        filter: 14,
        alphaTest: 1,
        delay: 15,
        transparent: 2,
        flipX: 16,
        startFrame: 17,
        endFrame: 18,
        rows: 19,
        columns: 20,
        totalFrames: 21,
        is: 3,
        ref: 0,
        play: 22,
        pause: 23
      },
      null,
      [-1, -1]
    );
  }
  get textureUrl() {
    return this.$$.ctx[8];
  }
  set textureUrl(e) {
    this.$$set({ textureUrl: e }), Y();
  }
  get dataUrl() {
    return this.$$.ctx[9];
  }
  set dataUrl(e) {
    this.$$set({ dataUrl: e }), Y();
  }
  get animation() {
    return this.$$.ctx[10];
  }
  set animation(e) {
    this.$$set({ animation: e }), Y();
  }
  get loop() {
    return this.$$.ctx[11];
  }
  set loop(e) {
    this.$$set({ loop: e }), Y();
  }
  get autoplay() {
    return this.$$.ctx[12];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), Y();
  }
  get fps() {
    return this.$$.ctx[13];
  }
  set fps(e) {
    this.$$set({ fps: e }), Y();
  }
  get filter() {
    return this.$$.ctx[14];
  }
  set filter(e) {
    this.$$set({ filter: e }), Y();
  }
  get alphaTest() {
    return this.$$.ctx[1];
  }
  set alphaTest(e) {
    this.$$set({ alphaTest: e }), Y();
  }
  get delay() {
    return this.$$.ctx[15];
  }
  set delay(e) {
    this.$$set({ delay: e }), Y();
  }
  get transparent() {
    return this.$$.ctx[2];
  }
  set transparent(e) {
    this.$$set({ transparent: e }), Y();
  }
  get flipX() {
    return this.$$.ctx[16];
  }
  set flipX(e) {
    this.$$set({ flipX: e }), Y();
  }
  get startFrame() {
    return this.$$.ctx[17];
  }
  set startFrame(e) {
    this.$$set({ startFrame: e }), Y();
  }
  get endFrame() {
    return this.$$.ctx[18];
  }
  set endFrame(e) {
    this.$$set({ endFrame: e }), Y();
  }
  get rows() {
    return this.$$.ctx[19];
  }
  set rows(e) {
    this.$$set({ rows: e }), Y();
  }
  get columns() {
    return this.$$.ctx[20];
  }
  set columns(e) {
    this.$$set({ columns: e }), Y();
  }
  get totalFrames() {
    return this.$$.ctx[21];
  }
  set totalFrames(e) {
    this.$$set({ totalFrames: e }), Y();
  }
  get is() {
    return this.$$.ctx[3];
  }
  set is(e) {
    this.$$set({ is: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), Y();
  }
  get play() {
    return this.$$.ctx[22];
  }
  get pause() {
    return this.$$.ctx[23];
  }
}
xt(dw, { textureUrl: {}, dataUrl: {}, animation: {}, loop: { type: "Boolean" }, autoplay: { type: "Boolean" }, fps: {}, filter: {}, alphaTest: {}, delay: {}, transparent: { type: "Boolean" }, flipX: { type: "Boolean" }, startFrame: {}, endFrame: {}, rows: {}, columns: {}, totalFrames: {}, is: {}, ref: {} }, [], ["play", "pause"], !0);
const pw = (s) => ({ ref: s & /*ref*/
4096 }), YA = (s) => ({ ref: (
  /*ref*/
  s[12]
) });
function Aw(s) {
  let e, t, n, i, r;
  e = new qe.EdgesGeometry({
    props: {
      args: [
        /*geometry*/
        s[4],
        /*thresholdAngle*/
        s[0]
      ]
    }
  }), n = new qe.LineBasicMaterial({ props: { color: (
    /*color*/
    s[1]
  ) } });
  const a = (
    /*#slots*/
    s[7].default
  ), o = At(
    a,
    s,
    /*$$scope*/
    s[9],
    YA
  );
  return {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment), i = Pt(), o && o.c();
    },
    m(c, l) {
      Oe(e, c, l), st(c, t, l), Oe(n, c, l), st(c, i, l), o && o.m(c, l), r = !0;
    },
    p(c, l) {
      const u = {};
      l & /*thresholdAngle*/
      1 && (u.args = [
        /*geometry*/
        c[4],
        /*thresholdAngle*/
        c[0]
      ]), e.$set(u);
      const h = {};
      l & /*color*/
      2 && (h.color = /*color*/
      c[1]), n.$set(h), o && o.p && (!r || l & /*$$scope, ref*/
      4608) && mt(
        o,
        a,
        c,
        /*$$scope*/
        c[9],
        r ? gt(
          a,
          /*$$scope*/
          c[9],
          l,
          pw
        ) : _t(
          /*$$scope*/
          c[9]
        ),
        YA
      );
    },
    i(c) {
      r || (ae(e.$$.fragment, c), ae(n.$$.fragment, c), ae(o, c), r = !0);
    },
    o(c) {
      ue(e.$$.fragment, c), ue(n.$$.fragment, c), ue(o, c), r = !1;
    },
    d(c) {
      c && (rt(t), rt(i)), Qe(e, c), Qe(n, c), o && o.d(c);
    }
  };
}
function gw(s) {
  let e, t;
  const n = [
    /*$$restProps*/
    s[6]
  ];
  let i = {
    $$slots: {
      default: [
        Aw,
        ({ ref: r }) => ({ 12: r }),
        ({ ref: r }) => r ? 4096 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe.LineSegments({ props: i }), s[8](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*$$restProps*/
      64 ? Qt(n, [qt(
        /*$$restProps*/
        r[6]
      )]) : {};
      a & /*$$scope, ref, color, thresholdAngle*/
      4611 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
function mw(s, e, t) {
  const n = ["thresholdAngle", "color"];
  let i = at(e, n), r, a, { $$slots: o = {}, $$scope: c } = e, { thresholdAngle: l = void 0 } = e, { color: u = void 0 } = e;
  const h = Fs();
  if ($e(s, h, (p) => t(10, r = p)), !r || r.type !== "Mesh")
    throw new Error("Edges: component must be a child of a Mesh");
  const f = r, d = "clone" in f.geometry ? f.geometry.clone() : f.geometry, A = An();
  $e(s, A, (p) => t(2, a = p));
  function m(p) {
    Mt[p ? "unshift" : "push"](() => {
      a = p, A.set(a);
    });
  }
  return s.$$set = (p) => {
    e = Ve(Ve({}, e), Kt(p)), t(6, i = at(e, n)), "thresholdAngle" in p && t(0, l = p.thresholdAngle), "color" in p && t(1, u = p.color), "$$scope" in p && t(9, c = p.$$scope);
  }, [
    l,
    u,
    a,
    h,
    d,
    A,
    i,
    o,
    m,
    c
  ];
}
class _w extends St {
  constructor(e) {
    super(), Et(this, e, mw, gw, pt, { thresholdAngle: 0, color: 1 });
  }
  get thresholdAngle() {
    return this.$$.ctx[0];
  }
  set thresholdAngle(e) {
    this.$$set({ thresholdAngle: e }), Y();
  }
  get color() {
    return this.$$.ctx[1];
  }
  set color(e) {
    this.$$set({ color: e }), Y();
  }
}
xt(_w, { thresholdAngle: {}, color: {} }, ["default"], [], !0);
const bw = () => {
  const s = vi();
  return {
    hasEventListeners: (t) => {
      const n = s.$$.callbacks;
      return t in n && n[t].length > 0;
    }
  };
}, $o = new P(), Pd = new P(), yw = new P(), W_ = (s) => s.isOrthographicCamera, q_ = (s) => s.isPerspectiveCamera, vw = (s) => W_(s) || q_(s), Ew = (s, e, t) => {
  const n = $o.setFromMatrixPosition(s.matrixWorld);
  n.project(e);
  const i = t.width / 2, r = t.height / 2;
  return [n.x * i + i, -(n.y * r) + r];
}, xw = (s, e) => {
  const t = $o.setFromMatrixPosition(s.matrixWorld), n = Pd.setFromMatrixPosition(e.matrixWorld), i = t.sub(n), r = e.getWorldDirection(yw);
  return i.angleTo(r) > Math.PI / 2;
}, Sw = (s, e, t, n) => {
  const i = $o.setFromMatrixPosition(s.matrixWorld), r = i.clone();
  r.project(e), t.setFromCamera(r, e);
  const a = t.intersectObjects(n, !0);
  if (a.length) {
    const o = a[0].distance;
    return i.distanceTo(t.ray.origin) < o;
  }
  return !0;
}, Cw = (s, e) => {
  if (W_(e))
    return e.zoom;
  if (q_(e)) {
    const t = $o.setFromMatrixPosition(s.matrixWorld), n = Pd.setFromMatrixPosition(e.matrixWorld), i = e.fov * Math.PI / 180, r = t.distanceTo(n);
    return 1 / (2 * Math.tan(i / 2) * r);
  } else
    return 1;
}, Mw = (s, e, t) => {
  if (vw(e)) {
    const n = $o.setFromMatrixPosition(s.matrixWorld), i = Pd.setFromMatrixPosition(e.matrixWorld), r = n.distanceTo(i), a = (t[1] - t[0]) / (e.far - e.near), o = t[1] - a * e.far;
    return Math.round(a * r + o);
  }
}, Uf = (s) => Math.abs(s) < 1e-10 ? 0 : s, X_ = (s, e, t = "") => {
  let n = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    n += Uf(e[i] * s.elements[i]) + (i !== 15 ? "," : ")");
  return t + n;
}, Iw = /* @__PURE__ */ ((s) => (e) => X_(e, s))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), ww = /* @__PURE__ */ ((s) => (e, t) => X_(e, s(t), "translate(-50%,-50%)"))((s) => [
  1 / s,
  1 / s,
  1 / s,
  1,
  -1 / s,
  -1 / s,
  -1 / s,
  -1,
  1 / s,
  1 / s,
  1 / s,
  1,
  1,
  1,
  1,
  1
]), Tw = (s) => s.split(/(?=[A-Z])/).join("-").toLowerCase(), zi = (s) => Object.entries(s).filter(([e, t]) => !!t).map(([e, t]) => `${Tw(e)}: ${t}`).join("; "), fi = (s, e) => {
  s.update((t) => ({
    ...t,
    ...e
  }));
}, Bw = (s) => ({ ref: s[0] & /*ref*/
4 }), jA = (s) => ({ ref: (
  /*ref*/
  s[2]
) });
function Rw(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].threlte
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[46],
    jA
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[0] & /*ref*/
      4 | r[1] & /*$$scope*/
      32768) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? gt(
          t,
          /*$$scope*/
          i[46],
          r,
          Bw
        ) : _t(
          /*$$scope*/
          i[46]
        ),
        jA
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Dw(s) {
  let e = (
    /*as*/
    s[1]
  ), t, n, i = (
    /*as*/
    s[1] && wh(s)
  );
  return {
    c() {
      i && i.c(), t = yi();
    },
    m(r, a) {
      i && i.m(r, a), st(r, t, a), n = !0;
    },
    p(r, a) {
      /*as*/
      r[1] ? e ? pt(
        e,
        /*as*/
        r[1]
      ) ? (i.d(1), i = wh(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : i.p(r, a) : (i = wh(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : e && (i.d(1), i = null, e = /*as*/
      r[1]);
    },
    i(r) {
      n || (ae(i, r), n = !0);
    },
    o(r) {
      ue(i, r), n = !1;
    },
    d(r) {
      r && rt(t), i && i.d(r);
    }
  };
}
function Lw(s) {
  let e = (
    /*as*/
    s[1]
  ), t, n, i = (
    /*as*/
    s[1] && Th(s)
  );
  return {
    c() {
      i && i.c(), t = yi();
    },
    m(r, a) {
      i && i.m(r, a), st(r, t, a), n = !0;
    },
    p(r, a) {
      /*as*/
      r[1] ? e ? pt(
        e,
        /*as*/
        r[1]
      ) ? (i.d(1), i = Th(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : i.p(r, a) : (i = Th(r), e = /*as*/
      r[1], i.c(), i.m(t.parentNode, t)) : e && (i.d(1), i = null, e = /*as*/
      r[1]);
    },
    i(r) {
      n || (ae(i, r), n = !0);
    },
    o(r) {
      ue(i, r), n = !1;
    },
    d(r) {
      r && rt(t), i && i.d(r);
    }
  };
}
function JA(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[46],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[1] & /*$$scope*/
      32768) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? gt(
          t,
          /*$$scope*/
          i[46],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[46]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function wh(s) {
  let e, t, n, i, r, a, o, c = (
    /*showEl*/
    s[6] && JA(s)
  ), l = [
    {
      style: i = zi(
        /*$noTransformElStyles*/
        s[11]
      )
    }
  ], u = {};
  for (let h = 0; h < l.length; h += 1)
    u = Ve(u, l[h]);
  return {
    c() {
      e = Rr(
        /*as*/
        s[1]
      ), t = Rr("div"), c && c.c(), Hi(t, "style", n = zi(
        /*$noTransformDivStyles*/
        s[12]
      )), yl(
        /*as*/
        s[1]
      )(e, u);
    },
    m(h, f) {
      st(h, e, f), bl(e, t), c && c.m(t, null), s[45](e), r = !0, a || (o = [
        _l(
          /*portalAction*/
          s[23].call(null, e)
        ),
        _l(
          /*buildDefaultNonTransformStyles*/
          s[22].call(null, e)
        )
      ], a = !0);
    },
    p(h, f) {
      /*showEl*/
      h[6] ? c ? (c.p(h, f), f[0] & /*showEl*/
      64 && ae(c, 1)) : (c = JA(h), c.c(), ae(c, 1), c.m(t, null)) : c && (ai(), ue(c, 1, 1, () => {
        c = null;
      }), oi()), (!r || f[0] & /*$noTransformDivStyles*/
      4096 && n !== (n = zi(
        /*$noTransformDivStyles*/
        h[12]
      ))) && Hi(t, "style", n), yl(
        /*as*/
        h[1]
      )(e, u = Qt(l, [
        (!r || f[0] & /*$noTransformElStyles*/
        2048 && i !== (i = zi(
          /*$noTransformElStyles*/
          h[11]
        ))) && { style: i }
      ]));
    },
    i(h) {
      r || (ae(c), r = !0);
    },
    o(h) {
      ue(c), r = !1;
    },
    d(h) {
      h && rt(e), c && c.d(), s[45](null), a = !1, Bs(o);
    }
  };
}
function KA(s) {
  let e;
  const t = (
    /*#slots*/
    s[40].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[46],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r[1] & /*$$scope*/
      32768) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[46],
        e ? gt(
          t,
          /*$$scope*/
          i[46],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[46]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Th(s) {
  let e, t, n, i, r, a, o, c, l, u = (
    /*showEl*/
    s[6] && KA(s)
  ), h = [
    {
      style: a = zi(
        /*$transformElStyles*/
        s[8]
      )
    }
  ], f = {};
  for (let d = 0; d < h.length; d += 1)
    f = Ve(f, h[d]);
  return {
    c() {
      e = Rr(
        /*as*/
        s[1]
      ), t = Rr("div"), n = Rr("div"), u && u.c(), Hi(n, "style", i = zi(
        /*$transformInnerRefStyles*/
        s[10]
      )), Hi(t, "style", r = zi(
        /*$transformOuterRefStyles*/
        s[9]
      )), yl(
        /*as*/
        s[1]
      )(e, f);
    },
    m(d, A) {
      st(d, e, A), bl(e, t), bl(t, n), u && u.m(n, null), s[42](n), s[43](t), s[44](e), o = !0, c || (l = _l(
        /*portalAction*/
        s[23].call(null, e)
      ), c = !0);
    },
    p(d, A) {
      /*showEl*/
      d[6] ? u ? (u.p(d, A), A[0] & /*showEl*/
      64 && ae(u, 1)) : (u = KA(d), u.c(), ae(u, 1), u.m(n, null)) : u && (ai(), ue(u, 1, 1, () => {
        u = null;
      }), oi()), (!o || A[0] & /*$transformInnerRefStyles*/
      1024 && i !== (i = zi(
        /*$transformInnerRefStyles*/
        d[10]
      ))) && Hi(n, "style", i), (!o || A[0] & /*$transformOuterRefStyles*/
      512 && r !== (r = zi(
        /*$transformOuterRefStyles*/
        d[9]
      ))) && Hi(t, "style", r), yl(
        /*as*/
        d[1]
      )(e, f = Qt(h, [
        (!o || A[0] & /*$transformElStyles*/
        256 && a !== (a = zi(
          /*$transformElStyles*/
          d[8]
        ))) && { style: a }
      ]));
    },
    i(d) {
      o || (ae(u), o = !0);
    },
    o(d) {
      ue(u), o = !1;
    },
    d(d) {
      d && rt(e), u && u.d(), s[42](null), s[43](null), s[44](null), c = !1, l();
    }
  };
}
function Pw(s) {
  let e, t, n, i, r, a;
  const o = [
    { is: (
      /*ref*/
      s[2]
    ) },
    /*$$restProps*/
    s[25]
  ];
  let c = {
    $$slots: {
      default: [Rw, ({ ref: f }) => ({ 2: f }), ({ ref: f }) => [f ? 4 : 0]]
    },
    $$scope: { ctx: s }
  };
  for (let f = 0; f < o.length; f += 1)
    c = Ve(c, o[f]);
  e = new qe({ props: c }), s[41](e);
  const l = [Lw, Dw], u = [];
  function h(f, d) {
    return (
      /*transform*/
      f[0] ? 0 : 1
    );
  }
  return n = h(s), i = u[n] = l[n](s), {
    c() {
      ze(e.$$.fragment), t = Pt(), i.c(), r = yi();
    },
    m(f, d) {
      Oe(e, f, d), st(f, t, d), u[n].m(f, d), st(f, r, d), a = !0;
    },
    p(f, d) {
      const A = d[0] & /*ref, $$restProps*/
      33554436 ? Qt(o, [
        d[0] & /*ref*/
        4 && { is: (
          /*ref*/
          f[2]
        ) },
        d[0] & /*$$restProps*/
        33554432 && qt(
          /*$$restProps*/
          f[25]
        )
      ]) : {};
      d[0] & /*ref*/
      4 | d[1] & /*$$scope*/
      32768 && (A.$$scope = { dirty: d, ctx: f }), e.$set(A);
      let m = n;
      n = h(f), n === m ? u[n].p(f, d) : (ai(), ue(u[m], 1, 1, () => {
        u[m] = null;
      }), oi(), i = u[n], i ? i.p(f, d) : (i = u[n] = l[n](f), i.c()), ae(i, 1), i.m(r.parentNode, r));
    },
    i(f) {
      a || (ae(e.$$.fragment, f), ae(i), a = !0);
    },
    o(f) {
      ue(e.$$.fragment, f), ue(i), a = !1;
    },
    d(f) {
      f && (rt(t), rt(r)), s[41](null), Qe(e, f), u[n].d(f);
    }
  };
}
function Uw(s, e, t) {
  const n = [
    "transform",
    "calculatePosition",
    "eps",
    "occlude",
    "zIndexRange",
    "sprite",
    "pointerEvents",
    "center",
    "fullscreen",
    "distanceFactor",
    "as",
    "portal",
    "ref",
    "visible"
  ];
  let i = at(e, n), r, a, o, c, l, u, h, f, d, A, { $$slots: m = {}, $$scope: p } = e, { transform: g = !1 } = e, { calculatePosition: _ = Ew } = e, { eps: b = 1e-3 } = e, { occlude: y = !1 } = e, { zIndexRange: v = [16777271, 0] } = e, { sprite: x = !1 } = e, { pointerEvents: S = "auto" } = e, { center: I = !1 } = e, { fullscreen: E = !1 } = e, { distanceFactor: M = void 0 } = e, { as: T = "div" } = e, { portal: D = void 0 } = e;
  const F = Ji();
  let { ref: C = new Un() } = e;
  const { renderer: R, camera: O, scene: V, size: q } = sn();
  $e(s, O, (G) => t(50, a = G)), $e(s, q, (G) => t(37, r = G));
  const z = (G) => G.isPerspectiveCamera || G.isOrthographicCamera, X = () => {
    if (!z(a))
      throw new Error("Only PerspectiveCamera or OrthographicCamera supported for component <HTML>");
    return a;
  }, w = new Zo();
  let N = [0, 0], H = 0, { visible: j = !0 } = e, $ = document.createElement(T), ce, ee;
  const { hasEventListeners: le } = bw();
  let Z = typeof y == "boolean" && y === !0 ? [V] : Array.isArray(y) ? y : void 0;
  const he = Vn(q, (G) => G.width / 2);
  $e(s, he, (G) => t(39, c = G));
  const _e = Vn(q, (G) => G.height / 2);
  $e(s, _e, (G) => t(38, o = G));
  let U = {
    common: { el: vt({}) },
    transform: {
      el: vt({
        position: "absolute",
        top: "0",
        left: "0",
        pointerEvents: "none",
        overflow: "hidden",
        display: "block",
        width: `${r.width}px`,
        height: `${r.height}px`
      }),
      outerRef: vt({
        position: "absolute",
        top: "0",
        left: "0",
        width: `${r.width}px`,
        height: `${r.height}px`,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      }),
      innerRef: vt({ position: "absolute", pointerEvents: S })
    },
    noTransform: {
      el: vt({}),
      div: vt({
        position: "absolute",
        transform: I ? "translate3d(-50%,-50%,0)" : "none",
        top: E ? `${-o}px` : void 0,
        left: E ? `${-c}px` : void 0,
        width: E ? `${r.width}px` : void 0,
        height: E ? `${r.height}px` : void 0
      })
    }
  };
  const ye = Vn([U.transform.el, U.common.el], ([G, Ce]) => ({ ...G, ...Ce }));
  $e(s, ye, (G) => t(8, u = G));
  const ie = Vn(U.transform.outerRef, (G) => G);
  $e(s, ie, (G) => t(9, h = G));
  const re = Vn(U.transform.innerRef, (G) => G);
  $e(s, re, (G) => t(10, f = G));
  const te = Vn(U.noTransform.el, (G) => G);
  $e(s, te, (G) => t(11, d = G));
  const Ie = Vn(U.noTransform.div, (G) => G);
  $e(s, Ie, (G) => t(12, A = G));
  const se = () => {
    let G = !0, Ce = C.parent;
    e:
      for (; Ce; ) {
        if ("visible" in Ce && !Ce.visible) {
          G = !1;
          break e;
        }
        Ce = Ce.parent;
      }
    return G;
  };
  let K = se();
  bi(async () => {
    t(6, K = se());
    const G = X();
    G.updateMatrixWorld(), C.updateWorldMatrix(!0, !1);
    const Ce = g ? N : _(C, G, r);
    if (g || Math.abs(H - G.zoom) > b || Math.abs(N[0] - Ce[0]) > b || Math.abs(N[1] - Ce[1]) > b) {
      const Se = xw(C, G), De = j;
      if (Z) {
        const Q = Sw(C, G, w, Z);
        t(26, j = Q && !Se);
      } else
        t(26, j = !Se);
      if (De !== j && (le("visibilitychange") ? F("visibilitychange", j) : fi(U.common.el, { display: j ? "block" : "none" })), fi(U.common.el, {
        zIndex: `${Mw(C, G, v)}`
      }), g) {
        const Q = G.projectionMatrix.elements[5] * o, { isOrthographicCamera: Me, top: pe, left: Le, bottom: Fe, right: Ge } = G;
        let Ue = C.matrixWorld;
        if (x && (Ue = G.matrixWorldInverse.clone().transpose().copyPosition(Ue).scale(C.scale), Ue.elements[3] = Ue.elements[7] = Ue.elements[11] = 0, Ue.elements[15] = 1), fi(U.transform.el, {
          perspective: Me ? "" : `${Q}px`
        }), ce && ee) {
          const we = Me ? `scale(${Q}) translate(${Uf(-(Ge + Le) / 2)}px,${Uf((pe + Fe) / 2)}px)` : `translateZ(${Q}px)`, Ye = Iw(G.matrixWorldInverse);
          fi(U.transform.outerRef, {
            transform: `${we}${Ye}translate(${c}px, ${o}px)`
          }), fi(U.transform.innerRef, {
            transform: ww(Ue, 1 / ((M || 10) / 400))
          });
        }
      } else {
        const Q = M === void 0 ? 1 : Cw(C, G) * M;
        fi(U.noTransform.el, {
          transform: `translate3d(${Ce[0]}px, ${Ce[1]}px, 0) scale(${Q})`
        });
      }
      N = Ce, H = G.zoom;
    }
  });
  const ve = (G) => {
    if (!C || g)
      return;
    V.updateMatrixWorld();
    const Ce = _(C, a, r);
    fi(U.noTransform.el, {
      position: "absolute",
      top: "0",
      left: "0",
      transform: `translate3d(${Ce[0]}px, ${Ce[1]}px, 0)`,
      transformOrigin: "0 0"
    });
  }, fe = (G) => {
    const Ce = D ?? R.domElement.parentElement;
    if (!Ce) {
      console.warn("HTML: target is undefined.");
      return;
    }
    return Ce.appendChild(G), {
      destroy: () => {
        G.parentNode && G.parentNode.removeChild(G);
      }
    };
  }, oe = An();
  $e(s, oe, (G) => t(7, l = G));
  function L(G) {
    Mt[G ? "unshift" : "push"](() => {
      l = G, oe.set(l);
    });
  }
  function B(G) {
    Mt[G ? "unshift" : "push"](() => {
      ee = G, t(5, ee);
    });
  }
  function W(G) {
    Mt[G ? "unshift" : "push"](() => {
      ce = G, t(4, ce);
    });
  }
  function de(G) {
    Mt[G ? "unshift" : "push"](() => {
      $ = G, t(3, $);
    });
  }
  function Ae(G) {
    Mt[G ? "unshift" : "push"](() => {
      $ = G, t(3, $);
    });
  }
  return s.$$set = (G) => {
    e = Ve(Ve({}, e), Kt(G)), t(25, i = at(e, n)), "transform" in G && t(0, g = G.transform), "calculatePosition" in G && t(27, _ = G.calculatePosition), "eps" in G && t(28, b = G.eps), "occlude" in G && t(29, y = G.occlude), "zIndexRange" in G && t(30, v = G.zIndexRange), "sprite" in G && t(31, x = G.sprite), "pointerEvents" in G && t(32, S = G.pointerEvents), "center" in G && t(33, I = G.center), "fullscreen" in G && t(34, E = G.fullscreen), "distanceFactor" in G && t(35, M = G.distanceFactor), "as" in G && t(1, T = G.as), "portal" in G && t(36, D = G.portal), "ref" in G && t(2, C = G.ref), "visible" in G && t(26, j = G.visible), "$$scope" in G && t(46, p = G.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*occlude*/
    536870912 && (Z = typeof y == "boolean" && y === !0 ? [V] : Array.isArray(y) ? y : void 0), s.$$.dirty[1] & /*$size*/
    64 && fi(U.transform.el, {
      width: `${r.width}px`,
      height: `${r.height}px`
    }), s.$$.dirty[1] & /*$size*/
    64 && fi(U.transform.outerRef, {
      width: `${r.width}px`,
      height: `${r.height}px`
    }), s.$$.dirty[1] & /*pointerEvents*/
    2 && fi(U.transform.innerRef, { pointerEvents: S }), s.$$.dirty[1] & /*pointerEvents*/
    2 && fi(U.noTransform.div, { pointerEvents: S }), s.$$.dirty[1] & /*center*/
    4 && fi(U.noTransform.div, {
      transform: I ? "translate3d(-50%, -50%, 0)" : "none"
    }), s.$$.dirty[1] & /*fullscreen, $heightHalf, $widthHalf, $size*/
    456 && fi(U.noTransform.div, {
      top: E ? `${-o}px` : void 0,
      left: E ? `${-c}px` : void 0,
      width: E ? `${r.width}px` : void 0,
      height: E ? `${r.height}px` : void 0
    });
  }, [
    g,
    T,
    C,
    $,
    ce,
    ee,
    K,
    l,
    u,
    h,
    f,
    d,
    A,
    O,
    q,
    he,
    _e,
    ye,
    ie,
    re,
    te,
    Ie,
    ve,
    fe,
    oe,
    i,
    j,
    _,
    b,
    y,
    v,
    x,
    S,
    I,
    E,
    M,
    D,
    r,
    o,
    c,
    m,
    L,
    B,
    W,
    de,
    Ae,
    p
  ];
}
class Fw extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      Uw,
      Pw,
      pt,
      {
        transform: 0,
        calculatePosition: 27,
        eps: 28,
        occlude: 29,
        zIndexRange: 30,
        sprite: 31,
        pointerEvents: 32,
        center: 33,
        fullscreen: 34,
        distanceFactor: 35,
        as: 1,
        portal: 36,
        ref: 2,
        visible: 26
      },
      null,
      [-1, -1]
    );
  }
  get transform() {
    return this.$$.ctx[0];
  }
  set transform(e) {
    this.$$set({ transform: e }), Y();
  }
  get calculatePosition() {
    return this.$$.ctx[27];
  }
  set calculatePosition(e) {
    this.$$set({ calculatePosition: e }), Y();
  }
  get eps() {
    return this.$$.ctx[28];
  }
  set eps(e) {
    this.$$set({ eps: e }), Y();
  }
  get occlude() {
    return this.$$.ctx[29];
  }
  set occlude(e) {
    this.$$set({ occlude: e }), Y();
  }
  get zIndexRange() {
    return this.$$.ctx[30];
  }
  set zIndexRange(e) {
    this.$$set({ zIndexRange: e }), Y();
  }
  get sprite() {
    return this.$$.ctx[31];
  }
  set sprite(e) {
    this.$$set({ sprite: e }), Y();
  }
  get pointerEvents() {
    return this.$$.ctx[32];
  }
  set pointerEvents(e) {
    this.$$set({ pointerEvents: e }), Y();
  }
  get center() {
    return this.$$.ctx[33];
  }
  set center(e) {
    this.$$set({ center: e }), Y();
  }
  get fullscreen() {
    return this.$$.ctx[34];
  }
  set fullscreen(e) {
    this.$$set({ fullscreen: e }), Y();
  }
  get distanceFactor() {
    return this.$$.ctx[35];
  }
  set distanceFactor(e) {
    this.$$set({ distanceFactor: e }), Y();
  }
  get as() {
    return this.$$.ctx[1];
  }
  set as(e) {
    this.$$set({ as: e }), Y();
  }
  get portal() {
    return this.$$.ctx[36];
  }
  set portal(e) {
    this.$$set({ portal: e }), Y();
  }
  get ref() {
    return this.$$.ctx[2];
  }
  set ref(e) {
    this.$$set({ ref: e }), Y();
  }
  get visible() {
    return this.$$.ctx[26];
  }
  set visible(e) {
    this.$$set({ visible: e }), Y();
  }
}
xt(Fw, { transform: { type: "Boolean" }, calculatePosition: {}, eps: {}, occlude: { type: "Boolean" }, zIndexRange: {}, sprite: { type: "Boolean" }, pointerEvents: {}, center: { type: "Boolean" }, fullscreen: { type: "Boolean" }, distanceFactor: {}, as: {}, portal: {}, ref: {}, visible: { type: "Boolean" } }, ["threlte", "default"], [], !0);
const kw = (s) => ({ ref: s & /*ref*/
32768 }), ZA = (s) => ({ ref: (
  /*ref*/
  s[15]
) });
function Nw(s) {
  let e;
  const t = (
    /*#slots*/
    s[11].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[12],
    ZA
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      36864) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[12],
        e ? gt(
          t,
          /*$$scope*/
          i[12],
          r,
          kw
        ) : _t(
          /*$$scope*/
          i[12]
        ),
        ZA
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Ow(s) {
  let e, t;
  const n = [
    { position: (
      /*floatPosition*/
      s[0]
    ) },
    { rotation: (
      /*floatRotation*/
      s[1]
    ) },
    /*$$restProps*/
    s[2]
  ];
  let i = {
    $$slots: {
      default: [
        Nw,
        ({ ref: r }) => ({ 15: r }),
        ({ ref: r }) => r ? 32768 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe.Group({ props: i }), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*floatPosition, floatRotation, $$restProps*/
      7 ? Qt(n, [
        a & /*floatPosition*/
        1 && { position: (
          /*floatPosition*/
          r[0]
        ) },
        a & /*floatRotation*/
        2 && { rotation: (
          /*floatRotation*/
          r[1]
        ) },
        a & /*$$restProps*/
        4 && qt(
          /*$$restProps*/
          r[2]
        )
      ]) : {};
      a & /*$$scope, ref*/
      36864 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      Qe(e, r);
    }
  };
}
function Qw(s, e, t) {
  const n = [
    "position",
    "rotation",
    "speed",
    "floatIntensity",
    "floatingRange",
    "rotationSpeed",
    "rotationIntensity",
    "seed"
  ];
  let i = at(e, n), { $$slots: r = {}, $$scope: a } = e, { position: o = 0 } = e, { rotation: c = 0 } = e, { speed: l = 1 } = e, { floatIntensity: u = 1 } = e, { floatingRange: h = [-0.1, 0.1] } = e, { rotationSpeed: f = 0 } = e, { rotationIntensity: d = 0 } = e, { seed: A = Math.random() * 1e4 } = e, m = A, p = Array.isArray(o) ? o : [o, o, o];
  const g = Cs.mapLinear;
  let _ = Array.isArray(c) ? c : [c, c, c];
  return bi((b) => {
    m += b;
    const y = Array.isArray(l) ? l : [l, l, l], v = Array.isArray(u) ? u : [u, u, u], x = h.length == 3 ? h : [[0, 0], h, [0, 0]];
    t(0, p = Array.isArray(o) ? o : [o, o, o]), t(0, p[0] = p[0] + g(Math.sin(m / 4 * y[0]) / 10, -0.1, 0.1, ...x[0]) * v[0], p), t(0, p[1] = p[1] + g(Math.sin(m / 4 * y[1]) / 10, -0.1, 0.1, ...x[1]) * v[1], p), t(0, p[2] = p[2] + g(Math.sin(m / 4 * y[2]) / 10, -0.1, 0.1, ...x[2]) * v[2], p), t(0, p);
    const S = Array.isArray(f) ? f : [f, f, f], I = Array.isArray(d) ? d : [d, d, d];
    t(1, _ = Array.isArray(c) ? c : [c, c, c]), t(1, _[0] += Math.cos(m / 4 * S[0]) / 8 * I[0], _), t(1, _[1] += Math.cos(m / 4 * S[1]) / 8 * I[1], _), t(1, _[2] += Math.cos(m / 4 * S[2]) / 8 * I[2], _);
  }), s.$$set = (b) => {
    e = Ve(Ve({}, e), Kt(b)), t(2, i = at(e, n)), "position" in b && t(3, o = b.position), "rotation" in b && t(4, c = b.rotation), "speed" in b && t(5, l = b.speed), "floatIntensity" in b && t(6, u = b.floatIntensity), "floatingRange" in b && t(7, h = b.floatingRange), "rotationSpeed" in b && t(8, f = b.rotationSpeed), "rotationIntensity" in b && t(9, d = b.rotationIntensity), "seed" in b && t(10, A = b.seed), "$$scope" in b && t(12, a = b.$$scope);
  }, [
    p,
    _,
    i,
    o,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    r,
    a
  ];
}
class Gw extends St {
  constructor(e) {
    super(), Et(this, e, Qw, Ow, pt, {
      position: 3,
      rotation: 4,
      speed: 5,
      floatIntensity: 6,
      floatingRange: 7,
      rotationSpeed: 8,
      rotationIntensity: 9,
      seed: 10
    });
  }
  get position() {
    return this.$$.ctx[3];
  }
  set position(e) {
    this.$$set({ position: e }), Y();
  }
  get rotation() {
    return this.$$.ctx[4];
  }
  set rotation(e) {
    this.$$set({ rotation: e }), Y();
  }
  get speed() {
    return this.$$.ctx[5];
  }
  set speed(e) {
    this.$$set({ speed: e }), Y();
  }
  get floatIntensity() {
    return this.$$.ctx[6];
  }
  set floatIntensity(e) {
    this.$$set({ floatIntensity: e }), Y();
  }
  get floatingRange() {
    return this.$$.ctx[7];
  }
  set floatingRange(e) {
    this.$$set({ floatingRange: e }), Y();
  }
  get rotationSpeed() {
    return this.$$.ctx[8];
  }
  set rotationSpeed(e) {
    this.$$set({ rotationSpeed: e }), Y();
  }
  get rotationIntensity() {
    return this.$$.ctx[9];
  }
  set rotationIntensity(e) {
    this.$$set({ rotationIntensity: e }), Y();
  }
  get seed() {
    return this.$$.ctx[10];
  }
  set seed(e) {
    this.$$set({ seed: e }), Y();
  }
}
xt(Gw, { position: {}, rotation: {}, speed: {}, floatIntensity: {}, floatingRange: {}, rotationSpeed: {}, rotationIntensity: {}, seed: {} }, ["default"], [], !0);
const zw = (s) => ({ ref: s & /*ref*/
67108864 }), $A = (s) => ({ ref: (
  /*ref*/
  s[26]
) });
function eg(s) {
  let e, t;
  const n = [
    { is: (
      /*scene*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [
        Hw,
        ({ ref: r }) => ({ 26: r }),
        ({ ref: r }) => r ? 67108864 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[18](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*scene, $$restProps*/
      9 ? Qt(n, [
        a & /*scene*/
        1 && { is: (
          /*scene*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      67633152 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[18](null), Qe(e, r);
    }
  };
}
function Hw(s) {
  let e;
  const t = (
    /*#slots*/
    s[17].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[19],
    $A
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      67633152) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[19],
        e ? gt(
          t,
          /*$$scope*/
          i[19],
          r,
          zw
        ) : _t(
          /*$$scope*/
          i[19]
        ),
        $A
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Vw(s) {
  let e, t, n = (
    /*scene*/
    s[0] && eg(s)
  );
  return {
    c() {
      n && n.c(), e = yi();
    },
    m(i, r) {
      n && n.m(i, r), st(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*scene*/
      i[0] ? n ? (n.p(i, r), r & /*scene*/
      1 && ae(n, 1)) : (n = eg(i), n.c(), ae(n, 1), n.m(e.parentNode, e)) : n && (ai(), ue(n, 1, 1, () => {
        n = null;
      }), oi());
    },
    i(i) {
      t || (ae(n), t = !0);
    },
    o(i) {
      ue(n), t = !1;
    },
    d(i) {
      i && rt(e), n && n.d(i);
    }
  };
}
function Ww(s, e, t) {
  const n = [
    "url",
    "useDraco",
    "useMeshopt",
    "ktxTranscoderPath",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes"
  ];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e;
  const c = An();
  $e(s, c, (C) => t(1, r = C));
  let { url: l } = e, { useDraco: u = !1 } = e, { useMeshopt: h = !1 } = e, { ktxTranscoderPath: f = void 0 } = e;
  const d = Ji();
  let { gltf: A = void 0 } = e, { scene: m = void 0 } = e, { animations: p = void 0 } = e, { asset: g = void 0 } = e, { cameras: _ = void 0 } = e, { scenes: b = void 0 } = e, { userData: y = void 0 } = e, { parser: v = void 0 } = e, { materials: x = void 0 } = e, { nodes: S = void 0 } = e;
  const I = H_({
    useDraco: u ? typeof u == "string" ? u : "https://www.gstatic.com/draco/v1/decoders/" : void 0,
    useMeshopt: h,
    ktxTranscoderPath: f
  }), E = (C) => {
    A && d("unload"), t(4, A = C), t(0, m = C.scene), t(5, p = C.animations), t(6, g = C.asset), t(7, _ = C.cameras), t(8, b = C.scenes), t(9, y = C.userData), t(10, v = C.parser), t(11, x = C.materials), t(12, S = C.nodes), d("load", A);
  }, M = (C) => {
    console.error(`Error loading GLTF: ${C.message}`), t(4, A = void 0), t(0, m = void 0), t(5, p = void 0), t(6, g = void 0), t(7, _ = void 0), t(8, b = void 0), t(9, y = void 0), t(10, v = void 0), t(12, S = void 0), t(11, x = void 0), d("error", C.message);
  }, T = Au(), D = async (C) => {
    try {
      const R = await T(I.load(C));
      E(R);
    } catch (R) {
      M(R);
    }
  };
  function F(C) {
    Mt[C ? "unshift" : "push"](() => {
      r = C, c.set(r);
    });
  }
  return s.$$set = (C) => {
    e = Ve(Ve({}, e), Kt(C)), t(3, i = at(e, n)), "url" in C && t(13, l = C.url), "useDraco" in C && t(14, u = C.useDraco), "useMeshopt" in C && t(15, h = C.useMeshopt), "ktxTranscoderPath" in C && t(16, f = C.ktxTranscoderPath), "gltf" in C && t(4, A = C.gltf), "scene" in C && t(0, m = C.scene), "animations" in C && t(5, p = C.animations), "asset" in C && t(6, g = C.asset), "cameras" in C && t(7, _ = C.cameras), "scenes" in C && t(8, b = C.scenes), "userData" in C && t(9, y = C.userData), "parser" in C && t(10, v = C.parser), "materials" in C && t(11, x = C.materials), "nodes" in C && t(12, S = C.nodes), "$$scope" in C && t(19, o = C.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*url*/
    8192 && D(l);
  }, [
    m,
    r,
    c,
    i,
    A,
    p,
    g,
    _,
    b,
    y,
    v,
    x,
    S,
    l,
    u,
    h,
    f,
    a,
    F,
    o
  ];
}
class qw extends St {
  constructor(e) {
    super(), Et(this, e, Ww, Vw, pt, {
      url: 13,
      useDraco: 14,
      useMeshopt: 15,
      ktxTranscoderPath: 16,
      gltf: 4,
      scene: 0,
      animations: 5,
      asset: 6,
      cameras: 7,
      scenes: 8,
      userData: 9,
      parser: 10,
      materials: 11,
      nodes: 12
    });
  }
  get url() {
    return this.$$.ctx[13];
  }
  set url(e) {
    this.$$set({ url: e }), Y();
  }
  get useDraco() {
    return this.$$.ctx[14];
  }
  set useDraco(e) {
    this.$$set({ useDraco: e }), Y();
  }
  get useMeshopt() {
    return this.$$.ctx[15];
  }
  set useMeshopt(e) {
    this.$$set({ useMeshopt: e }), Y();
  }
  get ktxTranscoderPath() {
    return this.$$.ctx[16];
  }
  set ktxTranscoderPath(e) {
    this.$$set({ ktxTranscoderPath: e }), Y();
  }
  get gltf() {
    return this.$$.ctx[4];
  }
  set gltf(e) {
    this.$$set({ gltf: e }), Y();
  }
  get scene() {
    return this.$$.ctx[0];
  }
  set scene(e) {
    this.$$set({ scene: e }), Y();
  }
  get animations() {
    return this.$$.ctx[5];
  }
  set animations(e) {
    this.$$set({ animations: e }), Y();
  }
  get asset() {
    return this.$$.ctx[6];
  }
  set asset(e) {
    this.$$set({ asset: e }), Y();
  }
  get cameras() {
    return this.$$.ctx[7];
  }
  set cameras(e) {
    this.$$set({ cameras: e }), Y();
  }
  get scenes() {
    return this.$$.ctx[8];
  }
  set scenes(e) {
    this.$$set({ scenes: e }), Y();
  }
  get userData() {
    return this.$$.ctx[9];
  }
  set userData(e) {
    this.$$set({ userData: e }), Y();
  }
  get parser() {
    return this.$$.ctx[10];
  }
  set parser(e) {
    this.$$set({ parser: e }), Y();
  }
  get materials() {
    return this.$$.ctx[11];
  }
  set materials(e) {
    this.$$set({ materials: e }), Y();
  }
  get nodes() {
    return this.$$.ctx[12];
  }
  set nodes(e) {
    this.$$set({ nodes: e }), Y();
  }
}
xt(qw, { url: {}, useDraco: { type: "Boolean" }, useMeshopt: { type: "Boolean" }, ktxTranscoderPath: {}, gltf: {}, scene: {}, animations: {}, asset: {}, cameras: {}, scenes: {}, userData: {}, parser: {}, materials: {}, nodes: {} }, ["default"], [], !0);
function tg(s) {
  s[55] = -20;
}
function Xw(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*xColor*/
          s[0],
          "X"
        )
      ),
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, xColor*/
      4097 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*xColor*/
        n[0],
        "X"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][0] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function Yw(s) {
  let e, t, n, i;
  return e = new qe({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new qe.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 1 : 0.5
      ),
      color: (
        /*xColor*/
        s[0]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 0 && /*p*/
        s[3][0] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[55]
      )
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), st(r, t, a), Oe(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][0] >= 0 ? 1 : 0.5), a[0] & /*xColor*/
      1 && (o.color = /*xColor*/
      r[0]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 0 && /*p*/
      r[3][0] < 0.75), n.$set(o);
    },
    i(r) {
      i || (ae(e.$$.fragment, r), ae(n.$$.fragment, r), i = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), ue(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && rt(t), Qe(e, r), Qe(n, r);
    }
  };
}
function jw(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*xColor*/
          s[0]
        )
      ),
      opacity: (
        /*p*/
        s[3][0] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, xColor*/
      4097 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*xColor*/
        n[0]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][0] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function Jw(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*yColor*/
          s[1],
          "Y"
        )
      ),
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, yColor*/
      4098 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*yColor*/
        n[1],
        "Y"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][1] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function Kw(s) {
  let e, t, n, i;
  return e = new qe({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new qe.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 1 : 0.5
      ),
      color: (
        /*yColor*/
        s[1]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 1 && /*p*/
        s[3][1] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[55]
      )
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), st(r, t, a), Oe(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][1] >= 0 ? 1 : 0.5), a[0] & /*yColor*/
      2 && (o.color = /*yColor*/
      r[1]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 1 && /*p*/
      r[3][1] < 0.75), n.$set(o);
    },
    i(r) {
      i || (ae(e.$$.fragment, r), ae(n.$$.fragment, r), i = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), ue(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && rt(t), Qe(e, r), Qe(n, r);
    }
  };
}
function Zw(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*yColor*/
          s[1]
        )
      ),
      opacity: (
        /*p*/
        s[3][1] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, yColor*/
      4098 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*yColor*/
        n[1]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][1] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function $w(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*zColor*/
          s[2],
          "Z"
        )
      ),
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 1 : 0.5
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, zColor*/
      4100 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*zColor*/
        n[2],
        "Z"
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][2] >= 0 ? 1 : 0.5), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function eT(s) {
  let e, t, n, i;
  return e = new qe({ props: { is: (
    /*stemGeometry*/
    s[15]
  ) } }), n = new qe.MeshBasicMaterial({
    props: {
      transparent: !0,
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 1 : 0.5
      ),
      color: (
        /*zColor*/
        s[2]
      ),
      polygonOffset: (
        /*usePolygonOffset*/
        s[10] && /*frontMostAxisIndex*/
        s[11] === 2 && /*p*/
        s[3][2] < 0.75
      ),
      polygonOffsetFactor: (
        /*polygonOffsetFactor*/
        s[55]
      )
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), st(r, t, a), Oe(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a[0] & /*p*/
      8 && (o.opacity = /*p*/
      r[3][2] >= 0 ? 1 : 0.5), a[0] & /*zColor*/
      4 && (o.color = /*zColor*/
      r[2]), a[0] & /*usePolygonOffset, frontMostAxisIndex, p*/
      3080 && (o.polygonOffset = /*usePolygonOffset*/
      r[10] && /*frontMostAxisIndex*/
      r[11] === 2 && /*p*/
      r[3][2] < 0.75), n.$set(o);
    },
    i(r) {
      i || (ae(e.$$.fragment, r), ae(n.$$.fragment, r), i = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), ue(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && rt(t), Qe(e, r), Qe(n, r);
    }
  };
}
function tT(s) {
  let e, t;
  return e = new qe.SpriteMaterial({
    props: {
      map: (
        /*getSpriteTexture*/
        s[14](
          /*textureSize*/
          s[12],
          /*zColor*/
          s[2]
        )
      ),
      opacity: (
        /*p*/
        s[3][2] >= 0 ? 0.5 : 1
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*textureSize, zColor*/
      4100 && (r.map = /*getSpriteTexture*/
      n[14](
        /*textureSize*/
        n[12],
        /*zColor*/
        n[2]
      )), i[0] & /*p*/
      8 && (r.opacity = /*p*/
      n[3][2] >= 0 ? 0.5 : 1), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function nT(s) {
  tg(s);
  let e, t, n, i, r, a, o, c, l, u, h, f, d, A, m, p, g, _, b, y, v, x, S, I;
  function E(w) {
    s[27](w);
  }
  let M = {
    renderOrder: 1,
    "position.x": 1,
    "userData.targetPosition": [1, 0, 0],
    "userData.targetEuler": [0, Math.PI * 0.5, 0],
    $$slots: { default: [Xw] },
    $$scope: { ctx: s }
  };
  /*posX*/
  s[4] !== void 0 && (M.ref = /*posX*/
  s[4]), e = new qe.Sprite({ props: M }), Mt.push(() => Gi(e, "ref", E)), i = new qe.Mesh({
    props: {
      "position.x": 0.39,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 0 ? -1 : 0
      ),
      $$slots: { default: [Yw] },
      $$scope: { ctx: s }
    }
  });
  function T(w) {
    s[28](w);
  }
  let D = {
    renderOrder: 1,
    "position.x": -1,
    scale: 0.8,
    "userData.targetPosition": [-1, 0, 0],
    "userData.targetEuler": [0, -Math.PI * 0.5, 0],
    $$slots: { default: [jw] },
    $$scope: { ctx: s }
  };
  /*negX*/
  s[7] !== void 0 && (D.ref = /*negX*/
  s[7]), a = new qe.Sprite({ props: D }), Mt.push(() => Gi(a, "ref", T));
  function F(w) {
    s[29](w);
  }
  let C = {
    renderOrder: 1,
    "position.y": 1,
    "userData.targetPosition": [0, 1, 0],
    "userData.targetEuler": [-Math.PI * 0.5, 0, 0],
    $$slots: { default: [Jw] },
    $$scope: { ctx: s }
  };
  /*posY*/
  s[5] !== void 0 && (C.ref = /*posY*/
  s[5]), l = new qe.Sprite({ props: C }), Mt.push(() => Gi(l, "ref", F)), f = new qe.Mesh({
    props: {
      "position.y": 0.39,
      "rotation.z": Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 1 ? -1 : 0
      ),
      $$slots: { default: [Kw] },
      $$scope: { ctx: s }
    }
  });
  function R(w) {
    s[30](w);
  }
  let O = {
    renderOrder: 1,
    "position.y": -1,
    scale: 0.8,
    "userData.targetPosition": [0, -1, 0],
    "userData.targetEuler": [Math.PI * 0.5, 0, 0],
    $$slots: { default: [Zw] },
    $$scope: { ctx: s }
  };
  /*negY*/
  s[8] !== void 0 && (O.ref = /*negY*/
  s[8]), A = new qe.Sprite({ props: O }), Mt.push(() => Gi(A, "ref", R));
  function V(w) {
    s[31](w);
  }
  let q = {
    renderOrder: 1,
    "position.z": 1,
    "userData.targetPosition": [0, 0, 1],
    "userData.targetEuler": [0, 0, 0],
    $$slots: { default: [$w] },
    $$scope: { ctx: s }
  };
  /*posZ*/
  s[6] !== void 0 && (q.ref = /*posZ*/
  s[6]), g = new qe.Sprite({ props: q }), Mt.push(() => Gi(g, "ref", V)), y = new qe.Mesh({
    props: {
      "position.z": 0.39,
      "rotation.y": -Math.PI / 2,
      renderOrder: (
        /*frontMostAxisIndex*/
        s[11] === 2 ? -1 : 0
      ),
      $$slots: { default: [eT] },
      $$scope: { ctx: s }
    }
  });
  function z(w) {
    s[32](w);
  }
  let X = {
    renderOrder: 1,
    "position.z": -1,
    scale: 0.8,
    "userData.targetPosition": [0, 0, -1],
    "userData.targetEuler": [0, Math.PI, 0],
    $$slots: { default: [tT] },
    $$scope: { ctx: s }
  };
  return (
    /*negZ*/
    s[9] !== void 0 && (X.ref = /*negZ*/
    s[9]), x = new qe.Sprite({ props: X }), Mt.push(() => Gi(x, "ref", z)), {
      c() {
        ze(e.$$.fragment), n = Pt(), ze(i.$$.fragment), r = Pt(), ze(a.$$.fragment), c = Pt(), ze(l.$$.fragment), h = Pt(), ze(f.$$.fragment), d = Pt(), ze(A.$$.fragment), p = Pt(), ze(g.$$.fragment), b = Pt(), ze(y.$$.fragment), v = Pt(), ze(x.$$.fragment);
      },
      m(w, N) {
        Oe(e, w, N), st(w, n, N), Oe(i, w, N), st(w, r, N), Oe(a, w, N), st(w, c, N), Oe(l, w, N), st(w, h, N), Oe(f, w, N), st(w, d, N), Oe(A, w, N), st(w, p, N), Oe(g, w, N), st(w, b, N), Oe(y, w, N), st(w, v, N), Oe(x, w, N), I = !0;
      },
      p(w, N) {
        tg(w);
        const H = {};
        N[0] & /*textureSize, xColor, p*/
        4105 | N[1] & /*$$scope*/
        33554432 && (H.$$scope = { dirty: N, ctx: w }), !t && N[0] & /*posX*/
        16 && (t = !0, H.ref = /*posX*/
        w[4], Qi(() => t = !1)), e.$set(H);
        const j = {};
        N[0] & /*frontMostAxisIndex*/
        2048 && (j.renderOrder = /*frontMostAxisIndex*/
        w[11] === 0 ? -1 : 0), N[0] & /*p, xColor, usePolygonOffset, frontMostAxisIndex*/
        3081 | N[1] & /*$$scope*/
        33554432 && (j.$$scope = { dirty: N, ctx: w }), i.$set(j);
        const $ = {};
        N[0] & /*textureSize, xColor, p*/
        4105 | N[1] & /*$$scope*/
        33554432 && ($.$$scope = { dirty: N, ctx: w }), !o && N[0] & /*negX*/
        128 && (o = !0, $.ref = /*negX*/
        w[7], Qi(() => o = !1)), a.$set($);
        const ce = {};
        N[0] & /*textureSize, yColor, p*/
        4106 | N[1] & /*$$scope*/
        33554432 && (ce.$$scope = { dirty: N, ctx: w }), !u && N[0] & /*posY*/
        32 && (u = !0, ce.ref = /*posY*/
        w[5], Qi(() => u = !1)), l.$set(ce);
        const ee = {};
        N[0] & /*frontMostAxisIndex*/
        2048 && (ee.renderOrder = /*frontMostAxisIndex*/
        w[11] === 1 ? -1 : 0), N[0] & /*p, yColor, usePolygonOffset, frontMostAxisIndex*/
        3082 | N[1] & /*$$scope*/
        33554432 && (ee.$$scope = { dirty: N, ctx: w }), f.$set(ee);
        const le = {};
        N[0] & /*textureSize, yColor, p*/
        4106 | N[1] & /*$$scope*/
        33554432 && (le.$$scope = { dirty: N, ctx: w }), !m && N[0] & /*negY*/
        256 && (m = !0, le.ref = /*negY*/
        w[8], Qi(() => m = !1)), A.$set(le);
        const Z = {};
        N[0] & /*textureSize, zColor, p*/
        4108 | N[1] & /*$$scope*/
        33554432 && (Z.$$scope = { dirty: N, ctx: w }), !_ && N[0] & /*posZ*/
        64 && (_ = !0, Z.ref = /*posZ*/
        w[6], Qi(() => _ = !1)), g.$set(Z);
        const he = {};
        N[0] & /*frontMostAxisIndex*/
        2048 && (he.renderOrder = /*frontMostAxisIndex*/
        w[11] === 2 ? -1 : 0), N[0] & /*p, zColor, usePolygonOffset, frontMostAxisIndex*/
        3084 | N[1] & /*$$scope*/
        33554432 && (he.$$scope = { dirty: N, ctx: w }), y.$set(he);
        const _e = {};
        N[0] & /*textureSize, zColor, p*/
        4108 | N[1] & /*$$scope*/
        33554432 && (_e.$$scope = { dirty: N, ctx: w }), !S && N[0] & /*negZ*/
        512 && (S = !0, _e.ref = /*negZ*/
        w[9], Qi(() => S = !1)), x.$set(_e);
      },
      i(w) {
        I || (ae(e.$$.fragment, w), ae(i.$$.fragment, w), ae(a.$$.fragment, w), ae(l.$$.fragment, w), ae(f.$$.fragment, w), ae(A.$$.fragment, w), ae(g.$$.fragment, w), ae(y.$$.fragment, w), ae(x.$$.fragment, w), I = !0);
      },
      o(w) {
        ue(e.$$.fragment, w), ue(i.$$.fragment, w), ue(a.$$.fragment, w), ue(l.$$.fragment, w), ue(f.$$.fragment, w), ue(A.$$.fragment, w), ue(g.$$.fragment, w), ue(y.$$.fragment, w), ue(x.$$.fragment, w), I = !1;
      },
      d(w) {
        w && (rt(n), rt(r), rt(c), rt(h), rt(d), rt(p), rt(b), rt(v)), Qe(e, w), Qe(i, w), Qe(a, w), Qe(l, w), Qe(f, w), Qe(A, w), Qe(g, w), Qe(y, w), Qe(x, w);
      }
    }
  );
}
function iT(s) {
  let e, t;
  return e = new qe({
    props: {
      is: (
        /*root*/
        s[13]
      ),
      $$slots: { default: [nT] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, negY, yColor, posY, negX, xColor, posX*/
      8191 | i[1] & /*$$scope*/
      33554432 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function rT(s) {
  let e, t;
  return e = new Pa({
    props: {
      $$slots: { default: [iT] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*negZ, textureSize, zColor, p, frontMostAxisIndex, usePolygonOffset, posZ, negY, yColor, posY, negX, xColor, posX*/
      8191 | i[1] & /*$$scope*/
      33554432 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function sT(s, e, t) {
  let n, i, r, a, { renderTask: o = void 0 } = e, { animationTask: c = void 0 } = e, { turnRate: l = 2 * Math.PI } = e, { center: u = [0, 0, 0] } = e, { verticalPlacement: h = "bottom" } = e, { horizontalPlacement: f = "right" } = e, { size: d = 128 } = e, { xColor: A = 16725587 } = e, { yColor: m = 9100032 } = e, { zColor: p = 2920447 } = e, { toneMapped: g = !1 } = e, { paddingX: _ = 0 } = e, { paddingY: b = 0 } = e;
  const { autoRenderTask: y, renderer: v, camera: x, invalidate: S } = sn(), I = new Ls(-1.25, 1.25, 1.25, -1.25, 0, 4);
  I.position.set(0, 0, 2);
  const E = new Jl(), M = new Dt();
  bi(
    (o == null ? void 0 : o.key) ?? Symbol("threlte-extras-gizmo-render"),
    () => {
      const oe = v.autoClear;
      t(26, v.autoClear = !1, v), v.getViewport(M);
      const L = v.toneMapping;
      t(26, v.toneMapping = g ? v.toneMapping : 0, v);
      const B = f === "left" ? _ : v.domElement.offsetWidth - d - _, W = h === "bottom" ? b : v.domElement.offsetHeight - d - b;
      v.setViewport(B, W, d, d), v.render(E, I), v.setViewport(M.x, M.y, M.z, M.w), t(26, v.autoClear = oe, v), t(26, v.toneMapping = L, v);
    },
    {
      ...o ?? { after: y },
      autoInvalidate: !1
    }
  );
  const T = document.createElement("div");
  T.style.position = "absolute";
  let D, F, C, R, O, V;
  const q = new P(), z = new Rt(), X = new Rt(), w = new Rt();
  let N = 0, H = !1;
  const j = new xe(), $ = new Zo(), ce = (oe, L, B) => Math.abs(oe.x - L.x) + Math.abs(oe.y - L.y) + Math.abs(oe.z - L.z) + Math.abs(oe.w - L.w) < B, ee = (oe) => {
    const L = oe.object, B = L.userData.targetPosition, W = L.userData.targetEuler;
    N = x.current.position.distanceTo(n), q.set(...B).multiplyScalar(N).add(n), z.setFromEuler(new Ds(...W));
    const de = new bt();
    return de.position.copy(n), de.lookAt(x.current.position), X.copy(de.quaternion), de.lookAt(q), w.copy(de.quaternion), ce(w, X, 1e-4) ? !0 : (H = !0, !1);
  }, le = (oe) => {
    if (H)
      return;
    const L = T.getBoundingClientRect(), B = L.left + (T.offsetWidth - d), W = L.top + (T.offsetHeight - d);
    j.x = (oe.clientX - B) / (L.right - B) * 2 - 1, j.y = -((oe.clientY - W) / (L.bottom - W)) * 2 + 1, $.setFromCamera(j, I);
    const de = $.intersectObjects([D, F, C, R, O, V]);
    de.length > 0 && ee(de[0]) && de.length > 1 && ee(de[1]);
  };
  Qr(() => {
    var oe;
    (oe = v.domElement.parentElement) == null || oe.appendChild(T), T.addEventListener("click", le);
  }), Wt(() => {
    var oe;
    (oe = v.domElement.parentElement) == null || oe.removeChild(T), T.removeEventListener("click", le);
  });
  const Z = new P();
  let he = [0, 0, 0];
  bi(
    (c == null ? void 0 : c.key) ?? Symbol("threlte-extras-gizmo-animation"),
    (oe) => {
      if (Z.set(0, 0, 1).applyQuaternion(x.current.quaternion), (Z.x !== he[0] || Z.y !== he[1] || Z.z !== he[2]) && (t(3, he = [Z.x, Z.y, Z.z]), E.quaternion.copy(x.current.quaternion).invert(), S()), H) {
        const L = oe * l;
        X.rotateTowards(w, L), x.current.position.set(0, 0, 1).applyQuaternion(X).multiplyScalar(N).add(n), x.current.quaternion.rotateTowards(z, L), X.angleTo(w) === 0 && (H = !1), S();
      }
    },
    { ...c, autoInvalidate: !1 }
  );
  const _e = (oe) => {
    if (oe <= 0)
      return 1;
    let L = 1;
    for (; L < oe; )
      L <<= 1;
    return L;
  }, U = {}, ye = new Pe(), ie = (oe, L, B = "") => {
    ye.set(L);
    const W = `${ye.getHexString()}-${B}`;
    U[W] && U[W].dispose();
    const de = document.createElement("canvas");
    de.width = oe, de.height = oe;
    const Ae = de.getContext("2d");
    if (Ae.beginPath(), Ae.arc(oe / 2, oe / 2, oe / 4, 0, 2 * Math.PI), Ae.closePath(), Ae.fillStyle = ye.convertSRGBToLinear().getStyle(), Ae.fill(), B) {
      const Ce = Math.abs(oe * 0.375);
      Ae.font = `${Ce}px Arial`, Ae.textAlign = "center", Ae.fillStyle = "#000000";
      const Se = oe * (41 / 64);
      Ae.fillText(B, oe / 2, Se);
    }
    const G = new R0(de);
    return U[W] = G, G;
  }, re = new jo(0.025, 0.78);
  re.rotateZ(Math.PI / 2);
  function te(oe) {
    D = oe, t(4, D);
  }
  function Ie(oe) {
    R = oe, t(7, R);
  }
  function se(oe) {
    F = oe, t(5, F);
  }
  function K(oe) {
    O = oe, t(8, O);
  }
  function ve(oe) {
    C = oe, t(6, C);
  }
  function fe(oe) {
    V = oe, t(9, V);
  }
  return s.$$set = (oe) => {
    "renderTask" in oe && t(16, o = oe.renderTask), "animationTask" in oe && t(17, c = oe.animationTask), "turnRate" in oe && t(18, l = oe.turnRate), "center" in oe && t(19, u = oe.center), "verticalPlacement" in oe && t(20, h = oe.verticalPlacement), "horizontalPlacement" in oe && t(21, f = oe.horizontalPlacement), "size" in oe && t(22, d = oe.size), "xColor" in oe && t(0, A = oe.xColor), "yColor" in oe && t(1, m = oe.yColor), "zColor" in oe && t(2, p = oe.zColor), "toneMapped" in oe && t(23, g = oe.toneMapped), "paddingX" in oe && t(24, _ = oe.paddingX), "paddingY" in oe && t(25, b = oe.paddingY);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*center*/
    524288 && (n = new P(...u)), s.$$.dirty[0] & /*size, horizontalPlacement, verticalPlacement, toneMapped, paddingX, paddingY*/
    66060288 && S(), s.$$.dirty[0] & /*horizontalPlacement, paddingX, verticalPlacement, paddingY, size*/
    57671680 && (f === "right" ? (T.style.right = `${_}px`, T.style.left = "") : (T.style.right = "", T.style.left = `${_}px`), h === "bottom" ? (T.style.bottom = `${b}px`, T.style.top = "") : (T.style.bottom = "", T.style.top = `${b}px`), T.style.height = `${d}px`, T.style.width = `${d}px`), s.$$.dirty[0] & /*size, renderer*/
    71303168 && t(12, i = _e(d * 0.3 * v.getPixelRatio())), s.$$.dirty[0] & /*p*/
    8 && t(11, r = he.indexOf(Math.max(...he))), s.$$.dirty[0] & /*p*/
    8 && t(10, a = he.some((oe) => oe < 0));
  }, [
    A,
    m,
    p,
    he,
    D,
    F,
    C,
    R,
    O,
    V,
    a,
    r,
    i,
    E,
    ie,
    re,
    o,
    c,
    l,
    u,
    h,
    f,
    d,
    g,
    _,
    b,
    v,
    te,
    Ie,
    se,
    K,
    ve,
    fe
  ];
}
class aT extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      sT,
      rT,
      pt,
      {
        renderTask: 16,
        animationTask: 17,
        turnRate: 18,
        center: 19,
        verticalPlacement: 20,
        horizontalPlacement: 21,
        size: 22,
        xColor: 0,
        yColor: 1,
        zColor: 2,
        toneMapped: 23,
        paddingX: 24,
        paddingY: 25
      },
      null,
      [-1, -1]
    );
  }
  get renderTask() {
    return this.$$.ctx[16];
  }
  set renderTask(e) {
    this.$$set({ renderTask: e }), Y();
  }
  get animationTask() {
    return this.$$.ctx[17];
  }
  set animationTask(e) {
    this.$$set({ animationTask: e }), Y();
  }
  get turnRate() {
    return this.$$.ctx[18];
  }
  set turnRate(e) {
    this.$$set({ turnRate: e }), Y();
  }
  get center() {
    return this.$$.ctx[19];
  }
  set center(e) {
    this.$$set({ center: e }), Y();
  }
  get verticalPlacement() {
    return this.$$.ctx[20];
  }
  set verticalPlacement(e) {
    this.$$set({ verticalPlacement: e }), Y();
  }
  get horizontalPlacement() {
    return this.$$.ctx[21];
  }
  set horizontalPlacement(e) {
    this.$$set({ horizontalPlacement: e }), Y();
  }
  get size() {
    return this.$$.ctx[22];
  }
  set size(e) {
    this.$$set({ size: e }), Y();
  }
  get xColor() {
    return this.$$.ctx[0];
  }
  set xColor(e) {
    this.$$set({ xColor: e }), Y();
  }
  get yColor() {
    return this.$$.ctx[1];
  }
  set yColor(e) {
    this.$$set({ yColor: e }), Y();
  }
  get zColor() {
    return this.$$.ctx[2];
  }
  set zColor(e) {
    this.$$set({ zColor: e }), Y();
  }
  get toneMapped() {
    return this.$$.ctx[23];
  }
  set toneMapped(e) {
    this.$$set({ toneMapped: e }), Y();
  }
  get paddingX() {
    return this.$$.ctx[24];
  }
  set paddingX(e) {
    this.$$set({ paddingX: e }), Y();
  }
  get paddingY() {
    return this.$$.ctx[25];
  }
  set paddingY(e) {
    this.$$set({ paddingY: e }), Y();
  }
}
xt(aT, { renderTask: {}, animationTask: {}, turnRate: {}, center: {}, verticalPlacement: {}, horizontalPlacement: {}, size: {}, xColor: {}, yColor: {}, zColor: {}, toneMapped: { type: "Boolean" }, paddingX: {}, paddingY: {} }, [], [], !0);
const oT = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, cT = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
}, rs = (s) => {
  let e = !1;
  const t = vt(s());
  return {
    ...t,
    memoize: (...i) => {
      if (!e) {
        e = !0;
        return;
      }
      t.set(s());
    }
  };
}, lT = (s) => ({ ref: s[1] & /*ref*/
1024 }), ng = (s) => ({ ref: (
  /*ref*/
  s[41]
) });
function uT(s) {
  let e, t, n, i, r;
  e = new qe.Mesh({
    props: {
      "scale.y": -1,
      "rotation.x": -Math.PI / 2,
      material: (
        /*shadowMaterial*/
        s[10]
      ),
      geometry: (
        /*$planeGeometry*/
        s[0]
      )
    }
  }), n = new qe({
    props: {
      is: (
        /*shadowCamera*/
        s[9]
      ),
      manual: !0
    }
  });
  const a = (
    /*#slots*/
    s[27].default
  ), o = At(
    a,
    s,
    /*$$scope*/
    s[29],
    ng
  );
  return {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment), i = Pt(), o && o.c();
    },
    m(c, l) {
      Oe(e, c, l), st(c, t, l), Oe(n, c, l), st(c, i, l), o && o.m(c, l), r = !0;
    },
    p(c, l) {
      const u = {};
      l[0] & /*$planeGeometry*/
      1 && (u.geometry = /*$planeGeometry*/
      c[0]), e.$set(u), o && o.p && (!r || l[0] & /*$$scope*/
      536870912 | l[1] & /*ref*/
      1024) && mt(
        o,
        a,
        c,
        /*$$scope*/
        c[29],
        r ? gt(
          a,
          /*$$scope*/
          c[29],
          l,
          lT
        ) : _t(
          /*$$scope*/
          c[29]
        ),
        ng
      );
    },
    i(c) {
      r || (ae(e.$$.fragment, c), ae(n.$$.fragment, c), ae(o, c), r = !0);
    },
    o(c) {
      ue(e.$$.fragment, c), ue(n.$$.fragment, c), ue(o, c), r = !1;
    },
    d(c) {
      c && (rt(t), rt(i)), Qe(e, c), Qe(n, c), o && o.d(c);
    }
  };
}
function hT(s) {
  let e, t;
  return e = new qe.Group({
    props: {
      "rotation.x": Math.PI / 2,
      $$slots: { default: [uT] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*$$scope, $planeGeometry*/
      536870913 | i[1] & /*ref*/
      1024 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function fT(s) {
  let e, t;
  const n = [
    /*$$restProps*/
    s[12]
  ];
  let i = {
    $$slots: {
      default: [
        hT,
        ({ ref: r }) => ({ 41: r }),
        ({ ref: r }) => [0, r ? 1024 : 0]
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe.Group({ props: i }), s[28](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a[0] & /*$$restProps*/
      4096 ? Qt(n, [qt(
        /*$$restProps*/
        r[12]
      )]) : {};
      a[0] & /*$$scope, $planeGeometry*/
      536870913 | a[1] & /*ref*/
      1024 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[28](null), Qe(e, r);
    }
  };
}
function dT(s, e, t) {
  const n = [
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "smooth",
    "resolution",
    "frames",
    "scale",
    "color",
    "depthWrite",
    "refresh"
  ];
  let i = at(e, n), r, a, o, c, l, u, h, f, { $$slots: d = {}, $$scope: A } = e, { opacity: m = 1 } = e, { width: p = 1 } = e, { height: g = 1 } = e, { blur: _ = 1 } = e, { far: b = 10 } = e, { smooth: y = !0 } = e, { resolution: v = 512 } = e, { frames: x = 1 / 0 } = e, { scale: S = 10 } = e, { color: I = "#000000" } = e, { depthWrite: E = !1 } = e;
  const { scene: M, renderer: T } = sn(), D = rs(() => p * (Array.isArray(S) ? S[0] : S || 1));
  $e(s, D, (Z) => t(26, h = Z));
  const F = rs(() => g * (Array.isArray(S) ? S[1] : S || 1));
  $e(s, F, (Z) => t(25, u = Z));
  const C = rs(() => {
    const Z = new pi(v, v);
    return Z.texture.generateMipmaps = !1, "colorSpace" in Z.texture ? Z.texture.colorSpace = T.outputColorSpace : Z.texture.encoding = T.outputEncoding, Z;
  });
  $e(s, C, (Z) => t(36, c = Z));
  const R = rs(() => {
    const Z = new pi(v, v);
    return Z.texture.generateMipmaps = !1, Z;
  });
  $e(s, R, (Z) => t(35, o = Z));
  const O = rs(() => new ji(h, u).rotateX(Math.PI / 2));
  $e(s, O, (Z) => t(0, a = Z));
  const V = rs(() => new Ne(a));
  $e(s, V, (Z) => t(37, l = Z));
  const q = rs(() => {
    const Z = new Wo({ depthTest: !1, depthWrite: !1 });
    return Z.onBeforeCompile = (he) => {
      he.uniforms = {
        ...he.uniforms,
        uColor: {
          value: new Pe(I).convertSRGBToLinear()
        }
      }, he.fragmentShader = `uniform vec3 uColor;
` + he.fragmentShader, he.fragmentShader = he.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );"), he.fragmentShader = he.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    }, Z;
  });
  $e(s, q, (Z) => t(34, r = Z));
  const z = new Kn({
    ...oT,
    depthTest: !1
  }), X = new Kn({ ...cT, depthTest: !1 }), w = new Ls(-h / 2, h / 2, u / 2, -u / 2, 0, b);
  w.updateProjectionMatrix();
  const N = new In({
    map: c.texture,
    transparent: !0,
    opacity: m,
    depthWrite: E
  }), H = (Z) => {
    const he = l;
    he.visible = !0, he.material = z, z.uniforms.tDiffuse.value = c.texture, z.uniforms.h.value = Z * 1 / 256, T.setRenderTarget(o), T.render(he, w), he.material = X, X.uniforms.tDiffuse.value = o.texture, X.uniforms.v.value = Z * 1 / 256, T.setRenderTarget(c), T.render(he, w), he.visible = !1;
  }, j = () => {
    const Z = M.background;
    M.background = null;
    const he = M.overrideMaterial;
    M.overrideMaterial = r;
    const _e = T.getClearAlpha();
    T.setClearAlpha(0), T.setRenderTarget(c), T.render(M, w), M.overrideMaterial = he, H(_), y && H(_ * 0.4), T.setRenderTarget(null), M.background = Z, T.setClearAlpha(_e);
  }, $ = () => {
    j();
  };
  let ce = 0;
  bi(() => {
    (x === 1 / 0 || ce < x) && (j(), ce += 1);
  }), Wt(() => {
    c.dispose(), o.dispose(), a.dispose(), r.dispose(), z.dispose(), X.dispose(), N.dispose();
  });
  const ee = An();
  $e(s, ee, (Z) => t(1, f = Z));
  function le(Z) {
    Mt[Z ? "unshift" : "push"](() => {
      f = Z, ee.set(f);
    });
  }
  return s.$$set = (Z) => {
    e = Ve(Ve({}, e), Kt(Z)), t(12, i = at(e, n)), "opacity" in Z && t(13, m = Z.opacity), "width" in Z && t(14, p = Z.width), "height" in Z && t(15, g = Z.height), "blur" in Z && t(16, _ = Z.blur), "far" in Z && t(17, b = Z.far), "smooth" in Z && t(18, y = Z.smooth), "resolution" in Z && t(19, v = Z.resolution), "frames" in Z && t(20, x = Z.frames), "scale" in Z && t(21, S = Z.scale), "color" in Z && t(22, I = Z.color), "depthWrite" in Z && t(23, E = Z.depthWrite), "$$scope" in Z && t(29, A = Z.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty[0] & /*width, scale*/
    2113536 && D.memoize([p, S]), s.$$.dirty[0] & /*height, scale*/
    2129920 && F.memoize(g, S), s.$$.dirty[0] & /*resolution*/
    524288 && C.memoize(v), s.$$.dirty[0] & /*resolution*/
    524288 && R.memoize(v), s.$$.dirty[0] & /*$scaledWidth, $scaledHeight*/
    100663296 && O.memoize(h, u), s.$$.dirty[0] & /*$planeGeometry*/
    1 && V.memoize(a), s.$$.dirty[0] & /*color*/
    4194304 && q.memoize(I);
  }, [
    a,
    f,
    D,
    F,
    C,
    R,
    O,
    V,
    q,
    w,
    N,
    ee,
    i,
    m,
    p,
    g,
    _,
    b,
    y,
    v,
    x,
    S,
    I,
    E,
    $,
    u,
    h,
    d,
    le,
    A
  ];
}
class pT extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      dT,
      fT,
      pt,
      {
        opacity: 13,
        width: 14,
        height: 15,
        blur: 16,
        far: 17,
        smooth: 18,
        resolution: 19,
        frames: 20,
        scale: 21,
        color: 22,
        depthWrite: 23,
        refresh: 24
      },
      null,
      [-1, -1]
    );
  }
  get opacity() {
    return this.$$.ctx[13];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), Y();
  }
  get width() {
    return this.$$.ctx[14];
  }
  set width(e) {
    this.$$set({ width: e }), Y();
  }
  get height() {
    return this.$$.ctx[15];
  }
  set height(e) {
    this.$$set({ height: e }), Y();
  }
  get blur() {
    return this.$$.ctx[16];
  }
  set blur(e) {
    this.$$set({ blur: e }), Y();
  }
  get far() {
    return this.$$.ctx[17];
  }
  set far(e) {
    this.$$set({ far: e }), Y();
  }
  get smooth() {
    return this.$$.ctx[18];
  }
  set smooth(e) {
    this.$$set({ smooth: e }), Y();
  }
  get resolution() {
    return this.$$.ctx[19];
  }
  set resolution(e) {
    this.$$set({ resolution: e }), Y();
  }
  get frames() {
    return this.$$.ctx[20];
  }
  set frames(e) {
    this.$$set({ frames: e }), Y();
  }
  get scale() {
    return this.$$.ctx[21];
  }
  set scale(e) {
    this.$$set({ scale: e }), Y();
  }
  get color() {
    return this.$$.ctx[22];
  }
  set color(e) {
    this.$$set({ color: e }), Y();
  }
  get depthWrite() {
    return this.$$.ctx[23];
  }
  set depthWrite(e) {
    this.$$set({ depthWrite: e }), Y();
  }
  get refresh() {
    return this.$$.ctx[24];
  }
}
xt(pT, { opacity: {}, width: {}, height: {}, blur: {}, far: {}, smooth: { type: "Boolean" }, resolution: {}, frames: {}, scale: {}, color: {}, depthWrite: { type: "Boolean" } }, ["default"], ["refresh"], !0);
class Y_ extends i_ {
  constructor(e) {
    super(e), this.type = Pn;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const a = function(I, E) {
      switch (I) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (E || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (E || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (E || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (E || ""));
      }
    }, u = `
`, h = function(I, E, M) {
      E = E || 1024;
      let D = I.pos, F = -1, C = 0, R = "", O = String.fromCharCode.apply(null, new Uint16Array(I.subarray(D, D + 128)));
      for (; 0 > (F = O.indexOf(u)) && C < E && D < I.byteLength; )
        R += O, C += O.length, D += 128, O += String.fromCharCode.apply(null, new Uint16Array(I.subarray(D, D + 128)));
      return -1 < F ? (M !== !1 && (I.pos += C + F + 1), R + O.slice(0, F)) : !1;
    }, f = function(I) {
      const E = /^#\?(\S+)/, M = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, T = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, D = /^\s*FORMAT=(\S+)\s*$/, F = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, C = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let R, O;
      for ((I.pos >= I.byteLength || !(R = h(I))) && a(1, "no header found"), (O = R.match(E)) || a(3, "bad initial token"), C.valid |= 1, C.programtype = O[1], C.string += R + `
`; R = h(I), R !== !1; ) {
        if (C.string += R + `
`, R.charAt(0) === "#") {
          C.comments += R + `
`;
          continue;
        }
        if ((O = R.match(M)) && (C.gamma = parseFloat(O[1])), (O = R.match(T)) && (C.exposure = parseFloat(O[1])), (O = R.match(D)) && (C.valid |= 2, C.format = O[1]), (O = R.match(F)) && (C.valid |= 4, C.height = parseInt(O[1], 10), C.width = parseInt(O[2], 10)), C.valid & 2 && C.valid & 4)
          break;
      }
      return C.valid & 2 || a(3, "missing format specifier"), C.valid & 4 || a(3, "missing image size specifier"), C;
    }, d = function(I, E, M) {
      const T = E;
      if (
        // run length encoding is not allowed so read flat
        T < 8 || T > 32767 || // this file is not run length encoded
        I[0] !== 2 || I[1] !== 2 || I[2] & 128
      )
        return new Uint8Array(I);
      T !== (I[2] << 8 | I[3]) && a(3, "wrong scanline width");
      const D = new Uint8Array(4 * E * M);
      D.length || a(4, "unable to allocate buffer space");
      let F = 0, C = 0;
      const R = 4 * T, O = new Uint8Array(4), V = new Uint8Array(R);
      let q = M;
      for (; q > 0 && C < I.byteLength; ) {
        C + 4 > I.byteLength && a(1), O[0] = I[C++], O[1] = I[C++], O[2] = I[C++], O[3] = I[C++], (O[0] != 2 || O[1] != 2 || (O[2] << 8 | O[3]) != T) && a(3, "bad rgbe scanline format");
        let z = 0, X;
        for (; z < R && C < I.byteLength; ) {
          X = I[C++];
          const N = X > 128;
          if (N && (X -= 128), (X === 0 || z + X > R) && a(3, "bad scanline data"), N) {
            const H = I[C++];
            for (let j = 0; j < X; j++)
              V[z++] = H;
          } else
            V.set(I.subarray(C, C + X), z), z += X, C += X;
        }
        const w = T;
        for (let N = 0; N < w; N++) {
          let H = 0;
          D[F] = V[N + H], H += T, D[F + 1] = V[N + H], H += T, D[F + 2] = V[N + H], H += T, D[F + 3] = V[N + H], F += 4;
        }
        q--;
      }
      return D;
    }, A = function(I, E, M, T) {
      const D = I[E + 3], F = Math.pow(2, D - 128) / 255;
      M[T + 0] = I[E + 0] * F, M[T + 1] = I[E + 1] * F, M[T + 2] = I[E + 2] * F, M[T + 3] = 1;
    }, m = function(I, E, M, T) {
      const D = I[E + 3], F = Math.pow(2, D - 128) / 255;
      M[T + 0] = uo.toHalfFloat(Math.min(I[E + 0] * F, 65504)), M[T + 1] = uo.toHalfFloat(Math.min(I[E + 1] * F, 65504)), M[T + 2] = uo.toHalfFloat(Math.min(I[E + 2] * F, 65504)), M[T + 3] = uo.toHalfFloat(1);
    }, p = new Uint8Array(e);
    p.pos = 0;
    const g = f(p), _ = g.width, b = g.height, y = d(p.subarray(p.pos), _, b);
    let v, x, S;
    switch (this.type) {
      case pn:
        S = y.length / 4;
        const I = new Float32Array(S * 4);
        for (let M = 0; M < S; M++)
          A(y, M * 4, I, M * 4);
        v = I, x = pn;
        break;
      case Pn:
        S = y.length / 4;
        const E = new Uint16Array(S * 4);
        for (let M = 0; M < S; M++)
          m(y, M * 4, E, M * 4);
        v = E, x = Pn;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: _,
      height: b,
      data: v,
      header: g.string,
      gamma: g.gamma,
      exposure: g.exposure,
      type: x
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, i) {
    function r(a, o) {
      switch (a.type) {
        case pn:
        case Pn:
          a.colorSpace = rn, a.minFilter = wt, a.magFilter = wt, a.generateMipmaps = !1, a.flipY = !0;
          break;
      }
      t && t(a, o);
    }
    return super.load(e, r, n, i);
  }
}
class AT extends Tn {
  constructor(e) {
    super(e), this.hdrLoader = new Y_(), this.type = Pn;
  }
  load(e, t, n, i) {
    const r = new Ta();
    switch (r.type = this.type, r.type) {
      case pn:
        r.colorSpace = rn, r.minFilter = wt, r.magFilter = wt, r.generateMipmaps = !1;
        break;
      case Pn:
        r.colorSpace = rn, r.minFilter = wt, r.magFilter = wt, r.generateMipmaps = !1;
        break;
    }
    const a = this;
    let o = 0;
    function c(l, u, h, f) {
      new wn(a.manager).setPath(a.path).setResponseType("arraybuffer").setWithCredentials(a.withCredentials).load(e[l], function(d) {
        o++;
        const A = a.hdrLoader.parse(d);
        if (A) {
          if (A.data !== void 0) {
            const m = new pr(A.data, A.width, A.height);
            m.type = r.type, m.colorSpace = r.colorSpace, m.format = r.format, m.minFilter = r.minFilter, m.magFilter = r.magFilter, m.generateMipmaps = r.generateMipmaps, r.images[l] = m;
          }
          o === 6 && (r.needsUpdate = !0, u && u(r));
        }
      }, h, f);
    }
    for (let l = 0; l < e.length; l++)
      c(l, t, n, i);
    return r;
  }
  setDataType(e) {
    return this.type = e, this.hdrLoader.setDataType(e), this;
  }
}
class gT extends Ne {
  constructor(e, t = {}) {
    const i = [
      e.isCubeTexture ? "#define ENVMAP_TYPE_CUBE" : ""
    ], r = (
      /* glsl */
      `
			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
			`
    ), a = i.join(`
`) + /* glsl */
    `

				varying vec3 vWorldPosition;

				uniform float radius;
				uniform float height;
				uniform float angle;

				#ifdef ENVMAP_TYPE_CUBE

					uniform samplerCube map;

				#else

					uniform sampler2D map;

				#endif

				// From: https://www.shadertoy.com/view/4tsBD7
				float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
				{

					float d = dot ( rd, n );

					if( d > 0.0 ) { return 1e6; }

					vec3 o = ro - c;
					float t = - dot( n, o ) / d;
					vec3 q = o + rd * t;

					return ( dot( q, q ) < r * r ) ? t : 1e6;

				}

				// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
				float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {

					vec3 oc = ro - ce;
					float b = dot( oc, rd );
					float c = dot( oc, oc ) - ra * ra;
					float h = b * b - c;

					if( h < 0.0 ) { return -1.0; }

					h = sqrt( h );

					return - b + h;

				}

				vec3 project() {

					vec3 p = normalize( vWorldPosition );
					vec3 camPos = cameraPosition;
					camPos.y -= height;

					float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
					if( intersection > 0.0 ) {

						vec3 h = vec3( 0.0, - height, 0.0 );
						float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
						p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

					} else {

						p = vec3( 0.0, 1.0, 0.0 );

					}

					return p;

				}

				#include <common>

				void main() {

					vec3 projectedWorldPosition = project();

					#ifdef ENVMAP_TYPE_CUBE

						vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

					#else

						vec3 direction = normalize( projectedWorldPosition );
						vec2 uv = equirectUv( direction );
						vec3 outcolor = texture2D( map, uv ).rgb;

					#endif

					gl_FragColor = vec4( outcolor, 1.0 );

					#include <tonemapping_fragment>
					#include <colorspace_fragment>

				}
				`, o = {
      map: { value: e },
      height: { value: t.height || 15 },
      radius: { value: t.radius || 100 }
    }, c = new Jo(1, 16), l = new Kn({
      uniforms: o,
      fragmentShader: a,
      vertexShader: r,
      side: Mn
    });
    super(c, l);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
function ig(s) {
  let e, t;
  const n = [
    { is: gT },
    { args: [
      /*envMap*/
      s[0]
    ] },
    /*$$restProps*/
    s[1]
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*envMap, $$restProps*/
      3 ? Qt(n, [
        n[0],
        a & /*envMap*/
        1 && { args: [
          /*envMap*/
          r[0]
        ] },
        a & /*$$restProps*/
        2 && qt(
          /*$$restProps*/
          r[1]
        )
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      Qe(e, r);
    }
  };
}
function mT(s) {
  let e, t, n = (
    /*envMap*/
    s[0] && ig(s)
  );
  return {
    c() {
      n && n.c(), e = yi();
    },
    m(i, r) {
      n && n.m(i, r), st(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*envMap*/
      i[0] ? n ? (n.p(i, r), r & /*envMap*/
      1 && ae(n, 1)) : (n = ig(i), n.c(), ae(n, 1), n.m(e.parentNode, e)) : n && (ai(), ue(n, 1, 1, () => {
        n = null;
      }), oi());
    },
    i(i) {
      t || (ae(n), t = !0);
    },
    o(i) {
      ue(n), t = !1;
    },
    d(i) {
      i && rt(e), n && n.d(i);
    }
  };
}
function _T(s, e, t) {
  const n = ["envMap"];
  let i = at(e, n), { envMap: r } = e;
  return s.$$set = (a) => {
    e = Ve(Ve({}, e), Kt(a)), t(1, i = at(e, n)), "envMap" in a && t(0, r = a.envMap);
  }, [r, i];
}
class j_ extends St {
  constructor(e) {
    super(), Et(this, e, _T, mT, pt, { envMap: 0 });
  }
  get envMap() {
    return this.$$.ctx[0];
  }
  set envMap(e) {
    this.$$set({ envMap: e }), Y();
  }
}
xt(j_, { envMap: {} }, [], [], !0);
function rg(s) {
  let e, t;
  const n = [
    /*groundProjection*/
    s[0],
    { envMap: (
      /*previousEnvMap*/
      s[1]
    ) }
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new j_({ props: i }), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*groundProjection, previousEnvMap*/
      3 ? Qt(n, [
        a & /*groundProjection*/
        1 && qt(
          /*groundProjection*/
          r[0]
        ),
        a & /*previousEnvMap*/
        2 && { envMap: (
          /*previousEnvMap*/
          r[1]
        ) }
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      Qe(e, r);
    }
  };
}
function bT(s) {
  let e, t, n = (
    /*groundProjection*/
    s[0] && rg(s)
  );
  return {
    c() {
      n && n.c(), e = yi();
    },
    m(i, r) {
      n && n.m(i, r), st(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*groundProjection*/
      i[0] ? n ? (n.p(i, r), r & /*groundProjection*/
      1 && ae(n, 1)) : (n = rg(i), n.c(), ae(n, 1), n.m(e.parentNode, e)) : n && (ai(), ue(n, 1, 1, () => {
        n = null;
      }), oi());
    },
    i(i) {
      t || (ae(n), t = !0);
    },
    o(i) {
      ue(n), t = !1;
    },
    d(i) {
      i && rt(e), n && n.d(i);
    }
  };
}
function yT(s, e, t) {
  let n, i, r, { path: a = "" } = e, { files: o } = e, { isBackground: c = void 0 } = e, { groundProjection: l = void 0 } = e, { format: u = void 0 } = e, { encoding: h = void 0 } = e;
  const f = (M) => !!M.isScene, { scene: d, invalidate: A } = sn(), m = Fs();
  $e(s, m, (M) => t(13, r = M));
  let p = d;
  f(r) && (p = r);
  let g = p.environment, _ = p.background, b = i, y, v;
  const x = () => {
    const M = u || (Array.isArray(o) ? o[0] : o).split(".").pop() == "hdr" ? "hdr" : "ldr";
    return n && M == "ldr" ? n_ : !n && M == "ldr" ? Qo : n && M == "hdr" ? AT : !n && M == "hdr" ? Y_ : Qo;
  }, { remember: S } = y_(), I = Au(), E = async () => {
    var R;
    const M = x(), T = new M();
    (R = T.setDataType) == null || R.call(T, pn);
    const D = Array.isArray(o) ? o.join(",") : o, C = await S(
      async () => I(new Promise((O, V) => {
        T.setPath(a).load(o, (q) => {
          O(q);
        });
      })),
      [M, a, D]
    );
    C.mapping = n ? Xi : _a, C.encoding = h || n ? va : Wi, t(1, y = C), t(8, p.environment = y, p), c && t(8, p.background = y, p), A(), t(10, v = u || void 0), t(9, b = i);
  };
  return Wt(() => {
    t(8, p.environment = g, p), t(8, p.background = _, p), y && y.dispose(), t(0, l = void 0), A();
  }), s.$$set = (M) => {
    "path" in M && t(3, a = M.path), "files" in M && t(4, o = M.files), "isBackground" in M && t(5, c = M.isBackground), "groundProjection" in M && t(0, l = M.groundProjection), "format" in M && t(6, u = M.format), "encoding" in M && t(7, h = M.encoding);
  }, s.$$.update = () => {
    s.$$.dirty & /*files*/
    16 && (n = Array.isArray(o)), s.$$.dirty & /*path, files*/
    24 && t(11, i = `${a}${o}`), s.$$.dirty & /*envPath, previousEnvPath, format, previousFormat, previousEnvMap, groundProjection, isBackground, scene*/
    3939 && ((i != b || u != v) && (y && y.dispose(), E(), t(0, l), t(11, i), t(9, b), t(6, u), t(10, v), t(1, y), t(5, c), t(8, p), t(3, a), t(4, o)), !c && p.background && (t(8, p.background = null, p), A()), c && !p.background && y && (t(8, p.background = y, p), A()));
  }, [
    l,
    y,
    m,
    a,
    o,
    c,
    u,
    h,
    p,
    b,
    v,
    i
  ];
}
class vT extends St {
  constructor(e) {
    super(), Et(this, e, yT, bT, pt, {
      path: 3,
      files: 4,
      isBackground: 5,
      groundProjection: 0,
      format: 6,
      encoding: 7
    });
  }
  get path() {
    return this.$$.ctx[3];
  }
  set path(e) {
    this.$$set({ path: e }), Y();
  }
  get files() {
    return this.$$.ctx[4];
  }
  set files(e) {
    this.$$set({ files: e }), Y();
  }
  get isBackground() {
    return this.$$.ctx[5];
  }
  set isBackground(e) {
    this.$$set({ isBackground: e }), Y();
  }
  get groundProjection() {
    return this.$$.ctx[0];
  }
  set groundProjection(e) {
    this.$$set({ groundProjection: e }), Y();
  }
  get format() {
    return this.$$.ctx[6];
  }
  set format(e) {
    this.$$set({ format: e }), Y();
  }
  get encoding() {
    return this.$$.ctx[7];
  }
  set encoding(e) {
    this.$$set({ encoding: e }), Y();
  }
}
xt(vT, { path: {}, files: {}, isBackground: {}, groundProjection: {}, format: {}, encoding: {} }, [], [], !0);
const J_ = Number.parseInt(Ma.replace("dev", "")), ET = (
  /*glsl*/
  `
	varying vec3 worldPosition;
	uniform float uFadeDistance;
	uniform float uInfiniteGrid;
	uniform float uFollowCamera;

	uniform int uCoord0;
	uniform int uCoord1;
	uniform int uCoord2;

	void main() {

		vec3 pos = vec3(position[uCoord0],position[uCoord1],position[uCoord2]) * (1. + uFadeDistance * uInfiniteGrid);

		vec3 cameraFollowOffset = cameraPosition * uFollowCamera;
		pos[uCoord0] += cameraFollowOffset[uCoord0];
		pos[uCoord1] += cameraFollowOffset[uCoord1];

		worldPosition = pos;

		gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
	}
`
), xT = (
  /*glsl*/
  `
	varying vec3 worldPosition;
	uniform float uSize1;
	uniform float uSize2;
	uniform vec3 uColor1;
	uniform vec3 uColor2;
	uniform vec3 uBackgroundColor;
	uniform float uBackgroundOpacity;
	uniform float uFadeDistance;
	uniform float uFadeStrength;
	uniform float uThickness1;
	uniform float uThickness2;
	uniform float uInfiniteGrid;

	uniform int uCoord0;
	uniform int uCoord1;
	uniform int uCoord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int uGridType;

  // lineGrid coord for lines
	uniform int uLineGridCoord;

	// circlegrid max radius
	uniform float uCircleGridMaxRadius;

	// polar grid dividers
	uniform float uPolarCellDividers;
	uniform float uPolarSectionDividers;

	const float pi = 3.141592653589793;

	float getSquareGrid(float size, float thickness) {
		vec2 coord = vec2(worldPosition[uCoord0], worldPosition[uCoord1]) / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1. - thickness;

		return 1.0 - min(line, 1.);
	}

	float getLinesGrid(float size, float thickness) {
		float coord = worldPosition[uLineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.);
	}

	float getCirclesGrid(float size, float thickness) {
		float coord = length(vec2(worldPosition[uCoord0], worldPosition[uCoord1])) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if(uCircleGridMaxRadius > 0. && coord > uCircleGridMaxRadius + thickness * 0.05) discard;

		return 1.0 - min(line, 1.);
	}

	float getPolarGrid(float size, float thickness, float polarDividers) {

		float rad = length(worldPosition.xz) / size;
		vec2 coord = vec2(rad, atan(worldPosition.x, worldPosition.z) * polarDividers / pi) ;


		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);



		if(uCircleGridMaxRadius > 0. && rad > uCircleGridMaxRadius + thickness * 0.05) discard;

		return 1.0 - min(line, 1.);
	}

	void main() {
		float g1 = 0.;
		float g2 = 0.;

		if(uGridType == 0){
			g1 = getSquareGrid(uSize1, uThickness1);
			g2 = getSquareGrid(uSize2, uThickness2);
		}

		if(uGridType == 1){
			g1 = getLinesGrid(uSize1, uThickness1);
			g2 = getLinesGrid(uSize2, uThickness2);
		}

		if(uGridType==2){
			g1 = getCirclesGrid(uSize1, uThickness1);
			g2 = getCirclesGrid(uSize2, uThickness2);
		}

		if(uGridType==3){
			g1 = getPolarGrid(uSize1, uThickness1, uPolarCellDividers);
			g2 = getPolarGrid(uSize2, uThickness2, uPolarSectionDividers);
		}


		vec3 color = mix(uColor1, uColor2, min(1.,uThickness2*g2));
		float d = 1.0 - min(distance(vec2(cameraPosition[uCoord0],cameraPosition[uCoord1]), vec2(worldPosition[uCoord0],worldPosition[uCoord1])) / uFadeDistance, 1.);
		float fadeFactor =  pow(d,uFadeStrength) * 0.95;

		if(uBackgroundOpacity> 0.0){
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.,1.);
			vec3 finalColor = mix(uBackgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, uBackgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);
		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d,uFadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}


		if(gl_FragColor.a <= 0.0) discard;

		#include <tonemapping_fragment>

		#ifdef USE_COLORSPACE_FRAGMENT
			#include <colorspace_fragment>
		#else
			#include <encodings_fragment>
		#endif


	}
`
), ST = {
  fragmentShader: xT,
  vertexShader: ET
}, CT = (s) => ({ ref: s[0] & /*ref*/
1 }), sg = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function MT(s) {
  let e, t;
  return e = new qe.PlaneGeometry({
    props: {
      args: typeof /*gridSize*/
      s[1] == "number" ? [
        /*gridSize*/
        s[1],
        /*gridSize*/
        s[1]
      ] : (
        /*gridSize*/
        s[1]
      )
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i[0] & /*gridSize*/
      2 && (r.args = typeof /*gridSize*/
      n[1] == "number" ? [
        /*gridSize*/
        n[1],
        /*gridSize*/
        n[1]
      ] : (
        /*gridSize*/
        n[1]
      )), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function IT(s) {
  let e, t, n;
  e = new qe.ShaderMaterial({
    props: {
      fragmentShader: (
        /*fragmentShader*/
        s[4]
      ),
      vertexShader: (
        /*vertexShader*/
        s[5]
      ),
      uniforms: (
        /*uniforms*/
        s[2]
      ),
      transparent: !0,
      side: Mn,
      defines: {
        USE_COLORSPACE_FRAGMENT: J_ >= 154 ? "" : void 0
      }
    }
  });
  const i = (
    /*#slots*/
    s[26].default
  ), r = At(
    i,
    s,
    /*$$scope*/
    s[29],
    sg
  ), a = r || MT(s);
  return {
    c() {
      ze(e.$$.fragment), t = Pt(), a && a.c();
    },
    m(o, c) {
      Oe(e, o, c), st(o, t, c), a && a.m(o, c), n = !0;
    },
    p(o, c) {
      const l = {};
      c[0] & /*uniforms*/
      4 && (l.uniforms = /*uniforms*/
      o[2]), e.$set(l), r ? r.p && (!n || c[0] & /*$$scope, ref*/
      536870913) && mt(
        r,
        i,
        o,
        /*$$scope*/
        o[29],
        n ? gt(
          i,
          /*$$scope*/
          o[29],
          c,
          CT
        ) : _t(
          /*$$scope*/
          o[29]
        ),
        sg
      ) : a && a.p && (!n || c[0] & /*gridSize*/
      2) && a.p(o, n ? c : [-1, -1]);
    },
    i(o) {
      n || (ae(e.$$.fragment, o), ae(a, o), n = !0);
    },
    o(o) {
      ue(e.$$.fragment, o), ue(a, o), n = !1;
    },
    d(o) {
      o && rt(t), Qe(e, o), a && a.d(o);
    }
  };
}
function wT(s) {
  let e, t, n;
  const i = [
    { frustumCulled: !1 },
    /*$$restProps*/
    s[7]
  ];
  function r(o) {
    s[28](o);
  }
  let a = {
    $$slots: {
      default: [IT, ({ ref: o }) => ({ 0: o }), ({ ref: o }) => [o ? 1 : 0]]
    },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = Ve(a, i[o]);
  return (
    /*ref*/
    s[0] !== void 0 && (a.ref = /*ref*/
    s[0]), e = new qe.Mesh({ props: a }), s[27](e), Mt.push(() => Gi(e, "ref", r)), {
      c() {
        ze(e.$$.fragment);
      },
      m(o, c) {
        Oe(e, o, c), n = !0;
      },
      p(o, c) {
        const l = c[0] & /*$$restProps*/
        128 ? Qt(i, [i[0], qt(
          /*$$restProps*/
          o[7]
        )]) : {};
        c[0] & /*$$scope, gridSize, ref, uniforms*/
        536870919 && (l.$$scope = { dirty: c, ctx: o }), !t && c[0] & /*ref*/
        1 && (t = !0, l.ref = /*ref*/
        o[0], Qi(() => t = !1)), e.$set(l);
      },
      i(o) {
        n || (ae(e.$$.fragment, o), n = !0);
      },
      o(o) {
        ue(e.$$.fragment, o), n = !1;
      },
      d(o) {
        s[27](null), Qe(e, o);
      }
    }
  );
}
function TT(s, e, t) {
  const n = [
    "cellColor",
    "sectionColor",
    "cellSize",
    "backgroundColor",
    "backgroundOpacity",
    "sectionSize",
    "plane",
    "gridSize",
    "followCamera",
    "infiniteGrid",
    "fadeDistance",
    "fadeStrength",
    "cellThickness",
    "sectionThickness",
    "type",
    "axis",
    "maxRadius",
    "cellDividers",
    "sectionDividers",
    "ref"
  ];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { cellColor: c = "#000000" } = e, { sectionColor: l = "#0000ee" } = e, { cellSize: u = 1 } = e, { backgroundColor: h = "#dadada" } = e, { backgroundOpacity: f = 0 } = e, { sectionSize: d = 10 } = e, { plane: A = "xz" } = e, { gridSize: m = [20, 20] } = e, { followCamera: p = !1 } = e, { infiniteGrid: g = !1 } = e, { fadeDistance: _ = 100 } = e, { fadeStrength: b = 1 } = e, { cellThickness: y = 1 } = e, { sectionThickness: v = 2 } = e, { type: x = "grid" } = e, { axis: S = "x" } = e, { maxRadius: I = 0 } = e, { cellDividers: E = 6 } = e, { sectionDividers: M = 2 } = e, { ref: T } = e;
  const { fragmentShader: D, vertexShader: F } = ST, { invalidate: C } = sn();
  let R = {
    uSize1: { value: u },
    uSize2: { value: d },
    uColor1: { value: new Pe(c) },
    uColor2: { value: new Pe(l) },
    uBackgroundColor: { value: new Pe("#aaaaaa") },
    uBackgroundOpacity: { value: 0.7 },
    uFadeDistance: { value: _ },
    uFadeStrength: { value: b },
    uThickness1: { value: 1 },
    uThickness2: { value: 1 },
    uInfiniteGrid: { value: g ? 1 : 0 },
    uFollowCamera: { value: 0 },
    uCoord0: { value: 0 },
    uCoord1: { value: 2 },
    uCoord2: { value: 1 },
    uGridType: { value: 0 },
    uLineGridCoord: { value: 0 },
    uCircleGridMaxRadius: { value: 9 },
    uPolarCellDividers: { value: 6 },
    uPolarSectionDividers: { value: 2 }
  };
  const O = { x: 0, y: 1, z: 2 }, V = { xz: "xzy", xy: "xyz", zy: "zyx" }, q = An();
  $e(s, q, (w) => t(3, r = w));
  function z(w) {
    Mt[w ? "unshift" : "push"](() => {
      r = w, q.set(r);
    });
  }
  function X(w) {
    T = w, t(0, T);
  }
  return s.$$set = (w) => {
    e = Ve(Ve({}, e), Kt(w)), t(7, i = at(e, n)), "cellColor" in w && t(8, c = w.cellColor), "sectionColor" in w && t(9, l = w.sectionColor), "cellSize" in w && t(10, u = w.cellSize), "backgroundColor" in w && t(11, h = w.backgroundColor), "backgroundOpacity" in w && t(12, f = w.backgroundOpacity), "sectionSize" in w && t(13, d = w.sectionSize), "plane" in w && t(14, A = w.plane), "gridSize" in w && t(1, m = w.gridSize), "followCamera" in w && t(15, p = w.followCamera), "infiniteGrid" in w && t(16, g = w.infiniteGrid), "fadeDistance" in w && t(17, _ = w.fadeDistance), "fadeStrength" in w && t(18, b = w.fadeStrength), "cellThickness" in w && t(19, y = w.cellThickness), "sectionThickness" in w && t(20, v = w.sectionThickness), "type" in w && t(21, x = w.type), "axis" in w && t(22, S = w.axis), "maxRadius" in w && t(23, I = w.maxRadius), "cellDividers" in w && t(24, E = w.cellDividers), "sectionDividers" in w && t(25, M = w.sectionDividers), "ref" in w && t(0, T = w.ref), "$$scope" in w && t(29, o = w.$$scope);
  }, s.$$.update = () => {
    if (s.$$.dirty[0] & /*plane, cellSize, sectionSize, cellColor, sectionColor, backgroundColor, backgroundOpacity, fadeDistance, fadeStrength, cellThickness, sectionThickness, followCamera, infiniteGrid, type, axis, maxRadius, cellDividers, sectionDividers*/
    67108608) {
      const w = V[A], N = w.charAt(0), H = w.charAt(1), j = w.charAt(2);
      t(2, R.uCoord0.value = O[N], R), t(2, R.uCoord1.value = O[H], R), t(2, R.uCoord2.value = O[j], R), t(2, R.uSize1 = { value: u }, R), t(2, R.uSize2 = { value: d }, R), t(2, R.uColor1 = { value: new Pe(c) }, R), t(2, R.uColor2 = { value: new Pe(l) }, R), t(2, R.uBackgroundColor = { value: new Pe(h) }, R), t(2, R.uBackgroundOpacity = { value: f }, R), t(2, R.uFadeDistance = { value: _ }, R), t(2, R.uFadeStrength = { value: b }, R), t(2, R.uThickness1 = { value: y }, R), t(2, R.uThickness2 = { value: v }, R), t(2, R.uFollowCamera = { value: p ? 1 : 0 }, R), t(2, R.uInfiniteGrid = { value: g ? 1 : 0 }, R), x == "grid" && t(2, R.uGridType = { value: 0 }, R), x === "lines" && (t(2, R.uGridType = { value: 1 }, R), t(2, R.uLineGridCoord = { value: O[S] }, R)), x === "circular" && (t(2, R.uGridType = { value: 2 }, R), t(2, R.uCircleGridMaxRadius = { value: I || 0 }, R)), x === "polar" && (t(2, R.uGridType = { value: 3 }, R), t(2, R.uCircleGridMaxRadius = { value: I || 0 }, R), t(2, R.uPolarCellDividers = { value: E || 0 }, R), t(2, R.uPolarSectionDividers = { value: M || 0 }, R)), C();
    }
  }, [
    T,
    m,
    R,
    r,
    D,
    F,
    q,
    i,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    p,
    g,
    _,
    b,
    y,
    v,
    x,
    S,
    I,
    E,
    M,
    a,
    z,
    X,
    o
  ];
}
class BT extends St {
  constructor(e) {
    super(), Et(
      this,
      e,
      TT,
      wT,
      pt,
      {
        cellColor: 8,
        sectionColor: 9,
        cellSize: 10,
        backgroundColor: 11,
        backgroundOpacity: 12,
        sectionSize: 13,
        plane: 14,
        gridSize: 1,
        followCamera: 15,
        infiniteGrid: 16,
        fadeDistance: 17,
        fadeStrength: 18,
        cellThickness: 19,
        sectionThickness: 20,
        type: 21,
        axis: 22,
        maxRadius: 23,
        cellDividers: 24,
        sectionDividers: 25,
        ref: 0
      },
      null,
      [-1, -1]
    );
  }
  get cellColor() {
    return this.$$.ctx[8];
  }
  set cellColor(e) {
    this.$$set({ cellColor: e }), Y();
  }
  get sectionColor() {
    return this.$$.ctx[9];
  }
  set sectionColor(e) {
    this.$$set({ sectionColor: e }), Y();
  }
  get cellSize() {
    return this.$$.ctx[10];
  }
  set cellSize(e) {
    this.$$set({ cellSize: e }), Y();
  }
  get backgroundColor() {
    return this.$$.ctx[11];
  }
  set backgroundColor(e) {
    this.$$set({ backgroundColor: e }), Y();
  }
  get backgroundOpacity() {
    return this.$$.ctx[12];
  }
  set backgroundOpacity(e) {
    this.$$set({ backgroundOpacity: e }), Y();
  }
  get sectionSize() {
    return this.$$.ctx[13];
  }
  set sectionSize(e) {
    this.$$set({ sectionSize: e }), Y();
  }
  get plane() {
    return this.$$.ctx[14];
  }
  set plane(e) {
    this.$$set({ plane: e }), Y();
  }
  get gridSize() {
    return this.$$.ctx[1];
  }
  set gridSize(e) {
    this.$$set({ gridSize: e }), Y();
  }
  get followCamera() {
    return this.$$.ctx[15];
  }
  set followCamera(e) {
    this.$$set({ followCamera: e }), Y();
  }
  get infiniteGrid() {
    return this.$$.ctx[16];
  }
  set infiniteGrid(e) {
    this.$$set({ infiniteGrid: e }), Y();
  }
  get fadeDistance() {
    return this.$$.ctx[17];
  }
  set fadeDistance(e) {
    this.$$set({ fadeDistance: e }), Y();
  }
  get fadeStrength() {
    return this.$$.ctx[18];
  }
  set fadeStrength(e) {
    this.$$set({ fadeStrength: e }), Y();
  }
  get cellThickness() {
    return this.$$.ctx[19];
  }
  set cellThickness(e) {
    this.$$set({ cellThickness: e }), Y();
  }
  get sectionThickness() {
    return this.$$.ctx[20];
  }
  set sectionThickness(e) {
    this.$$set({ sectionThickness: e }), Y();
  }
  get type() {
    return this.$$.ctx[21];
  }
  set type(e) {
    this.$$set({ type: e }), Y();
  }
  get axis() {
    return this.$$.ctx[22];
  }
  set axis(e) {
    this.$$set({ axis: e }), Y();
  }
  get maxRadius() {
    return this.$$.ctx[23];
  }
  set maxRadius(e) {
    this.$$set({ maxRadius: e }), Y();
  }
  get cellDividers() {
    return this.$$.ctx[24];
  }
  set cellDividers(e) {
    this.$$set({ cellDividers: e }), Y();
  }
  get sectionDividers() {
    return this.$$.ctx[25];
  }
  set sectionDividers(e) {
    this.$$set({ sectionDividers: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(e) {
    this.$$set({ ref: e }), Y();
  }
}
xt(BT, { cellColor: {}, sectionColor: {}, cellSize: {}, backgroundColor: {}, backgroundOpacity: {}, sectionSize: {}, plane: {}, gridSize: {}, followCamera: { type: "Boolean" }, infiniteGrid: { type: "Boolean" }, fadeDistance: {}, fadeStrength: {}, cellThickness: {}, sectionThickness: {}, type: {}, axis: {}, maxRadius: {}, cellDividers: {}, sectionDividers: {}, ref: {} }, ["default"], [], !0);
const Bh = (1 + 1e-10) * 100, ag = (s) => `${~~(s.x * Bh)},${~~(s.y * Bh)},${~~(s.z * Bh)}`, RT = (s, e = Math.PI) => {
  const t = Math.cos(e), n = [new P(), new P(), new P()], i = new P(), r = new P(), a = new P(), o = new P(), c = s.getAttribute("position"), l = s.getAttribute("normal"), u = {};
  for (let h = 0, f = c.count / 3; h < f; h += 1) {
    const d = 3 * h;
    n.forEach((m, p) => m.fromBufferAttribute(c, d + p)), i.subVectors(n[2], n[1]), r.subVectors(n[0], n[1]);
    const A = new P().crossVectors(i, r).normalize();
    n.forEach((m) => {
      var g;
      const p = ag(m);
      u[p] || (u[p] = []), (g = u[p]) == null || g.push(A);
    });
  }
  for (let h = 0, f = c.count / 3; h < f; h += 1) {
    const d = 3 * h;
    n.forEach((A, m) => A.fromBufferAttribute(c, d + m)), i.subVectors(n[2], n[1]), r.subVectors(n[0], n[1]), a.crossVectors(i, r).normalize(), n.forEach((A, m) => {
      var g;
      const p = ag(A);
      o.set(0, 0, 0), (g = u[p]) == null || g.forEach((_) => {
        a.dot(_) > t && o.add(_);
      }), o.normalize(), l.setXYZ(d + m, o.x, o.y, o.z);
    });
  }
  return s.setAttribute("normal", l), s;
}, DT = (s) => ({ ref: s & /*ref*/
131072 }), og = (s) => ({ ref: (
  /*ref*/
  s[17]
) });
function LT(s) {
  let e;
  const t = (
    /*#slots*/
    s[12].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[15],
    og
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      163840) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[15],
        e ? gt(
          t,
          /*$$scope*/
          i[15],
          r,
          DT
        ) : _t(
          /*$$scope*/
          i[15]
        ),
        og
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function PT(s) {
  let e, t, n = {
    args: [
      /*shape*/
      s[2],
      /*params*/
      s[1]
    ],
    $$slots: {
      default: [
        LT,
        ({ ref: i }) => ({ 17: i }),
        ({ ref: i }) => i ? 131072 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  return e = new qe.ExtrudeGeometry({ props: n }), s[13](e), e.$on(
    "create",
    /*create_handler*/
    s[14]
  ), {
    c() {
      ze(e.$$.fragment);
    },
    m(i, r) {
      Oe(e, i, r), t = !0;
    },
    p(i, [r]) {
      const a = {};
      r & /*shape, params*/
      6 && (a.args = [
        /*shape*/
        i[2],
        /*params*/
        i[1]
      ]), r & /*$$scope, ref*/
      163840 && (a.$$scope = { dirty: r, ctx: i }), e.$set(a);
    },
    i(i) {
      t || (ae(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ue(e.$$.fragment, i), t = !1;
    },
    d(i) {
      s[13](null), Qe(e, i);
    }
  };
}
const ki = 1e-5;
function UT(s, e, t) {
  let n, i, r, a, o, c, { $$slots: l = {}, $$scope: u } = e;
  const h = An();
  $e(s, h, (y) => t(3, c = y));
  let { args: f = [] } = e, { radius: d = 0.05 } = e, { smoothness: A = 4 } = e, { creaseAngle: m = 0.4 } = e, { steps: p = 1 } = e;
  const g = (y, v, x) => {
    const S = new Pr(), I = x - ki;
    return S.absarc(ki, ki, ki, -Math.PI / 2, -Math.PI, !0), S.absarc(ki, v - I * 2, ki, Math.PI, Math.PI / 2, !0), S.absarc(y - I * 2, v - I * 2, ki, Math.PI / 2, 0, !0), S.absarc(y - I * 2, ki, ki, 0, -Math.PI / 2, !0), S;
  };
  function _(y) {
    Mt[y ? "unshift" : "push"](() => {
      c = y, h.set(c);
    });
  }
  const b = ({ ref: y }) => {
    y.center(), RT(y, m);
  };
  return s.$$set = (y) => {
    "args" in y && t(5, f = y.args), "radius" in y && t(6, d = y.radius), "smoothness" in y && t(7, A = y.smoothness), "creaseAngle" in y && t(0, m = y.creaseAngle), "steps" in y && t(8, p = y.steps), "$$scope" in y && t(15, u = y.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*args*/
    32 && t(11, n = f[0] ?? 1), s.$$.dirty & /*args*/
    32 && t(10, i = f[1] ?? 1), s.$$.dirty & /*args*/
    32 && t(9, r = f[2] ?? 1), s.$$.dirty & /*width, height, radius*/
    3136 && t(2, a = g(n, i, d)), s.$$.dirty & /*depth, radius, smoothness, steps*/
    960 && t(1, o = {
      depth: r - d * 2,
      bevelEnabled: !0,
      bevelSegments: A * 2,
      steps: p,
      bevelSize: d - ki,
      bevelThickness: d,
      curveSegments: A
    });
  }, [
    m,
    o,
    a,
    c,
    h,
    f,
    d,
    A,
    p,
    r,
    i,
    n,
    l,
    _,
    b,
    u
  ];
}
class FT extends St {
  constructor(e) {
    super(), Et(this, e, UT, PT, pt, {
      args: 5,
      radius: 6,
      smoothness: 7,
      creaseAngle: 0,
      steps: 8
    });
  }
  get args() {
    return this.$$.ctx[5];
  }
  set args(e) {
    this.$$set({ args: e }), Y();
  }
  get radius() {
    return this.$$.ctx[6];
  }
  set radius(e) {
    this.$$set({ radius: e }), Y();
  }
  get smoothness() {
    return this.$$.ctx[7];
  }
  set smoothness(e) {
    this.$$set({ smoothness: e }), Y();
  }
  get creaseAngle() {
    return this.$$.ctx[0];
  }
  set creaseAngle(e) {
    this.$$set({ creaseAngle: e }), Y();
  }
  get steps() {
    return this.$$.ctx[8];
  }
  set steps(e) {
    this.$$set({ steps: e }), Y();
  }
}
xt(FT, { args: {}, radius: {}, smoothness: {}, creaseAngle: {}, steps: {} }, ["default"], [], !0);
const ss = new Zo(), Hn = new P(), Ir = new P(), jt = new Rt(), cg = {
  X: new P(1, 0, 0),
  Y: new P(0, 1, 0),
  Z: new P(0, 0, 1)
}, Rh = { type: "change" }, lg = { type: "mouseDown" }, ug = { type: "mouseUp", mode: null }, hg = { type: "objectChange" };
class kT extends bt {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const n = new HT();
    this._gizmo = n, this.add(n);
    const i = new VT();
    this._plane = i, this.add(i);
    const r = this;
    function a(_, b) {
      let y = b;
      Object.defineProperty(r, _, {
        get: function() {
          return y !== void 0 ? y : b;
        },
        set: function(v) {
          y !== v && (y = v, i[_] = v, n[_] = v, r.dispatchEvent({ type: _ + "-changed", value: v }), r.dispatchEvent(Rh));
        }
      }), r[_] = b, i[_] = b, n[_] = b;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "world"), a("size", 1), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const o = new P(), c = new P(), l = new Rt(), u = new Rt(), h = new P(), f = new Rt(), d = new P(), A = new P(), m = new P(), p = 0, g = new P();
    a("worldPosition", o), a("worldPositionStart", c), a("worldQuaternion", l), a("worldQuaternionStart", u), a("cameraPosition", h), a("cameraQuaternion", f), a("pointStart", d), a("pointEnd", A), a("rotationAxis", m), a("rotationAngle", p), a("eye", g), this._offset = new P(), this._startNorm = new P(), this._endNorm = new P(), this._cameraScale = new P(), this._parentPosition = new P(), this._parentQuaternion = new Rt(), this._parentQuaternionInv = new Rt(), this._parentScale = new P(), this._worldScaleStart = new P(), this._worldQuaternionInv = new Rt(), this._worldScale = new P(), this._positionStart = new P(), this._quaternionStart = new Rt(), this._scaleStart = new P(), this._getPointer = NT.bind(this), this._onPointerDown = QT.bind(this), this._onPointerHover = OT.bind(this), this._onPointerMove = GT.bind(this), this._onPointerUp = zT.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    ss.setFromCamera(e, this.camera);
    const t = Dh(this._gizmo.picker[this.mode], ss);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      ss.setFromCamera(e, this.camera);
      const t = Dh(this._plane, ss, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, lg.mode = this.mode, this.dispatchEvent(lg);
    }
  }
  pointerMove(e) {
    const t = this.axis, n = this.mode, i = this.object;
    let r = this.space;
    if (n === "scale" ? r = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (r = "world"), i === void 0 || t === null || this.dragging === !1 || e.button !== -1)
      return;
    ss.setFromCamera(e, this.camera);
    const a = Dh(this._plane, ss, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (i.position.applyQuaternion(jt.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), r === "world" && (i.parent && i.position.add(Hn.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Hn.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), Ir.set(o, o, o);
        } else
          Hn.copy(this.pointStart), Ir.copy(this.pointEnd), Hn.applyQuaternion(this._worldQuaternionInv), Ir.applyQuaternion(this._worldQuaternionInv), Ir.divide(Hn), t.search("X") === -1 && (Ir.x = 1), t.search("Y") === -1 && (Ir.y = 1), t.search("Z") === -1 && (Ir.z = 1);
        i.scale.copy(this._scaleStart).multiply(Ir), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(Hn.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Hn.copy(this.rotationAxis).cross(this.eye)) * o) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(cg[t]), Hn.copy(cg[t]), r === "local" && Hn.applyQuaternion(this.worldQuaternion), Hn.cross(this.eye), Hn.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(Hn.normalize()) * o), (t === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(jt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(jt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Rh), this.dispatchEvent(hg);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (ug.mode = this.mode, this.dispatchEvent(ug)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  // Set current object
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Rh), this.dispatchEvent(hg), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return ss;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function NT(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function OT(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function QT(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function GT(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function zT(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function Dh(s, e, t) {
  const n = e.intersectObject(s, !0);
  for (let i = 0; i < n.length; i++)
    if (n[i].object.visible || t)
      return n[i];
  return !1;
}
const $c = new Ds(), Nt = new P(0, 1, 0), fg = new P(0, 0, 0), dg = new Je(), el = new Rt(), Al = new Rt(), Ni = new P(), pg = new Je(), fo = new P(1, 0, 0), hs = new P(0, 1, 0), po = new P(0, 0, 1), tl = new P(), io = new P(), ro = new P();
class HT extends bt {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new In({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new kn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = e.clone();
    n.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const r = e.clone();
    r.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const l = e.clone();
    l.color.setHex(65280), l.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(255), u.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const f = e.clone();
    f.color.setHex(16776960), f.opacity = 0.25, e.clone().color.setHex(16776960);
    const A = e.clone();
    A.color.setHex(7895160);
    const m = new hn(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const p = new en(0.08, 0.08, 0.08);
    p.translate(0, 0.04, 0);
    const g = new ot();
    g.setAttribute("position", new je([0, 0, 0, 1, 0, 0], 3));
    const _ = new hn(75e-4, 75e-4, 0.5, 3);
    _.translate(0, 0.25, 0);
    function b(R, O) {
      const V = new cr(R, 75e-4, 3, 64, O * Math.PI * 2);
      return V.rotateY(Math.PI / 2), V.rotateX(Math.PI / 2), V;
    }
    function y() {
      const R = new ot();
      return R.setAttribute("position", new je([0, 0, 0, 1, 1, 1], 3)), R;
    }
    const v = {
      X: [
        [new Ne(m, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ne(m, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Ne(_, r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Ne(m, a), [0, 0.5, 0]],
        [new Ne(m, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Ne(_, a)]
      ],
      Z: [
        [new Ne(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ne(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Ne(_, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ne(new hr(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Ne(new en(0.15, 0.15, 0.01), u.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ne(new en(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ne(new en(0.15, 0.15, 0.01), l.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, x = {
      X: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ne(new hr(0.2, 0), n)]
      ],
      XY: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, S = {
      START: [
        [new Ne(new hr(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Ne(new hr(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Dn(y(), i), null, null, null, "helper"]
      ],
      X: [
        [new Dn(g, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Dn(g, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Dn(g, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, I = {
      XYZE: [
        [new Ne(b(0.5, 1), A), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Ne(b(0.5, 0.5), r)]
      ],
      Y: [
        [new Ne(b(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Ne(b(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Ne(b(0.75, 1), f), null, [0, Math.PI / 2, 0]]
      ]
    }, E = {
      AXIS: [
        [new Dn(g, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, M = {
      XYZE: [
        [new Ne(new Da(0.25, 10, 8), n)]
      ],
      X: [
        [new Ne(new cr(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Ne(new cr(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Ne(new cr(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Ne(new cr(0.75, 0.1, 2, 24), n)]
      ]
    }, T = {
      X: [
        [new Ne(p, r), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ne(_, r), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ne(p, r), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ne(p, a), [0, 0.5, 0]],
        [new Ne(_, a)],
        [new Ne(p, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ne(p, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ne(_, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Ne(p, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ne(new en(0.15, 0.15, 0.01), u), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ne(new en(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ne(new en(0.15, 0.15, 0.01), l), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ne(new en(0.1, 0.1, 0.1), h.clone())]
      ]
    }, D = {
      X: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ne(new hn(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ne(new en(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ne(new en(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, F = {
      X: [
        [new Dn(g, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Dn(g, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Dn(g, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function C(R) {
      const O = new bt();
      for (const V in R)
        for (let q = R[V].length; q--; ) {
          const z = R[V][q][0].clone(), X = R[V][q][1], w = R[V][q][2], N = R[V][q][3], H = R[V][q][4];
          z.name = V, z.tag = H, X && z.position.set(X[0], X[1], X[2]), w && z.rotation.set(w[0], w[1], w[2]), N && z.scale.set(N[0], N[1], N[2]), z.updateMatrix();
          const j = z.geometry.clone();
          j.applyMatrix4(z.matrix), z.geometry = j, z.renderOrder = 1 / 0, z.position.set(0, 0, 0), z.rotation.set(0, 0, 0), z.scale.set(1, 1, 1), O.add(z);
        }
      return O;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = C(v)), this.add(this.gizmo.rotate = C(I)), this.add(this.gizmo.scale = C(T)), this.add(this.picker.translate = C(x)), this.add(this.picker.rotate = C(M)), this.add(this.picker.scale = C(D)), this.add(this.helper.translate = C(S)), this.add(this.helper.rotate = C(E)), this.add(this.helper.scale = C(F)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const n = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Al;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let r = 0; r < i.length; r++) {
      const a = i[r];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (jt.setFromEuler($c.set(0, 0, 0)), a.quaternion.copy(n).multiply(jt), Math.abs(Nt.copy(fo).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (jt.setFromEuler($c.set(0, 0, Math.PI / 2)), a.quaternion.copy(n).multiply(jt), Math.abs(Nt.copy(hs).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (jt.setFromEuler($c.set(0, Math.PI / 2, 0)), a.quaternion.copy(n).multiply(jt), Math.abs(Nt.copy(po).applyQuaternion(n).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (jt.setFromEuler($c.set(0, Math.PI / 2, 0)), Nt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(dg.lookAt(fg, Nt, hs)), a.quaternion.multiply(jt), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Hn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Hn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Hn), a.visible = this.dragging) : (a.quaternion.copy(n), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(n), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(Nt.copy(fo).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(Nt.copy(hs).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(Nt.copy(po).applyQuaternion(n).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(Nt.copy(po).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(Nt.copy(fo).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(Nt.copy(hs).applyQuaternion(n).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (el.copy(n), Nt.copy(this.eye).applyQuaternion(jt.copy(n).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(dg.lookAt(this.eye, fg, hs)), a.name === "X" && (jt.setFromAxisAngle(fo, Math.atan2(-Nt.y, Nt.z)), jt.multiplyQuaternions(el, jt), a.quaternion.copy(jt)), a.name === "Y" && (jt.setFromAxisAngle(hs, Math.atan2(Nt.x, Nt.z)), jt.multiplyQuaternions(el, jt), a.quaternion.copy(jt)), a.name === "Z" && (jt.setFromAxisAngle(po, Math.atan2(Nt.y, Nt.x)), jt.multiplyQuaternions(el, jt), a.quaternion.copy(jt))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(c) {
        return a.name === c;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class VT extends Ne {
  constructor() {
    super(
      new ji(1e5, 1e5, 2, 2),
      new In({ visible: !1, wireframe: !0, side: Mn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), tl.copy(fo).applyQuaternion(t === "local" ? this.worldQuaternion : Al), io.copy(hs).applyQuaternion(t === "local" ? this.worldQuaternion : Al), ro.copy(po).applyQuaternion(t === "local" ? this.worldQuaternion : Al), Nt.copy(io), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Nt.copy(this.eye).cross(tl), Ni.copy(tl).cross(Nt);
            break;
          case "Y":
            Nt.copy(this.eye).cross(io), Ni.copy(io).cross(Nt);
            break;
          case "Z":
            Nt.copy(this.eye).cross(ro), Ni.copy(ro).cross(Nt);
            break;
          case "XY":
            Ni.copy(ro);
            break;
          case "YZ":
            Ni.copy(tl);
            break;
          case "XZ":
            Nt.copy(ro), Ni.copy(io);
            break;
          case "XYZ":
          case "E":
            Ni.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Ni.set(0, 0, 0);
    }
    Ni.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (pg.lookAt(Hn.set(0, 0, 0), Ni, Nt), this.quaternion.setFromRotationMatrix(pg)), super.updateMatrixWorld(e);
  }
}
const K_ = () => Ld("threlte-controls", {
  orbitControls: vt(void 0)
}), WT = (s) => ({ ref: s & /*ref*/
67108864 }), Ag = (s) => ({ ref: (
  /*ref*/
  s[26]
) });
function qT(s) {
  let e, t;
  const n = [
    { is: (
      /*$controlsStore*/
      s[1]
    ) },
    /*transformProps*/
    s[2]
  ];
  let i = {};
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[14](e), e.$on(
    "dragging-changed",
    /*onDraggingChanged*/
    s[7]
  ), e.$on(
    "change",
    /*invalidate*/
    s[5]
  ), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*$controlsStore, transformProps*/
      6 ? Qt(n, [
        a & /*$controlsStore*/
        2 && { is: (
          /*$controlsStore*/
          r[1]
        ) },
        a & /*transformProps*/
        4 && qt(
          /*transformProps*/
          r[2]
        )
      ]) : {};
      e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[14](null), Qe(e, r);
    }
  };
}
function XT(s) {
  let e;
  const t = (
    /*#slots*/
    s[13].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[17],
    Ag
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      67239936) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? gt(
          t,
          /*$$scope*/
          i[17],
          r,
          WT
        ) : _t(
          /*$$scope*/
          i[17]
        ),
        Ag
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function YT(s) {
  let e, t, n, i;
  e = new Pa({
    props: {
      onChildMount: (
        /*func*/
        s[15]
      ),
      onChildDestroy: (
        /*func_1*/
        s[16]
      ),
      $$slots: { default: [qT] },
      $$scope: { ctx: s }
    }
  });
  const r = [
    { is: (
      /*group*/
      s[0]
    ) },
    /*objectProps*/
    s[3]
  ];
  let a = {
    $$slots: {
      default: [
        XT,
        ({ ref: o }) => ({ 26: o }),
        ({ ref: o }) => o ? 67108864 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < r.length; o += 1)
    a = Ve(a, r[o]);
  return n = new qe({ props: a }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment);
    },
    m(o, c) {
      Oe(e, o, c), st(o, t, c), Oe(n, o, c), i = !0;
    },
    p(o, [c]) {
      const l = {};
      c & /*$$scope, $controlsStore, transformProps, $component*/
      131094 && (l.$$scope = { dirty: c, ctx: o }), e.$set(l);
      const u = c & /*group, objectProps*/
      9 ? Qt(r, [
        c & /*group*/
        1 && { is: (
          /*group*/
          o[0]
        ) },
        c & /*objectProps*/
        8 && qt(
          /*objectProps*/
          o[3]
        )
      ]) : {};
      c & /*$$scope, ref*/
      67239936 && (u.$$scope = { dirty: c, ctx: o }), n.$set(u);
    },
    i(o) {
      i || (ae(e.$$.fragment, o), ae(n.$$.fragment, o), i = !0);
    },
    o(o) {
      ue(e.$$.fragment, o), ue(n.$$.fragment, o), i = !1;
    },
    d(o) {
      o && rt(t), Qe(e, o), Qe(n, o);
    }
  };
}
function jT(s, e, t) {
  const n = ["autoPauseOrbitControls", "object", "group", "controls"];
  let i = at(e, n), r, a, { $$slots: o = {}, $$scope: c } = e, { autoPauseOrbitControls: l = !0 } = e, { object: u = void 0 } = e;
  const { camera: h, renderer: f, invalidate: d, scene: A } = sn(), { orbitControls: m } = K_(), p = vt(!1), g = vt(l) ?? !0, _ = (C) => {
    p.set(C.value);
  };
  Ft([m, p, g], ([C, R, O]) => {
    if (!(!C || !C.enabled && R))
      return C.enabled = !(R && O), () => {
        C.enabled = !0;
      };
  });
  const b = new Un(), y = Vn(h, (C) => new kT(C, f.domElement));
  $e(s, y, (C) => t(1, r = C));
  let { controls: v = r } = e;
  const x = vt(u ?? b);
  Ft([y, x], ([C, R]) => (C.attach(R), () => {
    C.detach();
  }));
  const S = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible"
  ];
  let I = {}, E = {};
  const M = An();
  $e(s, M, (C) => t(4, a = C));
  function T(C) {
    Mt[C ? "unshift" : "push"](() => {
      a = C, M.set(a);
    });
  }
  const D = (C) => {
    A.add(C);
  }, F = (C) => {
    A.remove(C);
  };
  return s.$$set = (C) => {
    e = Ve(Ve({}, e), Kt(C)), t(25, i = at(e, n)), "autoPauseOrbitControls" in C && t(11, l = C.autoPauseOrbitControls), "object" in C && t(12, u = C.object), "controls" in C && t(10, v = C.controls), "$$scope" in C && t(17, c = C.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*autoPauseOrbitControls*/
    2048 && g.set(l ?? !0), s.$$.dirty & /*$controlsStore*/
    2 && t(10, v = r);
    {
      t(2, I = {}), t(3, E = {});
      for (let [C, R] of Object.entries(i))
        S.includes(C) ? t(2, I[C] = R, I) : t(3, E[C] = R, E);
    }
  }, [
    b,
    r,
    I,
    E,
    a,
    d,
    A,
    _,
    y,
    M,
    v,
    l,
    u,
    o,
    T,
    D,
    F,
    c
  ];
}
class JT extends St {
  constructor(e) {
    super(), Et(this, e, jT, YT, pt, {
      autoPauseOrbitControls: 11,
      object: 12,
      group: 0,
      controls: 10
    });
  }
  get autoPauseOrbitControls() {
    return this.$$.ctx[11];
  }
  set autoPauseOrbitControls(e) {
    this.$$set({ autoPauseOrbitControls: e }), Y();
  }
  get object() {
    return this.$$.ctx[12];
  }
  set object(e) {
    this.$$set({ object: e }), Y();
  }
  get group() {
    return this.$$.ctx[0];
  }
  get controls() {
    return this.$$.ctx[10];
  }
  set controls(e) {
    this.$$set({ controls: e }), Y();
  }
}
xt(JT, { autoPauseOrbitControls: { type: "Boolean" }, object: {}, controls: {} }, ["default"], ["group"], !0);
const gg = { type: "change" }, Lh = { type: "start" }, mg = { type: "end" }, nl = new Rs(), _g = new ar(), KT = Math.cos(70 * Cs.DEG2RAD);
let ZT = class extends Yi {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new P(), this.cursor = new P(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: os.ROTATE, MIDDLE: os.DOLLY, RIGHT: os.PAN }, this.touches = { ONE: cs.ROTATE, TWO: cs.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o.phi;
    }, this.getAzimuthalAngle = function() {
      return o.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(Q) {
      Q.addEventListener("keydown", B), this._domElementKeyEvents = Q;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", B), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = function() {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(gg), n.update(), r = i.NONE;
    }, this.update = function() {
      const Q = new P(), Me = new Rt().setFromUnitVectors(e.up, new P(0, 1, 0)), pe = Me.clone().invert(), Le = new P(), Fe = new Rt(), Ge = new P(), Ue = 2 * Math.PI;
      return function(Ye = null) {
        const J = n.object.position;
        Q.copy(J).sub(n.target), Q.applyQuaternion(Me), o.setFromVector3(Q), n.autoRotate && r === i.NONE && T(E(Ye)), n.enableDamping ? (o.theta += c.theta * n.dampingFactor, o.phi += c.phi * n.dampingFactor) : (o.theta += c.theta, o.phi += c.phi);
        let ke = n.minAzimuthAngle, Te = n.maxAzimuthAngle;
        isFinite(ke) && isFinite(Te) && (ke < -Math.PI ? ke += Ue : ke > Math.PI && (ke -= Ue), Te < -Math.PI ? Te += Ue : Te > Math.PI && (Te -= Ue), ke <= Te ? o.theta = Math.max(ke, Math.min(Te, o.theta)) : o.theta = o.theta > (ke + Te) / 2 ? Math.max(ke, o.theta) : Math.min(Te, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), n.target.sub(n.cursor), n.target.clampLength(n.minTargetRadius, n.maxTargetRadius), n.target.add(n.cursor), n.zoomToCursor && x || n.object.isOrthographicCamera ? o.radius = z(o.radius) : o.radius = z(o.radius * l), Q.setFromSpherical(o), Q.applyQuaternion(pe), J.copy(n.target).add(Q), n.object.lookAt(n.target), n.enableDamping === !0 ? (c.theta *= 1 - n.dampingFactor, c.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (c.set(0, 0, 0), u.set(0, 0, 0));
        let Ee = !1;
        if (n.zoomToCursor && x) {
          let Re = null;
          if (n.object.isPerspectiveCamera) {
            const Xe = Q.length();
            Re = z(Xe * l);
            const Ke = Xe - Re;
            n.object.position.addScaledVector(y, Ke), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const Xe = new P(v.x, v.y, 0);
            Xe.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)), n.object.updateProjectionMatrix(), Ee = !0;
            const Ke = new P(v.x, v.y, 0);
            Ke.unproject(n.object), n.object.position.sub(Ke).add(Xe), n.object.updateMatrixWorld(), Re = Q.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          Re !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(Re).add(n.object.position) : (nl.origin.copy(n.object.position), nl.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(nl.direction)) < KT ? e.lookAt(n.target) : (_g.setFromNormalAndCoplanarPoint(n.object.up, n.target), nl.intersectPlane(_g, n.target))));
        } else
          n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)), n.object.updateProjectionMatrix(), Ee = !0);
        return l = 1, x = !1, Ee || Le.distanceToSquared(n.object.position) > a || 8 * (1 - Fe.dot(n.object.quaternion)) > a || Ge.distanceToSquared(n.target) > 0 ? (n.dispatchEvent(gg), Le.copy(n.object.position), Fe.copy(n.object.quaternion), Ge.copy(n.target), !0) : !1;
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", Ae), n.domElement.removeEventListener("pointerdown", se), n.domElement.removeEventListener("pointercancel", ve), n.domElement.removeEventListener("wheel", L), n.domElement.removeEventListener("pointermove", K), n.domElement.removeEventListener("pointerup", ve), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", B), n._domElementKeyEvents = null);
    };
    const n = this, i = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let r = i.NONE;
    const a = 1e-6, o = new Rf(), c = new Rf();
    let l = 1;
    const u = new P(), h = new xe(), f = new xe(), d = new xe(), A = new xe(), m = new xe(), p = new xe(), g = new xe(), _ = new xe(), b = new xe(), y = new P(), v = new xe();
    let x = !1;
    const S = [], I = {};
    function E(Q) {
      return Q !== null ? 2 * Math.PI / 60 * n.autoRotateSpeed * Q : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function M() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function T(Q) {
      c.theta -= Q;
    }
    function D(Q) {
      c.phi -= Q;
    }
    const F = function() {
      const Q = new P();
      return function(pe, Le) {
        Q.setFromMatrixColumn(Le, 0), Q.multiplyScalar(-pe), u.add(Q);
      };
    }(), C = function() {
      const Q = new P();
      return function(pe, Le) {
        n.screenSpacePanning === !0 ? Q.setFromMatrixColumn(Le, 1) : (Q.setFromMatrixColumn(Le, 0), Q.crossVectors(n.object.up, Q)), Q.multiplyScalar(pe), u.add(Q);
      };
    }(), R = function() {
      const Q = new P();
      return function(pe, Le) {
        const Fe = n.domElement;
        if (n.object.isPerspectiveCamera) {
          const Ge = n.object.position;
          Q.copy(Ge).sub(n.target);
          let Ue = Q.length();
          Ue *= Math.tan(n.object.fov / 2 * Math.PI / 180), F(2 * pe * Ue / Fe.clientHeight, n.object.matrix), C(2 * Le * Ue / Fe.clientHeight, n.object.matrix);
        } else
          n.object.isOrthographicCamera ? (F(pe * (n.object.right - n.object.left) / n.object.zoom / Fe.clientWidth, n.object.matrix), C(Le * (n.object.top - n.object.bottom) / n.object.zoom / Fe.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    }();
    function O(Q) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l /= Q : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function V(Q) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l *= Q : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function q(Q) {
      if (!n.zoomToCursor)
        return;
      x = !0;
      const Me = n.domElement.getBoundingClientRect(), pe = Q.clientX - Me.left, Le = Q.clientY - Me.top, Fe = Me.width, Ge = Me.height;
      v.x = pe / Fe * 2 - 1, v.y = -(Le / Ge) * 2 + 1, y.set(v.x, v.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function z(Q) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, Q));
    }
    function X(Q) {
      h.set(Q.clientX, Q.clientY);
    }
    function w(Q) {
      q(Q), g.set(Q.clientX, Q.clientY);
    }
    function N(Q) {
      A.set(Q.clientX, Q.clientY);
    }
    function H(Q) {
      f.set(Q.clientX, Q.clientY), d.subVectors(f, h).multiplyScalar(n.rotateSpeed);
      const Me = n.domElement;
      T(2 * Math.PI * d.x / Me.clientHeight), D(2 * Math.PI * d.y / Me.clientHeight), h.copy(f), n.update();
    }
    function j(Q) {
      _.set(Q.clientX, Q.clientY), b.subVectors(_, g), b.y > 0 ? O(M()) : b.y < 0 && V(M()), g.copy(_), n.update();
    }
    function $(Q) {
      m.set(Q.clientX, Q.clientY), p.subVectors(m, A).multiplyScalar(n.panSpeed), R(p.x, p.y), A.copy(m), n.update();
    }
    function ce(Q) {
      q(Q), Q.deltaY < 0 ? V(M()) : Q.deltaY > 0 && O(M()), n.update();
    }
    function ee(Q) {
      let Me = !1;
      switch (Q.code) {
        case n.keys.UP:
          Q.ctrlKey || Q.metaKey || Q.shiftKey ? D(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : R(0, n.keyPanSpeed), Me = !0;
          break;
        case n.keys.BOTTOM:
          Q.ctrlKey || Q.metaKey || Q.shiftKey ? D(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : R(0, -n.keyPanSpeed), Me = !0;
          break;
        case n.keys.LEFT:
          Q.ctrlKey || Q.metaKey || Q.shiftKey ? T(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : R(n.keyPanSpeed, 0), Me = !0;
          break;
        case n.keys.RIGHT:
          Q.ctrlKey || Q.metaKey || Q.shiftKey ? T(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : R(-n.keyPanSpeed, 0), Me = !0;
          break;
      }
      Me && (Q.preventDefault(), n.update());
    }
    function le() {
      if (S.length === 1)
        h.set(S[0].pageX, S[0].pageY);
      else {
        const Q = 0.5 * (S[0].pageX + S[1].pageX), Me = 0.5 * (S[0].pageY + S[1].pageY);
        h.set(Q, Me);
      }
    }
    function Z() {
      if (S.length === 1)
        A.set(S[0].pageX, S[0].pageY);
      else {
        const Q = 0.5 * (S[0].pageX + S[1].pageX), Me = 0.5 * (S[0].pageY + S[1].pageY);
        A.set(Q, Me);
      }
    }
    function he() {
      const Q = S[0].pageX - S[1].pageX, Me = S[0].pageY - S[1].pageY, pe = Math.sqrt(Q * Q + Me * Me);
      g.set(0, pe);
    }
    function _e() {
      n.enableZoom && he(), n.enablePan && Z();
    }
    function U() {
      n.enableZoom && he(), n.enableRotate && le();
    }
    function ye(Q) {
      if (S.length == 1)
        f.set(Q.pageX, Q.pageY);
      else {
        const pe = De(Q), Le = 0.5 * (Q.pageX + pe.x), Fe = 0.5 * (Q.pageY + pe.y);
        f.set(Le, Fe);
      }
      d.subVectors(f, h).multiplyScalar(n.rotateSpeed);
      const Me = n.domElement;
      T(2 * Math.PI * d.x / Me.clientHeight), D(2 * Math.PI * d.y / Me.clientHeight), h.copy(f);
    }
    function ie(Q) {
      if (S.length === 1)
        m.set(Q.pageX, Q.pageY);
      else {
        const Me = De(Q), pe = 0.5 * (Q.pageX + Me.x), Le = 0.5 * (Q.pageY + Me.y);
        m.set(pe, Le);
      }
      p.subVectors(m, A).multiplyScalar(n.panSpeed), R(p.x, p.y), A.copy(m);
    }
    function re(Q) {
      const Me = De(Q), pe = Q.pageX - Me.x, Le = Q.pageY - Me.y, Fe = Math.sqrt(pe * pe + Le * Le);
      _.set(0, Fe), b.set(0, Math.pow(_.y / g.y, n.zoomSpeed)), O(b.y), g.copy(_);
    }
    function te(Q) {
      n.enableZoom && re(Q), n.enablePan && ie(Q);
    }
    function Ie(Q) {
      n.enableZoom && re(Q), n.enableRotate && ye(Q);
    }
    function se(Q) {
      n.enabled !== !1 && (S.length === 0 && (n.domElement.setPointerCapture(Q.pointerId), n.domElement.addEventListener("pointermove", K), n.domElement.addEventListener("pointerup", ve)), G(Q), Q.pointerType === "touch" ? W(Q) : fe(Q));
    }
    function K(Q) {
      n.enabled !== !1 && (Q.pointerType === "touch" ? de(Q) : oe(Q));
    }
    function ve(Q) {
      Ce(Q), S.length === 0 && (n.domElement.releasePointerCapture(Q.pointerId), n.domElement.removeEventListener("pointermove", K), n.domElement.removeEventListener("pointerup", ve)), n.dispatchEvent(mg), r = i.NONE;
    }
    function fe(Q) {
      let Me;
      switch (Q.button) {
        case 0:
          Me = n.mouseButtons.LEFT;
          break;
        case 1:
          Me = n.mouseButtons.MIDDLE;
          break;
        case 2:
          Me = n.mouseButtons.RIGHT;
          break;
        default:
          Me = -1;
      }
      switch (Me) {
        case os.DOLLY:
          if (n.enableZoom === !1)
            return;
          w(Q), r = i.DOLLY;
          break;
        case os.ROTATE:
          if (Q.ctrlKey || Q.metaKey || Q.shiftKey) {
            if (n.enablePan === !1)
              return;
            N(Q), r = i.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            X(Q), r = i.ROTATE;
          }
          break;
        case os.PAN:
          if (Q.ctrlKey || Q.metaKey || Q.shiftKey) {
            if (n.enableRotate === !1)
              return;
            X(Q), r = i.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            N(Q), r = i.PAN;
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(Lh);
    }
    function oe(Q) {
      switch (r) {
        case i.ROTATE:
          if (n.enableRotate === !1)
            return;
          H(Q);
          break;
        case i.DOLLY:
          if (n.enableZoom === !1)
            return;
          j(Q);
          break;
        case i.PAN:
          if (n.enablePan === !1)
            return;
          $(Q);
          break;
      }
    }
    function L(Q) {
      n.enabled === !1 || n.enableZoom === !1 || r !== i.NONE || (Q.preventDefault(), n.dispatchEvent(Lh), ce(Q), n.dispatchEvent(mg));
    }
    function B(Q) {
      n.enabled === !1 || n.enablePan === !1 || ee(Q);
    }
    function W(Q) {
      switch (Se(Q), S.length) {
        case 1:
          switch (n.touches.ONE) {
            case cs.ROTATE:
              if (n.enableRotate === !1)
                return;
              le(), r = i.TOUCH_ROTATE;
              break;
            case cs.PAN:
              if (n.enablePan === !1)
                return;
              Z(), r = i.TOUCH_PAN;
              break;
            default:
              r = i.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case cs.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              _e(), r = i.TOUCH_DOLLY_PAN;
              break;
            case cs.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              U(), r = i.TOUCH_DOLLY_ROTATE;
              break;
            default:
              r = i.NONE;
          }
          break;
        default:
          r = i.NONE;
      }
      r !== i.NONE && n.dispatchEvent(Lh);
    }
    function de(Q) {
      switch (Se(Q), r) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          ye(Q), n.update();
          break;
        case i.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          ie(Q), n.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          te(Q), n.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          Ie(Q), n.update();
          break;
        default:
          r = i.NONE;
      }
    }
    function Ae(Q) {
      n.enabled !== !1 && Q.preventDefault();
    }
    function G(Q) {
      S.push(Q);
    }
    function Ce(Q) {
      delete I[Q.pointerId];
      for (let Me = 0; Me < S.length; Me++)
        if (S[Me].pointerId == Q.pointerId) {
          S.splice(Me, 1);
          return;
        }
    }
    function Se(Q) {
      let Me = I[Q.pointerId];
      Me === void 0 && (Me = new xe(), I[Q.pointerId] = Me), Me.set(Q.pageX, Q.pageY);
    }
    function De(Q) {
      const Me = Q.pointerId === S[0].pointerId ? S[1] : S[0];
      return I[Me.pointerId];
    }
    n.domElement.addEventListener("contextmenu", Ae), n.domElement.addEventListener("pointerdown", se), n.domElement.addEventListener("pointercancel", ve), n.domElement.addEventListener("wheel", L, { passive: !1 }), this.update();
  }
};
const $T = (s) => ({ ref: s & /*ref*/
1 }), bg = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function e2(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[10],
    bg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      1025) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? gt(
          t,
          /*$$scope*/
          i[10],
          r,
          $T
        ) : _t(
          /*$$scope*/
          i[10]
        ),
        bg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function t2(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[6]
  ];
  let i = {
    $$slots: {
      default: [e2, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[8](e), e.$on(
    "change",
    /*invalidate*/
    s[3]
  ), e.$on(
    "create",
    /*create_handler*/
    s[9]
  ), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      65 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        64 && qt(
          /*$$restProps*/
          r[6]
        )
      ]) : {};
      a & /*$$scope, ref*/
      1025 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
function n2(s, e, t) {
  const n = ["ref"];
  let i = at(e, n), r, a, { $$slots: o = {}, $$scope: c } = e;
  const l = Fs();
  $e(s, l, (y) => t(11, r = y));
  const u = (y) => y.isCamera, { renderer: h, invalidate: f } = sn();
  if (!u(r))
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  const d = new ZT(r, h.domElement), { start: A, stop: m } = bi(() => d.update(), { autoStart: !1 }), p = An();
  $e(s, p, (y) => t(1, a = y));
  const { orbitControls: g } = K_();
  function _(y) {
    Mt[y ? "unshift" : "push"](() => {
      a = y, p.set(a);
    });
  }
  const b = ({ ref: y, cleanup: v }) => {
    g.set(y), y.update(), v(() => {
      g.set(void 0);
    });
  };
  return s.$$set = (y) => {
    e = Ve(Ve({}, e), Kt(y)), t(6, i = at(e, n)), "$$scope" in y && t(10, c = y.$$scope);
  }, s.$$.update = () => {
    i.autoRotate || i.enableDamping ? A() : m();
  }, [
    d,
    a,
    l,
    f,
    p,
    g,
    i,
    o,
    _,
    b,
    c
  ];
}
class i2 extends St {
  constructor(e) {
    super(), Et(this, e, n2, t2, pt, { ref: 0 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
xt(i2, {}, ["default"], ["ref"], !0);
const Z_ = (s) => `threlte-instanced-mesh-${s}`, r2 = (s, e) => {
  const t = {
    instancedMesh: Ht(s),
    addInstance(n) {
      t.instances.update((i) => (i.push(n), i));
    },
    removeInstance(n) {
      t.instances.update((i) => {
        const r = i.indexOf(n);
        return r > -1 && i.splice(r, 1), i;
      });
    },
    instances: Ht([])
  };
  return Jn(Z_(e), t), t;
}, s2 = (s) => {
  const e = Wn(Z_(s));
  if (!e)
    throw new Error(`No <InstancedMesh> component found for id ${s}`);
  return e;
};
function a2(s) {
  let e, t, n, i, r;
  e = new qe.InstancedBufferAttribute({
    props: {
      attach: "instanceMatrix",
      count: (
        /*matrices*/
        s[1].length / 16
      ),
      array: (
        /*matrices*/
        s[1]
      ),
      itemSize: 16,
      usage: vf
    }
  }), n = new qe.InstancedBufferAttribute({
    props: {
      attach: "instanceColor",
      count: (
        /*colors*/
        s[2].length / 3
      ),
      array: (
        /*colors*/
        s[2]
      ),
      itemSize: 3,
      usage: vf
    }
  });
  const a = (
    /*#slots*/
    s[9].default
  ), o = At(
    a,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment), i = Pt(), o && o.c();
    },
    m(c, l) {
      Oe(e, c, l), st(c, t, l), Oe(n, c, l), st(c, i, l), o && o.m(c, l), r = !0;
    },
    p(c, [l]) {
      o && o.p && (!r || l & /*$$scope*/
      256) && mt(
        o,
        a,
        c,
        /*$$scope*/
        c[8],
        r ? gt(
          a,
          /*$$scope*/
          c[8],
          l,
          null
        ) : _t(
          /*$$scope*/
          c[8]
        ),
        null
      );
    },
    i(c) {
      r || (ae(e.$$.fragment, c), ae(n.$$.fragment, c), ae(o, c), r = !0);
    },
    o(c) {
      ue(e.$$.fragment, c), ue(n.$$.fragment, c), ue(o, c), r = !1;
    },
    d(c) {
      c && (rt(t), rt(i)), Qe(e, c), Qe(n, c), o && o.d(c);
    }
  };
}
function o2(s, e, t) {
  let n, { $$slots: i = {}, $$scope: r } = e, { instancedMesh: a } = e, { id: o } = e, { limit: c } = e, { range: l } = e, { update: u } = e;
  const { instances: h } = r2(a, o);
  $e(s, h, (v) => t(11, n = v));
  const f = new Je(), d = new Float32Array(c * 16);
  for (let v = 0; v < c; v++)
    f.identity().toArray(d, v * 16);
  const A = new Float32Array([...new Array(c * 3)].map(() => 1)), m = new Je(), p = new Je(), g = new P(), _ = new Rt(), b = new P();
  let y = !1;
  return bi(() => {
    if (a.updateMatrix(), u || !y) {
      a.updateMatrixWorld(), m.copy(a.matrixWorld).invert();
      const v = Math.min(c, l !== void 0 ? l : c, n.length);
      t(3, a.count = v, a), t(3, a.instanceMatrix.updateRange.count = v * 16, a), a.instanceColor && t(3, a.instanceColor.updateRange.count = v * 3, a), a.instanceColor && t(3, a.instanceColor.needsUpdate = !0, a), t(3, a.instanceMatrix.needsUpdate = !0, a);
      for (let x = 0; x < h.current.length; x++) {
        const S = h.current[x];
        S.matrixWorld.decompose(g, _, b), p.compose(g, _, b).premultiply(m), p.toArray(d, x * 16), S.color.toArray(A, x * 3);
      }
      y = !0;
    }
  }), s.$$set = (v) => {
    "instancedMesh" in v && t(3, a = v.instancedMesh), "id" in v && t(4, o = v.id), "limit" in v && t(5, c = v.limit), "range" in v && t(6, l = v.range), "update" in v && t(7, u = v.update), "$$scope" in v && t(8, r = v.$$scope);
  }, [
    h,
    d,
    A,
    a,
    o,
    c,
    l,
    u,
    r,
    i
  ];
}
class $_ extends St {
  constructor(e) {
    super(), Et(this, e, o2, a2, pt, {
      instancedMesh: 3,
      id: 4,
      limit: 5,
      range: 6,
      update: 7
    });
  }
  get instancedMesh() {
    return this.$$.ctx[3];
  }
  set instancedMesh(e) {
    this.$$set({ instancedMesh: e }), Y();
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get limit() {
    return this.$$.ctx[5];
  }
  set limit(e) {
    this.$$set({ limit: e }), Y();
  }
  get range() {
    return this.$$.ctx[6];
  }
  set range(e) {
    this.$$set({ range: e }), Y();
  }
  get update() {
    return this.$$.ctx[7];
  }
  set update(e) {
    this.$$set({ update: e }), Y();
  }
}
xt($_, { instancedMesh: {}, id: {}, limit: {}, range: {}, update: {} }, ["default"], [], !0);
const c2 = (s) => ({}), yg = (s) => ({ ref: (
  /*ref*/
  s[4]
) });
function l2(s) {
  let e;
  const t = (
    /*#slots*/
    s[9].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[11],
    yg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      2048) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[11],
        e ? gt(
          t,
          /*$$scope*/
          i[11],
          r,
          c2
        ) : _t(
          /*$$scope*/
          i[11]
        ),
        yg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function u2(s) {
  let e, t;
  return e = new $_({
    props: {
      instancedMesh: (
        /*ref*/
        s[4]
      ),
      id: (
        /*id*/
        s[0]
      ),
      limit: (
        /*limit*/
        s[1]
      ),
      range: (
        /*range*/
        s[2]
      ),
      update: (
        /*update*/
        s[3]
      ),
      $$slots: { default: [l2] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*id*/
      1 && (r.id = /*id*/
      n[0]), i & /*limit*/
      2 && (r.limit = /*limit*/
      n[1]), i & /*range*/
      4 && (r.range = /*range*/
      n[2]), i & /*update*/
      8 && (r.update = /*update*/
      n[3]), i & /*$$scope*/
      2048 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function h2(s) {
  let e, t, n;
  const i = [
    { is: (
      /*ref*/
      s[4]
    ) },
    { raycast: f2 },
    { matrixAutoUpdate: !1 },
    { args: (
      /*args*/
      s[7]
    ) },
    /*$$restProps*/
    s[8]
  ];
  function r(o) {
    s[10](o);
  }
  let a = {
    $$slots: { default: [u2] },
    $$scope: { ctx: s }
  };
  for (let o = 0; o < i.length; o += 1)
    a = Ve(a, i[o]);
  return (
    /*$dispatchingComponent*/
    s[5] !== void 0 && (a.bind = /*$dispatchingComponent*/
    s[5]), e = new qe({ props: a }), Mt.push(() => Gi(e, "bind", r)), {
      c() {
        ze(e.$$.fragment);
      },
      m(o, c) {
        Oe(e, o, c), n = !0;
      },
      p(o, [c]) {
        const l = c & /*ref, args, $$restProps*/
        400 ? Qt(i, [
          c & /*ref*/
          16 && { is: (
            /*ref*/
            o[4]
          ) },
          i[1],
          i[2],
          c & /*args*/
          128 && { args: (
            /*args*/
            o[7]
          ) },
          c & /*$$restProps*/
          256 && qt(
            /*$$restProps*/
            o[8]
          )
        ]) : {};
        c & /*$$scope, id, limit, range, update*/
        2063 && (l.$$scope = { dirty: c, ctx: o }), !t && c & /*$dispatchingComponent*/
        32 && (t = !0, l.bind = /*$dispatchingComponent*/
        o[5], Qi(() => t = !1)), e.$set(l);
      },
      i(o) {
        n || (ae(e.$$.fragment, o), n = !0);
      },
      o(o) {
        ue(e.$$.fragment, o), n = !1;
      },
      d(o) {
        Qe(e, o);
      }
    }
  );
}
const f2 = () => null;
function d2(s, e, t) {
  const n = ["id", "limit", "range", "update", "ref"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: c = "default" } = e, { limit: l = 1e3 } = e, { range: u = 1e3 } = e, { update: h = !0 } = e;
  const f = new $l(null, null, 0), d = An();
  $e(s, d, (p) => t(5, r = p));
  const A = [null, null, 0];
  function m(p) {
    r = p, d.set(r);
  }
  return s.$$set = (p) => {
    e = Ve(Ve({}, e), Kt(p)), t(8, i = at(e, n)), "id" in p && t(0, c = p.id), "limit" in p && t(1, l = p.limit), "range" in p && t(2, u = p.range), "update" in p && t(3, h = p.update), "$$scope" in p && t(11, o = p.$$scope);
  }, [
    c,
    l,
    u,
    h,
    f,
    r,
    d,
    A,
    i,
    a,
    m,
    o
  ];
}
class eb extends St {
  constructor(e) {
    super(), Et(this, e, d2, h2, pt, {
      id: 0,
      limit: 1,
      range: 2,
      update: 3,
      ref: 4
    });
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get limit() {
    return this.$$.ctx[1];
  }
  set limit(e) {
    this.$$set({ limit: e }), Y();
  }
  get range() {
    return this.$$.ctx[2];
  }
  set range(e) {
    this.$$set({ range: e }), Y();
  }
  get update() {
    return this.$$.ctx[3];
  }
  set update(e) {
    this.$$set({ update: e }), Y();
  }
  get ref() {
    return this.$$.ctx[4];
  }
}
xt(eb, { id: {}, limit: {}, range: {}, update: { type: "Boolean" } }, ["default"], ["ref"], !0);
const vg = new Je(), Eg = new Je(), il = [], so = new Ne(), p2 = (s) => s.isMaterial;
class A2 extends Un {
  constructor(t, n) {
    super();
    Bt(this, "color");
    Bt(this, "instancedMesh");
    Bt(this, "instances");
    this.color = new Pe("white"), this.instancedMesh = t, this.instances = n;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var t;
    return (t = this.instancedMesh.current) == null ? void 0 : t.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(t, n) {
    var o;
    const i = this.instancedMesh.current;
    if (!i || !i.geometry || !i.material)
      return;
    so.geometry = i.geometry;
    const r = i.matrixWorld, a = this.instances.current.indexOf(this);
    if (!(a === -1 || a > i.count)) {
      i.getMatrixAt(a, vg), Eg.multiplyMatrices(r, vg), so.matrixWorld = Eg, p2(i.material) ? so.material.side = i.material.side : so.material.side = ((o = i.material[0]) == null ? void 0 : o.side) ?? mi, so.raycast(t, il);
      for (let c = 0, l = il.length; c < l; c++) {
        const u = il[c];
        u.instanceId = a, u.object = this, n.push(u);
      }
      il.length = 0;
    }
  }
}
const g2 = (s) => ({}), xg = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function m2(s) {
  let e;
  const t = (
    /*#slots*/
    s[5].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[7],
    xg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? gt(
          t,
          /*$$scope*/
          i[7],
          r,
          g2
        ) : _t(
          /*$$scope*/
          i[7]
        ),
        xg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function _2(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [m2] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[6](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      128 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[6](null), Qe(e, r);
    }
  };
}
function b2(s, e, t) {
  const n = ["id", "ref"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: c = "default" } = e;
  const { addInstance: l, removeInstance: u, instancedMesh: h, instances: f } = s2(c), d = new A2(h, f);
  l(d), Wt(() => {
    u(d);
  });
  const A = An();
  $e(s, A, (p) => t(1, r = p));
  function m(p) {
    Mt[p ? "unshift" : "push"](() => {
      r = p, A.set(r);
    });
  }
  return s.$$set = (p) => {
    e = Ve(Ve({}, e), Kt(p)), t(3, i = at(e, n)), "id" in p && t(4, c = p.id), "$$scope" in p && t(7, o = p.$$scope);
  }, [
    d,
    r,
    A,
    i,
    c,
    a,
    m,
    o
  ];
}
class tb extends St {
  constructor(e) {
    super(), Et(this, e, b2, _2, pt, { id: 4, ref: 0 });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
}
xt(tb, { id: {} }, ["default"], ["ref"], !0);
function y2(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      256) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? gt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function v2(s) {
  let e, t;
  const n = [
    { geometry: (
      /*mesh*/
      s[2].geometry
    ) },
    { material: (
      /*mesh*/
      s[2].material
    ) },
    { id: (
      /*mesh*/
      s[2].uuid
    ) },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [x2] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new eb({ props: i }), s[7](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, a) {
      const o = a & /*mesh, $$restProps*/
      20 ? Qt(n, [
        a & /*mesh*/
        4 && { geometry: (
          /*mesh*/
          r[2].geometry
        ) },
        a & /*mesh*/
        4 && { material: (
          /*mesh*/
          r[2].material
        ) },
        a & /*mesh*/
        4 && { id: (
          /*mesh*/
          r[2].uuid
        ) },
        a & /*$$restProps*/
        16 && qt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope*/
      256 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[7](null), Qe(e, r);
    }
  };
}
function E2(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[8],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      256) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[8],
        e ? gt(
          t,
          /*$$scope*/
          i[8],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[8]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function x2(s) {
  let e, t;
  return e = new Ud({
    props: {
      meshes: (
        /*copiedArray*/
        s[1]
      ),
      $$slots: { default: [E2] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      256 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function S2(s) {
  let e, t, n, i;
  const r = [v2, y2], a = [];
  function o(c, l) {
    return (
      /*mesh*/
      c[2] ? 0 : 1
    );
  }
  return e = o(s), t = a[e] = r[e](s), {
    c() {
      t.c(), n = yi();
    },
    m(c, l) {
      a[e].m(c, l), st(c, n, l), i = !0;
    },
    p(c, [l]) {
      t.p(c, l);
    },
    i(c) {
      i || (ae(t), i = !0);
    },
    o(c) {
      ue(t), i = !1;
    },
    d(c) {
      c && rt(n), a[e].d(c);
    }
  };
}
function C2(s, e, t) {
  const n = ["meshes"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { meshes: c } = e;
  const l = [...c], u = l.pop(), h = An();
  $e(s, h, (d) => t(0, r = d));
  function f(d) {
    Mt[d ? "unshift" : "push"](() => {
      r = d, h.set(r);
    });
  }
  return s.$$set = (d) => {
    e = Ve(Ve({}, e), Kt(d)), t(4, i = at(e, n)), "meshes" in d && t(5, c = d.meshes), "$$scope" in d && t(8, o = d.$$scope);
  }, [
    r,
    l,
    u,
    h,
    i,
    c,
    a,
    f,
    o
  ];
}
class Ud extends St {
  constructor(e) {
    super(), Et(this, e, C2, S2, pt, { meshes: 5 });
  }
  get meshes() {
    return this.$$.ctx[5];
  }
  set meshes(e) {
    this.$$set({ meshes: e }), Y();
  }
}
xt(Ud, { meshes: {} }, ["default"], [], !0);
const M2 = (s) => ({ components: s & /*components*/
2 }), Sg = (s) => ({ components: (
  /*components*/
  s[1]
) });
function I2(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    Sg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, components*/
      514) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          M2
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        Sg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function w2(s) {
  let e, t;
  const n = [
    { meshes: (
      /*filteredMeshesArray*/
      s[0]
    ) },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [I2] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new Ud({ props: i }), s[8](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*filteredMeshesArray, $$restProps*/
      17 ? Qt(n, [
        a & /*filteredMeshesArray*/
        1 && { meshes: (
          /*filteredMeshesArray*/
          r[0]
        ) },
        a & /*$$restProps*/
        16 && qt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope, components*/
      514 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
function T2(s, e, t) {
  let n, i, r;
  const a = ["meshes"];
  let o = at(e, a), c, { $$slots: l = {}, $$scope: u } = e, { meshes: h } = e;
  const f = (g) => new Proxy(
    tb,
    {
      construct(_, b) {
        const y = {
          ...b[0],
          props: { ...b[0].props, id: g }
        };
        return new _(y);
      }
    }
  ), d = (g) => g.filter((_) => _.isMesh).map((_) => f(_.uuid)), A = (g) => Object.entries(g).reduce(
    (_, [b, y]) => (y.isMesh && (_[b] = f(y.uuid)), _),
    {}
  ), m = An();
  $e(s, m, (g) => t(2, c = g));
  function p(g) {
    Mt[g ? "unshift" : "push"](() => {
      c = g, m.set(c);
    });
  }
  return s.$$set = (g) => {
    e = Ve(Ve({}, e), Kt(g)), t(4, o = at(e, a)), "meshes" in g && t(5, h = g.meshes), "$$scope" in g && t(9, u = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*meshes*/
    32 && t(1, n = Array.isArray(h) ? d(h) : A(h)), s.$$.dirty & /*meshes*/
    32 && t(6, i = Array.isArray(h) ? h : Object.values(h)), s.$$.dirty & /*meshesArray*/
    64 && t(0, r = i.filter((g) => g.isMesh));
  }, [
    r,
    n,
    c,
    m,
    o,
    h,
    i,
    l,
    p,
    u
  ];
}
class B2 extends St {
  constructor(e) {
    super(), Et(this, e, T2, w2, pt, { meshes: 5 });
  }
  get meshes() {
    return this.$$.ctx[5];
  }
  set meshes(e) {
    this.$$set({ meshes: e }), Y();
  }
}
xt(B2, { meshes: {} }, ["default"], [], !0);
function R2(s, e, t) {
  let n;
  const { renderer: i, camera: r, scene: a } = sn();
  let { size: o = 25 } = e, { focus: c = 0 } = e, { samples: l = 10 } = e;
  const u = tt.shadowmap_pars_fragment, h = () => {
    tt.shadowmap_pars_fragment = u.replace("#ifdef USE_SHADOWMAP", `#ifdef USE_SHADOWMAP
` + n).replace("#if defined( SHADOWMAP_TYPE_PCF )", `
return PCSS(shadowMap, shadowCoord);
#if defined( SHADOWMAP_TYPE_PCF )`), f();
  }, f = () => {
    a.traverse((d) => {
      var m, p;
      const A = d;
      A.material && (i == null || i.properties.remove(A.material), (p = (m = A.material).dispose) == null || p.call(m));
    }), i != null && i.info.programs && (i.info.programs.length = 0), i == null || i.compile(a, r.current);
  };
  return Wt(() => {
    tt.shadowmap_pars_fragment = u, f();
  }), s.$$set = (d) => {
    "size" in d && t(0, o = d.size), "focus" in d && t(1, c = d.focus), "samples" in d && t(2, l = d.samples);
  }, s.$$.update = () => {
    s.$$.dirty & /*size, focus, samples*/
    7 && t(3, n = `
		#define PENUMBRA_FILTER_SIZE float(${o})
		#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
		vec3 randRGB(vec2 uv) {
			return vec3(
				fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
				fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
				fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
			);
		}

		vec3 lowPassRandRGB(vec2 uv) {
			// 3x3 convolution (average)
			// can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
			vec3 result = vec3(0);
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
			result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
			result *= 0.111111111; // 1.0 / 9.0
			return result;
		}
		vec3 highPassRandRGB(vec2 uv) {
			// by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
			// hp(x) = x - lp(x)
			return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
		}


		vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
			const float goldenAngle = 2.399963f; // radians
			float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
			float theta = float(sampleIndex) * goldenAngle + angle;
			float sine = sin(theta);
			float cosine = cos(theta);
			return vec2(cosine, sine) * r;
		}
		float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
			return (zReceiver - zBlocker) / zBlocker;
		}
		float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float blockerDepthSum = float(${c});
			float blockers = 0.0;

			int j = 0;
			vec2 offset = vec2(0.);
			float depth = 0.;

			#pragma unroll_loop_start
			for(int i = 0; i < ${l}; i ++) {
				offset = (vogelDiskSample(j, ${l}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
				depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
				if (depth < compare) {
					blockerDepthSum += depth;
					blockers++;
				}
				j++;
			}
			#pragma unroll_loop_end

			if (blockers > 0.0) {
				return blockerDepthSum / blockers;
			}
			return -1.0;
		}


		float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
			float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
			float shadow = 0.0f;
			int j = 0;
			vec2 vogelSample = vec2(0.0);
			vec2 offset = vec2(0.0);
			#pragma unroll_loop_start
			for (int i = 0; i < ${l}; i++) {
				vogelSample = vogelDiskSample(j, ${l}, angle) * texelSize;
				offset = vogelSample * (1.0 + filterRadius * float(${o}));
				shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
				j++;
			}
			#pragma unroll_loop_end
			return shadow * 1.0 / ${l}.0;
		}

		float PCSS (sampler2D shadowMap, vec4 coords) {
			vec2 uv = coords.xy;
			float zReceiver = coords.z; // Assumed to be eye-space z in this code
			float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
			float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
			if (avgBlockerDepth == -1.0) {
				return 1.0;
			}
			float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
			return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
	}`), s.$$.dirty & /*pcss*/
    8 && h();
  }, [o, c, l, n];
}
class D2 extends St {
  constructor(e) {
    super(), Et(this, e, R2, null, pt, { size: 0, focus: 1, samples: 2 });
  }
  get size() {
    return this.$$.ctx[0];
  }
  set size(e) {
    this.$$set({ size: e }), Y();
  }
  get focus() {
    return this.$$.ctx[1];
  }
  set focus(e) {
    this.$$set({ focus: e }), Y();
  }
  get samples() {
    return this.$$.ctx[2];
  }
  set samples(e) {
    this.$$set({ samples: e }), Y();
  }
}
xt(D2, { size: {}, focus: {}, samples: {} }, [], [], !0);
const ao = (s, e, t, n, i) => {
  s[e + 0] = t, s[e + 1] = n, s[e + 2] = i, s[e + 3] = t, s[e + 4] = n, s[e + 5] = i;
}, Cg = (s, e, t, n) => {
  s[e + 0] = t, s[e + 1] = n;
}, Mg = (s, e, t, n, i) => {
  s[e + 0] = t, s[e + 1] = n, s[e + 2] = i;
}, L2 = (s, e, t, n, i, r) => {
  s[e + 0] = t, s[e + 1] = n, s[e + 2] = i, s[e + 3] = r;
}, P2 = (s) => ({}), Ig = (s) => ({ ref: (
  /*geometry*/
  s[1]
) });
function U2(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    Ig
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          P2
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        Ig
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function F2(s) {
  let e, t;
  const n = [
    { is: (
      /*geometry*/
      s[1]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: { default: [U2] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[8](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*geometry, $$restProps*/
      10 ? Qt(n, [
        a & /*geometry*/
        2 && { is: (
          /*geometry*/
          r[1]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope*/
      512 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
function k2(s, e, t) {
  const n = ["points", "shape", "shapeFunction"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { points: c = [] } = e, { shape: l = "none" } = e, { shapeFunction: u = (_) => 1 } = e, h;
  const { invalidate: f } = sn(), A = (() => {
    h = c.length;
    let _ = [], b = 0, y = [], v = [], x = 0, S = [], I = 0, E = [], M = 0;
    l === "taper" && t(4, u = (D) => 1 * Math.pow(4 * D * (1 - D), 1));
    for (let D = 0; D < h; D++) {
      const F = D / c.length;
      _[b + 0] = F, _[b + 1] = F, b += 2, Cg(y, x, 1, -1);
      let C = l === "none" ? 1 : u(D / (h - 1));
      if (Cg(v, x, C, C), x += 2, L2(S, I, D / (h - 1), 0, D / (h - 1), 1), I += 4, D < h - 1) {
        const R = D * 2;
        Mg(E, M, R + 0, R + 1, R + 2), Mg(E, M + 3, R + 2, R + 1, R + 3), M += 6;
      }
    }
    const T = new ot();
    return T.setAttribute("position", new ut(new Float32Array(h * 6), 3)), T.setAttribute("previous", new ut(new Float32Array(h * 6), 3)), T.setAttribute("next", new ut(new Float32Array(h * 6), 3)), T.setAttribute("counters", new ut(new Float32Array(_), 1)), T.setAttribute("side", new ut(new Float32Array(y), 1)), T.setAttribute("width", new ut(new Float32Array(v), 1)), T.setAttribute("uv", new ut(new Float32Array(S), 2)), T.setIndex(new ut(new Uint16Array(E), 1)), T;
  })(), m = (_) => {
    if (!_[0] || _.length != h)
      return;
    let b = [], y = [], v = [], x = 0, S = 0, I = 0;
    ao(y, S, _[0].x, _[0].y, _[0].z), S += 6;
    for (let D = 0; D < h; D++) {
      const F = _[D];
      ao(b, x, F.x, F.y, F.z), x += 6, D < h - 1 && (ao(y, S, F.x, F.y, F.z), S += 6), D > 0 && D + 1 <= h && (ao(v, I, F.x, F.y, F.z), I += 6);
    }
    ao(v, I, _[h - 1].x, _[h - 1].y, _[h - 1].z);
    const E = A.getAttribute("position").set(b), M = A.getAttribute("previous").set(y), T = A.getAttribute("next").set(v);
    E.needsUpdate = !0, M.needsUpdate = !0, T.needsUpdate = !0, A.computeBoundingSphere(), f();
  }, p = An();
  $e(s, p, (_) => t(0, r = _));
  function g(_) {
    Mt[_ ? "unshift" : "push"](() => {
      r = _, p.set(r);
    });
  }
  return s.$$set = (_) => {
    e = Ve(Ve({}, e), Kt(_)), t(3, i = at(e, n)), "points" in _ && t(5, c = _.points), "shape" in _ && t(6, l = _.shape), "shapeFunction" in _ && t(4, u = _.shapeFunction), "$$scope" in _ && t(9, o = _.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*points*/
    32 && m(c);
  }, [
    r,
    A,
    p,
    i,
    u,
    c,
    l,
    a,
    g,
    o
  ];
}
class N2 extends St {
  constructor(e) {
    super(), Et(this, e, k2, F2, pt, { points: 5, shape: 6, shapeFunction: 4 });
  }
  get points() {
    return this.$$.ctx[5];
  }
  set points(e) {
    this.$$set({ points: e }), Y();
  }
  get shape() {
    return this.$$.ctx[6];
  }
  set shape(e) {
    this.$$set({ shape: e }), Y();
  }
  get shapeFunction() {
    return this.$$.ctx[4];
  }
  set shapeFunction(e) {
    this.$$set({ shapeFunction: e }), Y();
  }
}
xt(N2, { points: {}, shape: {}, shapeFunction: {} }, ["default"], [], !0);
const O2 = `
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform float useDash;
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
uniform sampler2D alphaMap;
uniform float useAlphaMap;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounters;

void main()	{
	#include <logdepthbuf_fragment>
	#include <${J_ < 154 ? "encodings_fragment" : "colorspace_fragment"}>

	vec4 c = vColor;

	if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV ).r;

	if( useDash == 1. ){
			c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
	}

	gl_FragColor = LinearTosRGB(c);
}
`, Q2 = `
    ${tt.logdepthbuf_pars_vertex}
    ${tt.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${tt.logdepthbuf_vertex}
        ${tt.fog_vertex}
    }
`, G2 = (s) => ({ ref: s & /*material*/
1 }), wg = (s) => ({ ref: (
  /*material*/
  s[0]
) });
function z2(s) {
  let e;
  const t = (
    /*#slots*/
    s[15].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[17],
    wg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, material*/
      131073) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? gt(
          t,
          /*$$scope*/
          i[17],
          r,
          G2
        ) : _t(
          /*$$scope*/
          i[17]
        ),
        wg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function H2(s) {
  let e, t;
  const n = [
    { is: (
      /*material*/
      s[0]
    ) },
    /*$$restProps*/
    s[4],
    { fragmentShader: O2 },
    { vertexShader: Q2 }
  ];
  let i = {
    $$slots: { default: [z2] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[16](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*material, $$restProps*/
      17 ? Qt(n, [
        a & /*material*/
        1 && { is: (
          /*material*/
          r[0]
        ) },
        a & /*$$restProps*/
        16 && qt(
          /*$$restProps*/
          r[4]
        ),
        n[2],
        n[3]
      ]) : {};
      a & /*$$scope, material*/
      131073 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[16](null), Qe(e, r);
    }
  };
}
function V2(s, e, t) {
  const n = [
    "opacity",
    "color",
    "dashOffset",
    "dashArray",
    "dashRatio",
    "attenuate",
    "width",
    "scaleDown",
    "alphaMap"
  ];
  let i = at(e, n), r, a, { $$slots: o = {}, $$scope: c } = e, { opacity: l = 1 } = e, { color: u = "#ffffff" } = e, { dashOffset: h = 0 } = e, { dashArray: f = 0 } = e, { dashRatio: d = 0 } = e, { attenuate: A = !0 } = e, { width: m = 1 } = e, { scaleDown: p = 0 } = e, { alphaMap: g = void 0 } = e, { invalidate: _, size: b } = sn();
  $e(s, b, (S) => t(14, r = S));
  const y = new Kn({
    uniforms: {
      lineWidth: { value: m },
      color: { value: new Pe(u) },
      opacity: { value: l },
      resolution: { value: new xe(1, 1) },
      sizeAttenuation: { value: A ? 1 : 0 },
      dashArray: { value: f },
      dashOffset: { value: h },
      dashRatio: { value: d },
      useDash: { value: f > 0 ? 1 : 0 },
      scaleDown: { value: p / 10 },
      alphaTest: { value: 0 },
      alphaMap: { value: g },
      useAlphaMap: { value: g ? 1 : 0 }
    }
  }), v = An();
  $e(s, v, (S) => t(1, a = S));
  function x(S) {
    Mt[S ? "unshift" : "push"](() => {
      a = S, v.set(a);
    });
  }
  return s.$$set = (S) => {
    e = Ve(Ve({}, e), Kt(S)), t(4, i = at(e, n)), "opacity" in S && t(5, l = S.opacity), "color" in S && t(6, u = S.color), "dashOffset" in S && t(7, h = S.dashOffset), "dashArray" in S && t(8, f = S.dashArray), "dashRatio" in S && t(9, d = S.dashRatio), "attenuate" in S && t(10, A = S.attenuate), "width" in S && t(11, m = S.width), "scaleDown" in S && t(12, p = S.scaleDown), "alphaMap" in S && t(13, g = S.alphaMap), "$$scope" in S && t(17, c = S.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*$size*/
    16384 && (t(0, y.uniforms.resolution.value = new xe(r.width, r.height), y), _()), s.$$.dirty & /*dashRatio, dashArray, dashOffset, width, opacity, color*/
    3040 && (t(0, y.uniforms.dashRatio.value = d, y), t(0, y.uniforms.dashArray.value = f, y), t(0, y.uniforms.dashOffset.value = h, y), t(0, y.uniforms.lineWidth.value = m, y), t(0, y.uniforms.opacity.value = l, y), t(0, y.uniforms.color.value = new Pe(u), y), _());
  }, [
    y,
    a,
    b,
    v,
    i,
    l,
    u,
    h,
    f,
    d,
    A,
    m,
    p,
    g,
    r,
    o,
    x,
    c
  ];
}
class W2 extends St {
  constructor(e) {
    super(), Et(this, e, V2, H2, pt, {
      opacity: 5,
      color: 6,
      dashOffset: 7,
      dashArray: 8,
      dashRatio: 9,
      attenuate: 10,
      width: 11,
      scaleDown: 12,
      alphaMap: 13
    });
  }
  get opacity() {
    return this.$$.ctx[5];
  }
  set opacity(e) {
    this.$$set({ opacity: e }), Y();
  }
  get color() {
    return this.$$.ctx[6];
  }
  set color(e) {
    this.$$set({ color: e }), Y();
  }
  get dashOffset() {
    return this.$$.ctx[7];
  }
  set dashOffset(e) {
    this.$$set({ dashOffset: e }), Y();
  }
  get dashArray() {
    return this.$$.ctx[8];
  }
  set dashArray(e) {
    this.$$set({ dashArray: e }), Y();
  }
  get dashRatio() {
    return this.$$.ctx[9];
  }
  set dashRatio(e) {
    this.$$set({ dashRatio: e }), Y();
  }
  get attenuate() {
    return this.$$.ctx[10];
  }
  set attenuate(e) {
    this.$$set({ attenuate: e }), Y();
  }
  get width() {
    return this.$$.ctx[11];
  }
  set width(e) {
    this.$$set({ width: e }), Y();
  }
  get scaleDown() {
    return this.$$.ctx[12];
  }
  set scaleDown(e) {
    this.$$set({ scaleDown: e }), Y();
  }
  get alphaMap() {
    return this.$$.ctx[13];
  }
  set alphaMap(e) {
    this.$$set({ alphaMap: e }), Y();
  }
}
xt(W2, { opacity: {}, color: {}, dashOffset: {}, dashArray: {}, dashRatio: {}, attenuate: { type: "Boolean" }, width: {}, scaleDown: {}, alphaMap: {} }, ["default"], [], !0);
class gu extends Ne {
  constructor() {
    const e = gu.SkyShader, t = new Kn({
      name: e.name,
      uniforms: Vl.clone(e.uniforms),
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      side: Fn,
      depthWrite: !1
    });
    super(new en(1, 1, 1), t), this.isSky = !0;
  }
}
gu.SkyShader = {
  name: "SkyShader",
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new P() },
    up: { value: new P(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const q2 = (s) => ({ renderTarget: s & /*renderTarget*/
1 }), Tg = (s) => ({
  sunPosition: (
    /*sunPosition*/
    s[2]
  ),
  renderTarget: (
    /*renderTarget*/
    s[0]
  )
});
function X2(s) {
  let e;
  const t = (
    /*#slots*/
    s[13].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[14],
    Tg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, renderTarget*/
      16385) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[14],
        e ? gt(
          t,
          /*$$scope*/
          i[14],
          r,
          q2
        ) : _t(
          /*$$scope*/
          i[14]
        ),
        Tg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function Y2(s) {
  let e, t;
  return e = new qe({
    props: {
      is: (
        /*sky*/
        s[1]
      ),
      $$slots: { default: [X2] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, [i]) {
      const r = {};
      i & /*$$scope, renderTarget*/
      16385 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function j2(s, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { scale: r = 1e3 } = e, { turbidity: a = 10 } = e, { rayleigh: o = 3 } = e, { mieCoefficient: c = 5e-3 } = e, { mieDirectionalG: l = 0.7 } = e, { elevation: u = 2 } = e, { azimuth: h = 180 } = e, { setEnvironment: f = !0 } = e, { cubeMapSize: d = 128 } = e, { webGLRenderTargetOptions: A = {} } = e;
  const m = new gu(), p = new P(), g = m.material.uniforms, { renderer: _, scene: b, invalidate: y } = sn();
  let v, x;
  const S = () => {
    t(0, v = new nd(
      d,
      {
        type: Pn,
        generateMipmaps: !0,
        minFilter: _i,
        ...A
      }
    )), x = new td(1, 1.1, v);
  }, I = b.environment, { start: E, stop: M } = bi(
    () => {
      m.scale.setScalar(r), g.turbidity.value = a, g.rayleigh.value = o, g.mieCoefficient.value = c, g.mieDirectionalG.value = l;
      const T = Cs.degToRad(90 - u), D = Cs.degToRad(h);
      p.setFromSphericalCoords(1, T, D), g.sunPosition.value.copy(p), f && ((!v || !x) && S(), x == null || x.update(_, m)), y(), M();
    },
    { autoStart: !1, autoInvalidate: !1 }
  );
  return Wt(() => {
    m.material.dispose(), v == null || v.dispose(), b.environment = I;
  }), s.$$set = (T) => {
    "scale" in T && t(3, r = T.scale), "turbidity" in T && t(4, a = T.turbidity), "rayleigh" in T && t(5, o = T.rayleigh), "mieCoefficient" in T && t(6, c = T.mieCoefficient), "mieDirectionalG" in T && t(7, l = T.mieDirectionalG), "elevation" in T && t(8, u = T.elevation), "azimuth" in T && t(9, h = T.azimuth), "setEnvironment" in T && t(10, f = T.setEnvironment), "cubeMapSize" in T && t(11, d = T.cubeMapSize), "webGLRenderTargetOptions" in T && t(12, A = T.webGLRenderTargetOptions), "$$scope" in T && t(14, i = T.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*setEnvironment, renderTarget*/
    1025 && (f && v ? (b.environment = v.texture, y()) : f || (b.environment = I, y())), s.$$.dirty & /*scale, turbidity, rayleigh, mieCoefficient, mieDirectionalG, elevation, azimuth*/
    1016 && E();
  }, [
    v,
    m,
    p,
    r,
    a,
    o,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    n,
    i
  ];
}
class J2 extends St {
  constructor(e) {
    super(), Et(this, e, j2, Y2, pt, {
      scale: 3,
      turbidity: 4,
      rayleigh: 5,
      mieCoefficient: 6,
      mieDirectionalG: 7,
      elevation: 8,
      azimuth: 9,
      setEnvironment: 10,
      cubeMapSize: 11,
      webGLRenderTargetOptions: 12
    });
  }
  get scale() {
    return this.$$.ctx[3];
  }
  set scale(e) {
    this.$$set({ scale: e }), Y();
  }
  get turbidity() {
    return this.$$.ctx[4];
  }
  set turbidity(e) {
    this.$$set({ turbidity: e }), Y();
  }
  get rayleigh() {
    return this.$$.ctx[5];
  }
  set rayleigh(e) {
    this.$$set({ rayleigh: e }), Y();
  }
  get mieCoefficient() {
    return this.$$.ctx[6];
  }
  set mieCoefficient(e) {
    this.$$set({ mieCoefficient: e }), Y();
  }
  get mieDirectionalG() {
    return this.$$.ctx[7];
  }
  set mieDirectionalG(e) {
    this.$$set({ mieDirectionalG: e }), Y();
  }
  get elevation() {
    return this.$$.ctx[8];
  }
  set elevation(e) {
    this.$$set({ elevation: e }), Y();
  }
  get azimuth() {
    return this.$$.ctx[9];
  }
  set azimuth(e) {
    this.$$set({ azimuth: e }), Y();
  }
  get setEnvironment() {
    return this.$$.ctx[10];
  }
  set setEnvironment(e) {
    this.$$set({ setEnvironment: e }), Y();
  }
  get cubeMapSize() {
    return this.$$.ctx[11];
  }
  set cubeMapSize(e) {
    this.$$set({ cubeMapSize: e }), Y();
  }
  get webGLRenderTargetOptions() {
    return this.$$.ctx[12];
  }
  set webGLRenderTargetOptions(e) {
    this.$$set({ webGLRenderTargetOptions: e }), Y();
  }
}
xt(J2, { scale: {}, turbidity: {}, rayleigh: {}, mieCoefficient: {}, mieDirectionalG: {}, elevation: {}, azimuth: {}, setEnvironment: { type: "Boolean" }, cubeMapSize: {}, webGLRenderTargetOptions: {} }, ["default"], [], !0);
const K2 = (s) => s.isObject3D, Z2 = (s) => {
  Dd("align-plugin", ({ ref: e }) => {
    if (!K2(e))
      return;
    Qr(() => (s(), s));
    const t = async () => {
      await Ll(), s();
    };
    return {
      onRefChange() {
        t();
      }
    };
  });
}, $2 = (s) => ({ ref: s & /*ref*/
2097152 }), Bg = (s) => ({
  align: (
    /*scheduleAligning*/
    s[4]
  ),
  ref: (
    /*ref*/
    s[21]
  )
});
function eB(s) {
  let e;
  const t = (
    /*#slots*/
    s[15].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[17],
    Bg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2228224) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[17],
        e ? gt(
          t,
          /*$$scope*/
          i[17],
          r,
          $2
        ) : _t(
          /*$$scope*/
          i[17]
        ),
        Bg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function tB(s) {
  let e, t;
  return e = new qe({
    props: {
      is: (
        /*innerGroup*/
        s[2]
      ),
      $$slots: { default: [eB] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, ref*/
      2228224 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function nB(s) {
  let e, t;
  return e = new qe({
    props: {
      is: (
        /*outerGroup*/
        s[3]
      ),
      $$slots: { default: [tB] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, ref*/
      2228224 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function iB(s) {
  let e, t;
  const n = [
    { is: (
      /*containerGroup*/
      s[1]
    ) },
    /*$$restProps*/
    s[6]
  ];
  let i = {
    $$slots: {
      default: [
        nB,
        ({ ref: r }) => ({ 21: r }),
        ({ ref: r }) => r ? 2097152 : 0
      ]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[16](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*containerGroup, $$restProps*/
      66 ? Qt(n, [
        a & /*containerGroup*/
        2 && { is: (
          /*containerGroup*/
          r[1]
        ) },
        a & /*$$restProps*/
        64 && qt(
          /*$$restProps*/
          r[6]
        )
      ]) : {};
      a & /*$$scope, ref*/
      2228224 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[16](null), Qe(e, r);
    }
  };
}
function rB(s, e, t) {
  const n = ["x", "y", "z", "precise", "auto", "calculate", "align"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { x: c = 0 } = e, { y: l = 0 } = e, { z: u = 0 } = e, { precise: h = !1 } = e, { auto: f = !1 } = e;
  const d = Ji(), { invalidate: A } = sn(), m = new Un(), p = new Un(), g = new Un();
  let _ = !1;
  Qr(() => {
    t(14, _ = !0);
  });
  const b = () => {
    if (!_ || c === !1 && l === !1 && u === !1)
      return;
    g.matrixWorld.identity();
    const E = new bn().setFromObject(p, h), M = new P(), T = new yn(), D = E.max.x - E.min.x, F = E.max.y - E.min.y, C = E.max.z - E.min.z;
    E.getCenter(M), E.getBoundingSphere(T);
    const R = (l || 0) * F / 2, O = (c || 0) * D / 2, V = (u || 0) * C / 2;
    g.position.set(c === !1 ? 0 : -M.x + O, l === !1 ? 0 : -M.y + R, u === !1 ? 0 : -M.z + V);
    const q = {
      boundingBox: E,
      center: g.position.clone(),
      boundingSphere: T,
      container: m,
      depth: C,
      depthAlignment: V,
      height: F,
      verticalAlignment: R,
      width: D,
      horizontalAlignment: O
    };
    d("align", q);
  }, { start: y, stop: v } = bi(
    () => {
      b(), A(), v();
    },
    { autoStart: !1, autoInvalidate: !1 }
  ), x = () => {
    y();
  };
  f && Z2(y);
  const S = An();
  $e(s, S, (E) => t(0, r = E));
  function I(E) {
    Mt[E ? "unshift" : "push"](() => {
      r = E, S.set(r);
    });
  }
  return s.$$set = (E) => {
    e = Ve(Ve({}, e), Kt(E)), t(6, i = at(e, n)), "x" in E && t(7, c = E.x), "y" in E && t(8, l = E.y), "z" in E && t(9, u = E.z), "precise" in E && t(10, h = E.precise), "auto" in E && t(11, f = E.auto), "$$scope" in E && t(17, o = E.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*mounted, x, y, z, precise*/
    18304 && y();
  }, [
    r,
    m,
    p,
    g,
    y,
    S,
    i,
    c,
    l,
    u,
    h,
    f,
    b,
    x,
    _,
    a,
    I,
    o
  ];
}
class sB extends St {
  constructor(e) {
    super(), Et(this, e, rB, iB, pt, {
      x: 7,
      y: 8,
      z: 9,
      precise: 10,
      auto: 11,
      calculate: 12,
      align: 13
    });
  }
  get x() {
    return this.$$.ctx[7];
  }
  set x(e) {
    this.$$set({ x: e }), Y();
  }
  get y() {
    return this.$$.ctx[8];
  }
  set y(e) {
    this.$$set({ y: e }), Y();
  }
  get z() {
    return this.$$.ctx[9];
  }
  set z(e) {
    this.$$set({ z: e }), Y();
  }
  get precise() {
    return this.$$.ctx[10];
  }
  set precise(e) {
    this.$$set({ precise: e }), Y();
  }
  get auto() {
    return this.$$.ctx[11];
  }
  set auto(e) {
    this.$$set({ auto: e }), Y();
  }
  get calculate() {
    return this.$$.ctx[12];
  }
  get align() {
    return this.$$.ctx[13];
  }
}
xt(sB, { x: {}, y: {}, z: {}, precise: { type: "Boolean" }, auto: { type: "Boolean" } }, ["default"], ["calculate", "align"], !0);
const Ph = new Je();
class mu {
  constructor(e) {
    e = e || {}, this.vertices = {
      near: [
        new P(),
        new P(),
        new P(),
        new P()
      ],
      far: [
        new P(),
        new P(),
        new P(),
        new P()
      ]
    }, e.projectionMatrix !== void 0 && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4);
  }
  setFromProjectionMatrix(e, t) {
    const n = e.elements[11] === 0;
    return Ph.copy(e).invert(), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(i) {
      i.applyMatrix4(Ph);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(i) {
      i.applyMatrix4(Ph);
      const r = Math.abs(i.z);
      n ? i.z *= Math.min(t / r, 1) : i.multiplyScalar(Math.min(t / r, 1));
    }), this.vertices;
  }
  split(e, t) {
    for (; e.length > t.length; )
      t.push(new mu());
    t.length = e.length;
    for (let n = 0; n < e.length; n++) {
      const i = t[n];
      if (n === 0)
        for (let r = 0; r < 4; r++)
          i.vertices.near[r].copy(this.vertices.near[r]);
      else
        for (let r = 0; r < 4; r++)
          i.vertices.near[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[n - 1]);
      if (n === e.length - 1)
        for (let r = 0; r < 4; r++)
          i.vertices.far[r].copy(this.vertices.far[r]);
      else
        for (let r = 0; r < 4; r++)
          i.vertices.far[r].lerpVectors(this.vertices.near[r], this.vertices.far[r], e[n]);
    }
  }
  toSpace(e, t) {
    for (let n = 0; n < 4; n++)
      t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e), t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e);
  }
}
const Rg = {
  lights_fragment_begin: (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
 
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + tt.lights_pars_begin
  )
}, Dg = new Je(), Uh = new mu(), rr = new P(), oo = new bn(), Fh = [], kh = [], Nh = new Je(), Lg = new Je(), aB = new P(0, 1, 0);
class oB {
  constructor(e) {
    this.camera = e.camera, this.parent = e.parent, this.cascades = e.cascades || 3, this.maxFar = e.maxFar || 1e5, this.mode = e.mode || "practical", this.shadowMapSize = e.shadowMapSize || 2048, this.shadowBias = e.shadowBias || 1e-6, this.lightDirection = e.lightDirection || new P(1, -1, 1).normalize(), this.lightIntensity = e.lightIntensity || 3, this.lightNear = e.lightNear || 1, this.lightFar = e.lightFar || 2e3, this.lightMargin = e.lightMargin || 200, this.customSplitsCallback = e.customSplitsCallback, this.fade = !1, this.mainFrustum = new mu(), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = /* @__PURE__ */ new Map(), this.createLights(), this.updateFrustums(), this.injectInclude();
  }
  createLights() {
    for (let e = 0; e < this.cascades; e++) {
      const t = new fu(16777215, this.lightIntensity);
      t.castShadow = !0, t.shadow.mapSize.width = this.shadowMapSize, t.shadow.mapSize.height = this.shadowMapSize, t.shadow.camera.near = this.lightNear, t.shadow.camera.far = this.lightFar, t.shadow.bias = this.shadowBias, this.parent.add(t), this.parent.add(t.target), this.lights.push(t);
    }
  }
  initCascades() {
    const e = this.camera;
    e.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const e = this.frustums;
    for (let t = 0; t < e.length; t++) {
      const i = this.lights[t].shadow.camera, r = this.frustums[t], a = r.vertices.near, o = r.vertices.far, c = o[0];
      let l;
      c.distanceTo(o[2]) > c.distanceTo(a[2]) ? l = o[2] : l = a[2];
      let u = c.distanceTo(l);
      if (this.fade) {
        const h = this.camera, f = Math.max(h.far, this.maxFar), d = r.vertices.far[0].z / (f - h.near), A = 0.25 * Math.pow(d, 2) * (f - h.near);
        u += A;
      }
      i.left = -u / 2, i.right = u / 2, i.top = u / 2, i.bottom = -u / 2, i.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const e = this.camera, t = Math.min(e.far, this.maxFar);
    switch (this.breaks.length = 0, this.mode) {
      case "uniform":
        n(this.cascades, e.near, t, this.breaks);
        break;
      case "logarithmic":
        i(this.cascades, e.near, t, this.breaks);
        break;
      case "practical":
        r(this.cascades, e.near, t, 0.5, this.breaks);
        break;
      case "custom":
        this.customSplitsCallback === void 0 && console.error("CSM: Custom split scheme callback not defined."), this.customSplitsCallback(this.cascades, e.near, t, this.breaks);
        break;
    }
    function n(a, o, c, l) {
      for (let u = 1; u < a; u++)
        l.push((o + (c - o) * u / a) / c);
      l.push(1);
    }
    function i(a, o, c, l) {
      for (let u = 1; u < a; u++)
        l.push(o * (c / o) ** (u / a) / c);
      l.push(1);
    }
    function r(a, o, c, l, u) {
      Fh.length = 0, kh.length = 0, i(a, o, c, kh), n(a, o, c, Fh);
      for (let h = 1; h < a; h++)
        u.push(Cs.lerp(Fh[h - 1], kh[h - 1], l));
      u.push(1);
    }
  }
  update() {
    const e = this.camera, t = this.frustums;
    Nh.lookAt(new P(), this.lightDirection, aB), Lg.copy(Nh).invert();
    for (let n = 0; n < t.length; n++) {
      const i = this.lights[n], r = i.shadow.camera, a = (r.right - r.left) / this.shadowMapSize, o = (r.top - r.bottom) / this.shadowMapSize;
      Dg.multiplyMatrices(Lg, e.matrixWorld), t[n].toSpace(Dg, Uh);
      const c = Uh.vertices.near, l = Uh.vertices.far;
      oo.makeEmpty();
      for (let u = 0; u < 4; u++)
        oo.expandByPoint(c[u]), oo.expandByPoint(l[u]);
      oo.getCenter(rr), rr.z = oo.max.z + this.lightMargin, rr.x = Math.floor(rr.x / a) * a, rr.y = Math.floor(rr.y / o) * o, rr.applyMatrix4(Nh), i.position.copy(rr), i.target.position.copy(rr), i.target.position.x += this.lightDirection.x, i.target.position.y += this.lightDirection.y, i.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    tt.lights_fragment_begin = Rg.lights_fragment_begin, tt.lights_pars_begin = Rg.lights_pars_begin;
  }
  setupMaterial(e) {
    e.defines = e.defines || {}, e.defines.USE_CSM = 1, e.defines.CSM_CASCADES = this.cascades, this.fade && (e.defines.CSM_FADE = "");
    const t = [], n = this, i = this.shaders;
    e.onBeforeCompile = function(r) {
      const a = Math.min(n.camera.far, n.maxFar);
      n.getExtendedBreaks(t), r.uniforms.CSM_cascades = { value: t }, r.uniforms.cameraNear = { value: n.camera.near }, r.uniforms.shadowFar = { value: a }, i.set(e, r);
    }, i.set(e, null);
  }
  updateUniforms() {
    const e = Math.min(this.camera.far, this.maxFar);
    this.shaders.forEach(function(n, i) {
      if (n !== null) {
        const r = n.uniforms;
        this.getExtendedBreaks(r.CSM_cascades.value), r.cameraNear.value = this.camera.near, r.shadowFar.value = e;
      }
      !this.fade && "CSM_FADE" in i.defines ? (delete i.defines.CSM_FADE, i.needsUpdate = !0) : this.fade && !("CSM_FADE" in i.defines) && (i.defines.CSM_FADE = "", i.needsUpdate = !0);
    }, this);
  }
  getExtendedBreaks(e) {
    for (; e.length < this.breaks.length; )
      e.push(new xe());
    e.length = this.breaks.length;
    for (let t = 0; t < this.cascades; t++) {
      const n = this.breaks[t], i = this.breaks[t - 1] || 0;
      e[t].x = i, e[t].y = n;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  remove() {
    for (let e = 0; e < this.lights.length; e++)
      this.parent.remove(this.lights[e].target), this.parent.remove(this.lights[e]);
  }
  dispose() {
    const e = this.shaders;
    e.forEach(function(t, n) {
      delete n.onBeforeCompile, delete n.defines.USE_CSM, delete n.defines.CSM_CASCADES, delete n.defines.CSM_FADE, t !== null && (delete t.uniforms.CSM_cascades, delete t.uniforms.cameraNear, delete t.uniforms.shadowFar), n.needsUpdate = !0;
    }), e.clear();
  }
}
const cB = () => {
  let s;
  const e = /* @__PURE__ */ new Set(), t = (o) => o.isMeshStandardMaterial || o.isMeshPhongMaterial, n = (o) => o.isMesh, i = (o) => {
    e.has(o) || (e.add(o), s == null || s(o));
  }, r = (o) => {
    t(o) ? i(o) : n(o) && (Array.isArray(o.material) ? o.material.forEach((c) => {
      t(c) && i(c);
    }) : t(o.material) && i(o.material));
  }, a = (o) => {
    s = o;
  };
  return Dd("csm", ({ ref: o }) => {
    Qr(() => {
      r(o);
    });
  }), Wt(() => s = void 0), { onNewMaterial: a, allMaterials: e };
}, lB = (s) => ({}), Pg = (s) => ({});
function Ug(s) {
  let e;
  const t = (
    /*#slots*/
    s[10].disabled
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    Pg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          lB
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        Pg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function uB(s) {
  let e, t, n;
  const i = (
    /*#slots*/
    s[10].default
  ), r = At(
    i,
    s,
    /*$$scope*/
    s[9],
    null
  );
  let a = !/*enabled*/
  s[0] && Ug(s);
  return {
    c() {
      r && r.c(), e = Pt(), a && a.c(), t = yi();
    },
    m(o, c) {
      r && r.m(o, c), st(o, e, c), a && a.m(o, c), st(o, t, c), n = !0;
    },
    p(o, [c]) {
      r && r.p && (!n || c & /*$$scope*/
      512) && mt(
        r,
        i,
        o,
        /*$$scope*/
        o[9],
        n ? gt(
          i,
          /*$$scope*/
          o[9],
          c,
          null
        ) : _t(
          /*$$scope*/
          o[9]
        ),
        null
      ), /*enabled*/
      o[0] ? a && (ai(), ue(a, 1, 1, () => {
        a = null;
      }), oi()) : a ? (a.p(o, c), c & /*enabled*/
      1 && ae(a, 1)) : (a = Ug(o), a.c(), ae(a, 1), a.m(t.parentNode, t));
    },
    i(o) {
      n || (ae(r, o), ae(a), n = !0);
    },
    o(o) {
      ue(r, o), ue(a), n = !1;
    },
    d(o) {
      o && (rt(e), rt(t)), r && r.d(o), a && a.d(o);
    }
  };
}
function hB(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e, { enabled: o = !0 } = e, { args: c = {} } = e, { camera: l = void 0 } = e, { configure: u = void 0 } = e, { lightIntensity: h = void 0 } = e, { lightColor: f = void 0 } = e, { lightDirection: d = [1, -1, 1] } = e;
  const A = vt(o), { camera: m, scene: p, size: g, useLegacyLights: _ } = sn();
  $e(s, m, (T) => t(12, i = T));
  const b = Ht(void 0);
  $e(s, b, (T) => t(11, n = T)), bi(() => n == null ? void 0 : n.update(), { autoInvalidate: !1 });
  const { onNewMaterial: y, allMaterials: v } = cB(), x = () => {
    n == null || n.remove(), n == null || n.dispose(), ep(b, n = void 0, n);
  };
  Ft([g, b], ([T, D]) => {
    D && D.updateFrustums();
  });
  const S = vt(l);
  Ft([m, S, b], ([T, D, F]) => {
    F && (F.camera = D ?? T, c.maxFar !== void 0 && (F.maxFar = c.maxFar), c.mode !== void 0 && (F.mode = c.mode), F.updateFrustums());
  }), Ft(A, (T) => {
    if (T) {
      ep(
        b,
        n = new oB({
          camera: l ?? i,
          parent: p,
          ...c
        }),
        n
      ), u == null || u(n);
      for (const D of v)
        n.setupMaterial(D);
      y((D) => n == null ? void 0 : n.setupMaterial(D));
    } else
      y(void 0), x();
  });
  const I = vt(h), E = vt(f);
  Ft([b, I, E, _], ([T, D, F, C]) => {
    T == null || T.lights.forEach((R) => {
      D !== void 0 && (R.intensity = D / (C ? 1 : Math.PI)), F !== void 0 && R.color.set(F);
    });
  });
  const M = vt(d);
  return Ft([b, M], ([T, D]) => {
    T == null || T.lightDirection.set(...D).normalize();
  }), Wt(x), s.$$set = (T) => {
    "enabled" in T && t(0, o = T.enabled), "args" in T && t(3, c = T.args), "camera" in T && t(4, l = T.camera), "configure" in T && t(5, u = T.configure), "lightIntensity" in T && t(6, h = T.lightIntensity), "lightColor" in T && t(7, f = T.lightColor), "lightDirection" in T && t(8, d = T.lightDirection), "$$scope" in T && t(9, a = T.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*enabled*/
    1 && A.set(o), s.$$.dirty & /*camera*/
    16 && S.set(l), s.$$.dirty & /*lightIntensity*/
    64 && I.set(h), s.$$.dirty & /*lightColor*/
    128 && E.set(f), s.$$.dirty & /*lightDirection*/
    256 && M.set(d);
  }, [
    o,
    m,
    b,
    c,
    l,
    u,
    h,
    f,
    d,
    a,
    r
  ];
}
class fB extends St {
  constructor(e) {
    super(), Et(this, e, hB, uB, pt, {
      enabled: 0,
      args: 3,
      camera: 4,
      configure: 5,
      lightIntensity: 6,
      lightColor: 7,
      lightDirection: 8
    });
  }
  get enabled() {
    return this.$$.ctx[0];
  }
  set enabled(e) {
    this.$$set({ enabled: e }), Y();
  }
  get args() {
    return this.$$.ctx[3];
  }
  set args(e) {
    this.$$set({ args: e }), Y();
  }
  get camera() {
    return this.$$.ctx[4];
  }
  set camera(e) {
    this.$$set({ camera: e }), Y();
  }
  get configure() {
    return this.$$.ctx[5];
  }
  set configure(e) {
    this.$$set({ configure: e }), Y();
  }
  get lightIntensity() {
    return this.$$.ctx[6];
  }
  set lightIntensity(e) {
    this.$$set({ lightIntensity: e }), Y();
  }
  get lightColor() {
    return this.$$.ctx[7];
  }
  set lightColor(e) {
    this.$$set({ lightColor: e }), Y();
  }
  get lightDirection() {
    return this.$$.ctx[8];
  }
  set lightDirection(e) {
    this.$$set({ lightDirection: e }), Y();
  }
}
xt(fB, { enabled: { type: "Boolean" }, args: {}, camera: {}, configure: {}, lightIntensity: {}, lightColor: {}, lightDirection: {} }, ["default", "disabled"], [], !0);
const dB = (s) => ({}), Fg = (s) => ({}), pB = (s) => ({ errors: s & /*$errors*/
1 }), kg = (s) => ({ errors: (
  /*$errors*/
  s[0]
) }), AB = (s) => ({
  suspended: s & /*$suspended*/
  2,
  errors: s & /*$errors*/
  1
}), Ng = (s) => ({
  suspended: (
    /*$suspended*/
    s[1]
  ),
  errors: (
    /*$errors*/
    s[0]
  )
});
function gB(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[7],
    Ng
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, $suspended, $errors*/
      131) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? gt(
          t,
          /*$$scope*/
          i[7],
          r,
          AB
        ) : _t(
          /*$$scope*/
          i[7]
        ),
        Ng
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function mB(s) {
  let e, t;
  return e = new qe({
    props: {
      is: (
        /*group*/
        s[4]
      ),
      $$slots: { default: [gB] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope, $suspended, $errors*/
      131 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function _B(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].fallback
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[7],
    Fg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      128) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? gt(
          t,
          /*$$scope*/
          i[7],
          r,
          dB
        ) : _t(
          /*$$scope*/
          i[7]
        ),
        Fg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function bB(s) {
  let e;
  const t = (
    /*#slots*/
    s[6].error
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[7],
    kg
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, $errors*/
      129) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[7],
        e ? gt(
          t,
          /*$$scope*/
          i[7],
          r,
          pB
        ) : _t(
          /*$$scope*/
          i[7]
        ),
        kg
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function yB(s) {
  let e, t, n, i, r, a;
  e = new Pa({
    props: {
      $$slots: { default: [mB] },
      $$scope: { ctx: s }
    }
  });
  const o = [bB, _B], c = [];
  function l(u, h) {
    return (
      /*$errors*/
      u[0].length ? 0 : (
        /*$suspended*/
        u[1] ? 1 : -1
      )
    );
  }
  return ~(n = l(s)) && (i = c[n] = o[n](s)), {
    c() {
      ze(e.$$.fragment), t = Pt(), i && i.c(), r = yi();
    },
    m(u, h) {
      Oe(e, u, h), st(u, t, h), ~n && c[n].m(u, h), st(u, r, h), a = !0;
    },
    p(u, [h]) {
      const f = {};
      h & /*$$scope, $suspended, $errors*/
      131 && (f.$$scope = { dirty: h, ctx: u }), e.$set(f);
      let d = n;
      n = l(u), n === d ? ~n && c[n].p(u, h) : (i && (ai(), ue(c[d], 1, 1, () => {
        c[d] = null;
      }), oi()), ~n ? (i = c[n], i ? i.p(u, h) : (i = c[n] = o[n](u), i.c()), ae(i, 1), i.m(r.parentNode, r)) : i = null);
    },
    i(u) {
      a || (ae(e.$$.fragment, u), ae(i), a = !0);
    },
    o(u) {
      ue(e.$$.fragment, u), ue(i), a = !1;
    },
    d(u) {
      u && (rt(t), rt(r)), Qe(e, u), ~n && c[n].d(u);
    }
  };
}
function vB(s, e, t) {
  let n, i, { $$slots: r = {}, $$scope: a } = e, { final: o = !1 } = e;
  const c = Ji(), { suspended: l, errors: u, setFinal: h } = cw({ final: o });
  $e(s, l, (A) => t(1, i = A)), $e(s, u, (A) => t(0, n = A));
  const f = new Un(), d = Fs();
  return Ft([d, l, u], ([A, m, p]) => {
    if (A) {
      if (m || p.length) {
        A.remove(f);
        return;
      }
      return A.add(f), () => {
        A.remove(f);
      };
    }
  }), s.$$set = (A) => {
    "final" in A && t(5, o = A.final), "$$scope" in A && t(7, a = A.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*final*/
    32 && h(o), s.$$.dirty & /*$suspended*/
    2 && (i || c("load")), s.$$.dirty & /*$suspended*/
    2 && i && c("suspend"), s.$$.dirty & /*$errors*/
    1 && n.length && c("error", n);
  }, [n, i, l, u, f, o, r, a];
}
class EB extends St {
  constructor(e) {
    super(), Et(this, e, vB, yB, pt, { final: 5 });
  }
  get final() {
    return this.$$.ctx[5];
  }
  set final(e) {
    this.$$set({ final: e }), Y();
  }
}
xt(EB, { final: { type: "Boolean" } }, ["default", "error", "fallback"], [], !0);
const xB = () => {
  const s = {
    portals: Ht(/* @__PURE__ */ new Map()),
    addPortal(e, t) {
      s.portals.update((n) => (n.has(t) ? console.warn(`Portal with id ${t} already exists. Skipping portal creation.`) : n.set(t, e), n));
    },
    removePortal(e) {
      s.portals.update((t) => (t.has(e) ? t.delete(e) : console.warn(`Portal with id ${e} does not exist. Skipping portal removal.`), t));
    },
    getPortal(e) {
      return Vn(s.portals, (t) => t.get(e));
    },
    hasPortal(e) {
      return s.portals.current.has(e);
    }
  };
  return s;
}, nb = () => Ld("threlte-portals", xB());
function Og(s) {
  let e, t;
  return e = new Pa({
    props: {
      onChildMount: (
        /*func*/
        s[8]
      ),
      onChildDestroy: (
        /*func_1*/
        s[9]
      ),
      $$slots: { default: [SB] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      1024 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function SB(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[10],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      1024) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? gt(
          t,
          /*$$scope*/
          i[10],
          r,
          null
        ) : _t(
          /*$$scope*/
          i[10]
        ),
        null
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function CB(s) {
  let e, t, n = (
    /*$target*/
    s[1] && Og(s)
  );
  return {
    c() {
      n && n.c(), e = yi();
    },
    m(i, r) {
      n && n.m(i, r), st(i, e, r), t = !0;
    },
    p(i, [r]) {
      /*$target*/
      i[1] ? n ? (n.p(i, r), r & /*$target*/
      2 && ae(n, 1)) : (n = Og(i), n.c(), ae(n, 1), n.m(e.parentNode, e)) : n && (ai(), ue(n, 1, 1, () => {
        n = null;
      }), oi());
    },
    i(i) {
      t || (ae(n), t = !0);
    },
    o(i) {
      ue(n), t = !1;
    },
    d(i) {
      i && rt(e), n && n.d(i);
    }
  };
}
function MB(s, e, t) {
  let n, i, r = si, a = () => (r(), r = Go(n, (g) => t(6, i = g)), n), o;
  s.$$.on_destroy.push(() => r());
  let { $$slots: c = {}, $$scope: l } = e, { id: u = "default" } = e, { object: h = void 0 } = e;
  const { getPortal: f } = nb(), d = vt([]), A = vt();
  $e(s, A, (g) => t(1, o = g)), Ft([d, A], ([g, _]) => {
    if (_ !== void 0) {
      for (const b of g)
        _.children.includes(b) || _.add(b);
      return () => {
        for (const b of g)
          _.children.includes(b) && _.remove(b);
      };
    }
  });
  const m = (g) => d.update((_) => (_.push(g), _)), p = (g) => d.update((_) => (_.splice(_.indexOf(g), 1), _));
  return s.$$set = (g) => {
    "id" in g && t(4, u = g.id), "object" in g && t(5, h = g.object), "$$scope" in g && t(10, l = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*id*/
    16 && a(t(0, n = f(u))), s.$$.dirty & /*object, $portal*/
    96 && A.set(h ?? i);
  }, [
    n,
    o,
    d,
    A,
    u,
    h,
    i,
    c,
    m,
    p,
    l
  ];
}
class IB extends St {
  constructor(e) {
    super(), Et(this, e, MB, CB, pt, { id: 4, object: 5 });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get object() {
    return this.$$.ctx[5];
  }
  set object(e) {
    this.$$set({ object: e }), Y();
  }
}
xt(IB, { id: {}, object: {} }, ["default"], [], !0);
function wB(s, e, t) {
  let n;
  const i = Fs();
  if ($e(s, i, (c) => t(2, n = c)), !n)
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  let { id: r = "default" } = e;
  const { addPortal: a, removePortal: o } = nb();
  return Ft(i, (c) => {
    if (c)
      return a(c, r), () => {
        o(r);
      };
  }), s.$$set = (c) => {
    "id" in c && t(1, r = c.id);
  }, [i, r];
}
class TB extends St {
  constructor(e) {
    super(), Et(this, e, wB, null, pt, { id: 1 });
  }
  get id() {
    return this.$$.ctx[1];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
}
xt(TB, { id: {} }, [], [], !0);
function BB() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(i, r) {
    var a = i.id, o = i.name, c = i.dependencies;
    c === void 0 && (c = []);
    var l = i.init;
    l === void 0 && (l = function() {
    });
    var u = i.getTransferables;
    if (u === void 0 && (u = null), !s[a])
      try {
        c = c.map(function(f) {
          return f && f.isWorkerModule && (e(f, function(d) {
            if (d instanceof Error)
              throw d;
          }), f = s[f.id].value), f;
        }), l = n("<" + o + ">.init", l), u && (u = n("<" + o + ">.getTransferables", u));
        var h = null;
        typeof l == "function" ? h = l.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: h,
          getTransferables: u
        }, r(h);
      } catch (f) {
        f && f.noLog || console.error(f), r(f);
      }
  }
  function t(i, r) {
    var a, o = i.id, c = i.args;
    (!s[o] || typeof s[o].value != "function") && r(new Error("Worker module " + o + ": not found or its 'init' did not return a function"));
    try {
      var l = (a = s[o]).value.apply(a, c);
      l && typeof l.then == "function" ? l.then(u, function(h) {
        return r(h instanceof Error ? h : new Error("" + h));
      }) : u(l);
    } catch (h) {
      r(h);
    }
    function u(h) {
      try {
        var f = s[o].getTransferables && s[o].getTransferables(h);
        (!f || !Array.isArray(f) || !f.length) && (f = void 0), r(h, f);
      } catch (d) {
        console.error(d), r(d);
      }
    }
  }
  function n(i, r) {
    var a = void 0;
    self.troikaDefine = function(c) {
      return a = c;
    };
    var o = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + r + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(o);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(o), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(i) {
    var r = i.data, a = r.messageId, o = r.action, c = r.data;
    try {
      o === "registerModule" && e(c, function(l) {
        l instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof l == "function" }
        });
      }), o === "callModule" && t(c, function(l, u) {
        l instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: l.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: l
        }, u || void 0);
      });
    } catch (l) {
      postMessage({
        messageId: a,
        success: !1,
        error: l.stack
      });
    }
  });
}
function RB(s) {
  var e = function() {
    for (var t = [], n = arguments.length; n--; )
      t[n] = arguments[n];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = s.dependencies, n = s.init;
    t = Array.isArray(t) ? t.map(
      function(r) {
        return r && r._getInitResult ? r._getInitResult() : r;
      }
    ) : [];
    var i = Promise.all(t).then(function(r) {
      return n.apply(null, r);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var ib = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return ib = function() {
    return s;
  }, s;
}, DB = 0, LB = 0, Oh = !1, Eo = /* @__PURE__ */ Object.create(null), xo = /* @__PURE__ */ Object.create(null), Ff = /* @__PURE__ */ Object.create(null);
function ec(s) {
  if ((!s || typeof s.init != "function") && !Oh)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, t = s.init, n = s.getTransferables, i = s.workerId;
  if (!ib())
    return RB(s);
  i == null && (i = "#default");
  var r = "workerModule" + ++DB, a = s.name || r, o = null;
  e = e && e.map(function(l) {
    return typeof l == "function" && !l.workerModuleData && (Oh = !0, l = ec({
      workerId: i,
      name: "<" + a + "> function dependency: " + l.name,
      init: `function(){return (
` + gl(l) + `
)}`
    }), Oh = !1), l && l.workerModuleData && (l = l.workerModuleData), l;
  });
  function c() {
    for (var l = [], u = arguments.length; u--; )
      l[u] = arguments[u];
    if (!o) {
      o = Qg(i, "registerModule", c.workerModuleData);
      var h = function() {
        o = null, xo[i].delete(h);
      };
      (xo[i] || (xo[i] = /* @__PURE__ */ new Set())).add(h);
    }
    return o.then(function(f) {
      var d = f.isCallable;
      if (d)
        return Qg(i, "callModule", { id: r, args: l });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return c.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: a,
    dependencies: e,
    init: gl(t),
    getTransferables: n && gl(n)
  }, c;
}
function PB(s) {
  xo[s] && xo[s].forEach(function(e) {
    e();
  }), Eo[s] && (Eo[s].terminate(), delete Eo[s]);
}
function gl(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function UB(s) {
  var e = Eo[s];
  if (!e) {
    var t = gl(BB);
    e = Eo[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(n) {
      var i = n.data, r = i.messageId, a = Ff[r];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete Ff[r], a(i);
    };
  }
  return e;
}
function Qg(s, e, t) {
  return new Promise(function(n, i) {
    var r = ++LB;
    Ff[r] = function(a) {
      a.success ? n(a.result) : i(new Error("Error in worker " + e + " call: " + a.error));
    }, UB(s).postMessage({
      messageId: r,
      action: e,
      data: t
    });
  });
}
function rb() {
  var s = function(e) {
    function t(z, X, w, N, H, j, $, ce) {
      var ee = 1 - $;
      ce.x = ee * ee * z + 2 * ee * $ * w + $ * $ * H, ce.y = ee * ee * X + 2 * ee * $ * N + $ * $ * j;
    }
    function n(z, X, w, N, H, j, $, ce, ee, le) {
      var Z = 1 - ee;
      le.x = Z * Z * Z * z + 3 * Z * Z * ee * w + 3 * Z * ee * ee * H + ee * ee * ee * $, le.y = Z * Z * Z * X + 3 * Z * Z * ee * N + 3 * Z * ee * ee * j + ee * ee * ee * ce;
    }
    function i(z, X) {
      for (var w = /([MLQCZ])([^MLQCZ]*)/g, N, H, j, $, ce; N = w.exec(z); ) {
        var ee = N[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(le) {
          return parseFloat(le);
        });
        switch (N[1]) {
          case "M":
            $ = H = ee[0], ce = j = ee[1];
            break;
          case "L":
            (ee[0] !== $ || ee[1] !== ce) && X("L", $, ce, $ = ee[0], ce = ee[1]);
            break;
          case "Q": {
            X("Q", $, ce, $ = ee[2], ce = ee[3], ee[0], ee[1]);
            break;
          }
          case "C": {
            X("C", $, ce, $ = ee[4], ce = ee[5], ee[0], ee[1], ee[2], ee[3]);
            break;
          }
          case "Z":
            ($ !== H || ce !== j) && X("L", $, ce, H, j);
            break;
        }
      }
    }
    function r(z, X, w) {
      w === void 0 && (w = 16);
      var N = { x: 0, y: 0 };
      i(z, function(H, j, $, ce, ee, le, Z, he, _e) {
        switch (H) {
          case "L":
            X(j, $, ce, ee);
            break;
          case "Q": {
            for (var U = j, ye = $, ie = 1; ie < w; ie++)
              t(
                j,
                $,
                le,
                Z,
                ce,
                ee,
                ie / (w - 1),
                N
              ), X(U, ye, N.x, N.y), U = N.x, ye = N.y;
            break;
          }
          case "C": {
            for (var re = j, te = $, Ie = 1; Ie < w; Ie++)
              n(
                j,
                $,
                le,
                Z,
                he,
                _e,
                ce,
                ee,
                Ie / (w - 1),
                N
              ), X(re, te, N.x, N.y), re = N.x, te = N.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", o = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), l = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function u(z, X) {
      var w = z.getContext ? z.getContext("webgl", l) : z, N = c.get(w);
      if (!N) {
        let Z = function(re) {
          var te = j[re];
          if (!te && (te = j[re] = w.getExtension(re), !te))
            throw new Error(re + " not supported");
          return te;
        }, he = function(re, te) {
          var Ie = w.createShader(te);
          return w.shaderSource(Ie, re), w.compileShader(Ie), Ie;
        }, _e = function(re, te, Ie, se) {
          if (!$[re]) {
            var K = {}, ve = {}, fe = w.createProgram();
            w.attachShader(fe, he(te, w.VERTEX_SHADER)), w.attachShader(fe, he(Ie, w.FRAGMENT_SHADER)), w.linkProgram(fe), $[re] = {
              program: fe,
              transaction: function(L) {
                w.useProgram(fe), L({
                  setUniform: function(W, de) {
                    for (var Ae = [], G = arguments.length - 2; G-- > 0; )
                      Ae[G] = arguments[G + 2];
                    var Ce = ve[de] || (ve[de] = w.getUniformLocation(fe, de));
                    w["uniform" + W].apply(w, [Ce].concat(Ae));
                  },
                  setAttribute: function(W, de, Ae, G, Ce) {
                    var Se = K[W];
                    Se || (Se = K[W] = {
                      buf: w.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: w.getAttribLocation(fe, W),
                      data: null
                    }), w.bindBuffer(w.ARRAY_BUFFER, Se.buf), w.vertexAttribPointer(Se.loc, de, w.FLOAT, !1, 0, 0), w.enableVertexAttribArray(Se.loc), H ? w.vertexAttribDivisor(Se.loc, G) : Z("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Se.loc, G), Ce !== Se.data && (w.bufferData(w.ARRAY_BUFFER, Ce, Ae), Se.data = Ce);
                  }
                });
              }
            };
          }
          $[re].transaction(se);
        }, U = function(re, te) {
          ee++;
          try {
            w.activeTexture(w.TEXTURE0 + ee);
            var Ie = ce[re];
            Ie || (Ie = ce[re] = w.createTexture(), w.bindTexture(w.TEXTURE_2D, Ie), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.NEAREST), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.NEAREST)), w.bindTexture(w.TEXTURE_2D, Ie), te(Ie, ee);
          } finally {
            ee--;
          }
        }, ye = function(re, te, Ie) {
          var se = w.createFramebuffer();
          le.push(se), w.bindFramebuffer(w.FRAMEBUFFER, se), w.activeTexture(w.TEXTURE0 + te), w.bindTexture(w.TEXTURE_2D, re), w.framebufferTexture2D(w.FRAMEBUFFER, w.COLOR_ATTACHMENT0, w.TEXTURE_2D, re, 0);
          try {
            Ie(se);
          } finally {
            w.deleteFramebuffer(se), w.bindFramebuffer(w.FRAMEBUFFER, le[--le.length - 1] || null);
          }
        }, ie = function() {
          j = {}, $ = {}, ce = {}, ee = -1, le.length = 0;
        };
        var H = typeof WebGL2RenderingContext < "u" && w instanceof WebGL2RenderingContext, j = {}, $ = {}, ce = {}, ee = -1, le = [];
        w.canvas.addEventListener("webglcontextlost", function(re) {
          ie(), re.preventDefault();
        }, !1), c.set(w, N = {
          gl: w,
          isWebGL2: H,
          getExtension: Z,
          withProgram: _e,
          withTexture: U,
          withTextureFramebuffer: ye,
          handleContextLoss: ie
        });
      }
      X(N);
    }
    function h(z, X, w, N, H, j, $, ce) {
      $ === void 0 && ($ = 15), ce === void 0 && (ce = null), u(z, function(ee) {
        var le = ee.gl, Z = ee.withProgram, he = ee.withTexture;
        he("copy", function(_e, U) {
          le.texImage2D(le.TEXTURE_2D, 0, le.RGBA, H, j, 0, le.RGBA, le.UNSIGNED_BYTE, X), Z("copy", a, o, function(ye) {
            var ie = ye.setUniform, re = ye.setAttribute;
            re("aUV", 2, le.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), ie("1i", "image", U), le.bindFramebuffer(le.FRAMEBUFFER, ce || null), le.disable(le.BLEND), le.colorMask($ & 8, $ & 4, $ & 2, $ & 1), le.viewport(w, N, H, j), le.scissor(w, N, H, j), le.drawArrays(le.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function f(z, X, w) {
      var N = z.width, H = z.height;
      u(z, function(j) {
        var $ = j.gl, ce = new Uint8Array(N * H * 4);
        $.readPixels(0, 0, N, H, $.RGBA, $.UNSIGNED_BYTE, ce), z.width = X, z.height = w, h($, ce, 0, 0, N, H);
      });
    }
    var d = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: f
    });
    function A(z, X, w, N, H, j) {
      j === void 0 && (j = 1);
      var $ = new Uint8Array(z * X), ce = N[2] - N[0], ee = N[3] - N[1], le = [];
      r(w, function(re, te, Ie, se) {
        le.push({
          x1: re,
          y1: te,
          x2: Ie,
          y2: se,
          minX: Math.min(re, Ie),
          minY: Math.min(te, se),
          maxX: Math.max(re, Ie),
          maxY: Math.max(te, se)
        });
      }), le.sort(function(re, te) {
        return re.maxX - te.maxX;
      });
      for (var Z = 0; Z < z; Z++)
        for (var he = 0; he < X; he++) {
          var _e = ye(
            N[0] + ce * (Z + 0.5) / z,
            N[1] + ee * (he + 0.5) / X
          ), U = Math.pow(1 - Math.abs(_e) / H, j) / 2;
          _e < 0 && (U = 1 - U), U = Math.max(0, Math.min(255, Math.round(U * 255))), $[he * z + Z] = U;
        }
      return $;
      function ye(re, te) {
        for (var Ie = 1 / 0, se = 1 / 0, K = le.length; K--; ) {
          var ve = le[K];
          if (ve.maxX + se <= re)
            break;
          if (re + se > ve.minX && te - se < ve.maxY && te + se > ve.minY) {
            var fe = g(re, te, ve.x1, ve.y1, ve.x2, ve.y2);
            fe < Ie && (Ie = fe, se = Math.sqrt(Ie));
          }
        }
        return ie(re, te) && (se = -se), se;
      }
      function ie(re, te) {
        for (var Ie = 0, se = le.length; se--; ) {
          var K = le[se];
          if (K.maxX <= re)
            break;
          var ve = K.y1 > te != K.y2 > te && re < (K.x2 - K.x1) * (te - K.y1) / (K.y2 - K.y1) + K.x1;
          ve && (Ie += K.y1 < K.y2 ? 1 : -1);
        }
        return Ie !== 0;
      }
    }
    function m(z, X, w, N, H, j, $, ce, ee, le) {
      j === void 0 && (j = 1), ce === void 0 && (ce = 0), ee === void 0 && (ee = 0), le === void 0 && (le = 0), p(z, X, w, N, H, j, $, null, ce, ee, le);
    }
    function p(z, X, w, N, H, j, $, ce, ee, le, Z) {
      j === void 0 && (j = 1), ee === void 0 && (ee = 0), le === void 0 && (le = 0), Z === void 0 && (Z = 0);
      for (var he = A(z, X, w, N, H, j), _e = new Uint8Array(he.length * 4), U = 0; U < he.length; U++)
        _e[U * 4 + Z] = he[U];
      h($, _e, ee, le, z, X, 1 << 3 - Z, ce);
    }
    function g(z, X, w, N, H, j) {
      var $ = H - w, ce = j - N, ee = $ * $ + ce * ce, le = ee ? Math.max(0, Math.min(1, ((z - w) * $ + (X - N) * ce) / ee)) : 0, Z = z - (w + le * $), he = X - (N + le * ce);
      return Z * Z + he * he;
    }
    var _ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: A,
      generateIntoCanvas: m,
      generateIntoFramebuffer: p
    }), b = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", y = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", v = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", x = new Float32Array([0, 0, 2, 0, 0, 2]), S = null, I = !1, E = {}, M = /* @__PURE__ */ new WeakMap();
    function T(z) {
      if (!I && !R(z))
        throw new Error("WebGL generation not supported");
    }
    function D(z, X, w, N, H, j, $) {
      if (j === void 0 && (j = 1), $ === void 0 && ($ = null), !$ && ($ = S, !$)) {
        var ce = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!ce)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        $ = S = ce.getContext("webgl", { depth: !1 });
      }
      T($);
      var ee = new Uint8Array(z * X * 4);
      u($, function(_e) {
        var U = _e.gl, ye = _e.withTexture, ie = _e.withTextureFramebuffer;
        ye("readable", function(re, te) {
          U.texImage2D(U.TEXTURE_2D, 0, U.RGBA, z, X, 0, U.RGBA, U.UNSIGNED_BYTE, null), ie(re, te, function(Ie) {
            C(
              z,
              X,
              w,
              N,
              H,
              j,
              U,
              Ie,
              0,
              0,
              0
              // red channel
            ), U.readPixels(0, 0, z, X, U.RGBA, U.UNSIGNED_BYTE, ee);
          });
        });
      });
      for (var le = new Uint8Array(z * X), Z = 0, he = 0; Z < ee.length; Z += 4)
        le[he++] = ee[Z];
      return le;
    }
    function F(z, X, w, N, H, j, $, ce, ee, le) {
      j === void 0 && (j = 1), ce === void 0 && (ce = 0), ee === void 0 && (ee = 0), le === void 0 && (le = 0), C(z, X, w, N, H, j, $, null, ce, ee, le);
    }
    function C(z, X, w, N, H, j, $, ce, ee, le, Z) {
      j === void 0 && (j = 1), ee === void 0 && (ee = 0), le === void 0 && (le = 0), Z === void 0 && (Z = 0), T($);
      var he = [];
      r(w, function(_e, U, ye, ie) {
        he.push(_e, U, ye, ie);
      }), he = new Float32Array(he), u($, function(_e) {
        var U = _e.gl, ye = _e.isWebGL2, ie = _e.getExtension, re = _e.withProgram, te = _e.withTexture, Ie = _e.withTextureFramebuffer, se = _e.handleContextLoss;
        if (te("rawDistances", function(K, ve) {
          (z !== K._lastWidth || X !== K._lastHeight) && U.texImage2D(
            U.TEXTURE_2D,
            0,
            U.RGBA,
            K._lastWidth = z,
            K._lastHeight = X,
            0,
            U.RGBA,
            U.UNSIGNED_BYTE,
            null
          ), re("main", b, y, function(fe) {
            var oe = fe.setAttribute, L = fe.setUniform, B = !ye && ie("ANGLE_instanced_arrays"), W = !ye && ie("EXT_blend_minmax");
            oe("aUV", 2, U.STATIC_DRAW, 0, x), oe("aLineSegment", 4, U.DYNAMIC_DRAW, 1, he), L.apply(void 0, ["4f", "uGlyphBounds"].concat(N)), L("1f", "uMaxDistance", H), L("1f", "uExponent", j), Ie(K, ve, function(de) {
              U.enable(U.BLEND), U.colorMask(!0, !0, !0, !0), U.viewport(0, 0, z, X), U.scissor(0, 0, z, X), U.blendFunc(U.ONE, U.ONE), U.blendEquationSeparate(U.FUNC_ADD, ye ? U.MAX : W.MAX_EXT), U.clear(U.COLOR_BUFFER_BIT), ye ? U.drawArraysInstanced(U.TRIANGLES, 0, 3, he.length / 4) : B.drawArraysInstancedANGLE(U.TRIANGLES, 0, 3, he.length / 4);
            });
          }), re("post", a, v, function(fe) {
            fe.setAttribute("aUV", 2, U.STATIC_DRAW, 0, x), fe.setUniform("1i", "tex", ve), U.bindFramebuffer(U.FRAMEBUFFER, ce), U.disable(U.BLEND), U.colorMask(Z === 0, Z === 1, Z === 2, Z === 3), U.viewport(ee, le, z, X), U.scissor(ee, le, z, X), U.drawArrays(U.TRIANGLES, 0, 3);
          });
        }), U.isContextLost())
          throw se(), new Error("webgl context lost");
      });
    }
    function R(z) {
      var X = !z || z === S ? E : z.canvas || z, w = M.get(X);
      if (w === void 0) {
        I = !0;
        var N = null;
        try {
          var H = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], j = D(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            z
          );
          w = j && H.length === j.length && j.every(function($, ce) {
            return $ === H[ce];
          }), w || (N = "bad trial run results", console.info(H, j));
        } catch ($) {
          w = !1, N = $.message;
        }
        N && console.warn("WebGL SDF generation not supported:", N), I = !1, M.set(X, w);
      }
      return w;
    }
    var O = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: F,
      generateIntoFramebuffer: C,
      isSupported: R
    });
    function V(z, X, w, N, H, j) {
      H === void 0 && (H = Math.max(N[2] - N[0], N[3] - N[1]) / 2), j === void 0 && (j = 1);
      try {
        return D.apply(O, arguments);
      } catch ($) {
        return console.info("WebGL SDF generation failed, falling back to JS", $), A.apply(_, arguments);
      }
    }
    function q(z, X, w, N, H, j, $, ce, ee, le) {
      H === void 0 && (H = Math.max(N[2] - N[0], N[3] - N[1]) / 2), j === void 0 && (j = 1), ce === void 0 && (ce = 0), ee === void 0 && (ee = 0), le === void 0 && (le = 0);
      try {
        return F.apply(O, arguments);
      } catch (Z) {
        return console.info("WebGL SDF generation failed, falling back to JS", Z), m.apply(_, arguments);
      }
    }
    return e.forEachPathCommand = i, e.generate = V, e.generateIntoCanvas = q, e.javascript = _, e.pathToLineSegments = r, e.webgl = O, e.webglUtils = d, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function FB() {
  var s = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, n = {}, i = {};
    n.L = 1, i[1] = "L", Object.keys(t).forEach(function(se, K) {
      n[se] = 1 << K + 1, i[n[se]] = se;
    }), Object.freeze(n);
    var r = n.LRI | n.RLI | n.FSI, a = n.L | n.R | n.AL, o = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI, c = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF, l = n.S | n.WS | n.B | r | n.PDI | c, u = null;
    function h() {
      if (!u) {
        u = /* @__PURE__ */ new Map();
        var se = function(ve) {
          if (t.hasOwnProperty(ve)) {
            var fe = 0;
            t[ve].split(",").forEach(function(oe) {
              var L = oe.split("+"), B = L[0], W = L[1];
              B = parseInt(B, 36), W = W ? parseInt(W, 36) : 0, u.set(fe += B, n[ve]);
              for (var de = 0; de < W; de++)
                u.set(++fe, n[ve]);
            });
          }
        };
        for (var K in t)
          se(K);
      }
    }
    function f(se) {
      return h(), u.get(se.codePointAt(0)) || n.L;
    }
    function d(se) {
      return i[f(se)];
    }
    var A = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function m(se, K) {
      var ve = 36, fe = 0, oe = /* @__PURE__ */ new Map(), L = K && /* @__PURE__ */ new Map(), B;
      return se.split(",").forEach(function W(de) {
        if (de.indexOf("+") !== -1)
          for (var Ae = +de; Ae--; )
            W(B);
        else {
          B = de;
          var G = de.split(">"), Ce = G[0], Se = G[1];
          Ce = String.fromCodePoint(fe += parseInt(Ce, ve)), Se = String.fromCodePoint(fe += parseInt(Se, ve)), oe.set(Ce, Se), K && L.set(Se, Ce);
        }
      }), { map: oe, reverseMap: L };
    }
    var p, g, _;
    function b() {
      if (!p) {
        var se = m(A.pairs, !0), K = se.map, ve = se.reverseMap;
        p = K, g = ve, _ = m(A.canonical, !1).map;
      }
    }
    function y(se) {
      return b(), p.get(se) || null;
    }
    function v(se) {
      return b(), g.get(se) || null;
    }
    function x(se) {
      return b(), _.get(se) || null;
    }
    var S = n.L, I = n.R, E = n.EN, M = n.ES, T = n.ET, D = n.AN, F = n.CS, C = n.B, R = n.S, O = n.ON, V = n.BN, q = n.NSM, z = n.AL, X = n.LRO, w = n.RLO, N = n.LRE, H = n.RLE, j = n.PDF, $ = n.LRI, ce = n.RLI, ee = n.FSI, le = n.PDI;
    function Z(se, K) {
      for (var ve = 125, fe = new Uint32Array(se.length), oe = 0; oe < se.length; oe++)
        fe[oe] = f(se[oe]);
      var L = /* @__PURE__ */ new Map();
      function B(ei, Ii) {
        var ti = fe[ei];
        fe[ei] = Ii, L.set(ti, L.get(ti) - 1), ti & o && L.set(o, L.get(o) - 1), L.set(Ii, (L.get(Ii) || 0) + 1), Ii & o && L.set(o, (L.get(o) || 0) + 1);
      }
      for (var W = new Uint8Array(se.length), de = /* @__PURE__ */ new Map(), Ae = [], G = null, Ce = 0; Ce < se.length; Ce++)
        G || Ae.push(G = {
          start: Ce,
          end: se.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: K === "rtl" ? 1 : K === "ltr" ? 0 : Kd(Ce, !1)
        }), fe[Ce] & C && (G.end = Ce, G = null);
      for (var Se = H | N | w | X | r | le | j | C, De = function(ei) {
        return ei + (ei & 1 ? 1 : 2);
      }, Q = function(ei) {
        return ei + (ei & 1 ? 2 : 1);
      }, Me = 0; Me < Ae.length; Me++) {
        G = Ae[Me];
        var pe = [{
          _level: G.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Le = void 0, Fe = 0, Ge = 0, Ue = 0;
        L.clear();
        for (var we = G.start; we <= G.end; we++) {
          var Ye = fe[we];
          if (Le = pe[pe.length - 1], L.set(Ye, (L.get(Ye) || 0) + 1), Ye & o && L.set(o, (L.get(o) || 0) + 1), Ye & Se)
            if (Ye & (H | N)) {
              W[we] = Le._level;
              var J = (Ye === H ? Q : De)(Le._level);
              J <= ve && !Fe && !Ge ? pe.push({
                _level: J,
                _override: 0,
                _isolate: 0
              }) : Fe || Ge++;
            } else if (Ye & (w | X)) {
              W[we] = Le._level;
              var ke = (Ye === w ? Q : De)(Le._level);
              ke <= ve && !Fe && !Ge ? pe.push({
                _level: ke,
                _override: Ye & w ? I : S,
                _isolate: 0
              }) : Fe || Ge++;
            } else if (Ye & r) {
              Ye & ee && (Ye = Kd(we + 1, !0) === 1 ? ce : $), W[we] = Le._level, Le._override && B(we, Le._override);
              var Te = (Ye === ce ? Q : De)(Le._level);
              Te <= ve && Fe === 0 && Ge === 0 ? (Ue++, pe.push({
                _level: Te,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: we
              })) : Fe++;
            } else if (Ye & le) {
              if (Fe > 0)
                Fe--;
              else if (Ue > 0) {
                for (Ge = 0; !pe[pe.length - 1]._isolate; )
                  pe.pop();
                var Ee = pe[pe.length - 1]._isolInitIndex;
                Ee != null && (de.set(Ee, we), de.set(we, Ee)), pe.pop(), Ue--;
              }
              Le = pe[pe.length - 1], W[we] = Le._level, Le._override && B(we, Le._override);
            } else
              Ye & j ? (Fe === 0 && (Ge > 0 ? Ge-- : !Le._isolate && pe.length > 1 && (pe.pop(), Le = pe[pe.length - 1])), W[we] = Le._level) : Ye & C && (W[we] = G.level);
          else
            W[we] = Le._level, Le._override && Ye !== V && B(we, Le._override);
        }
        for (var Re = [], Xe = null, Ke = G.start; Ke <= G.end; Ke++) {
          var Xt = fe[Ke];
          if (!(Xt & c)) {
            var yt = W[Ke], nt = Xt & r, kt = Xt === le;
            Xe && yt === Xe._level ? (Xe._end = Ke, Xe._endsWithIsolInit = nt) : Re.push(Xe = {
              _start: Ke,
              _end: Ke,
              _level: yt,
              _startsWithPDI: kt,
              _endsWithIsolInit: nt
            });
          }
        }
        for (var Yt = [], Lt = 0; Lt < Re.length; Lt++) {
          var gn = Re[Lt];
          if (!gn._startsWithPDI || gn._startsWithPDI && !de.has(gn._start)) {
            for (var Bn = [Xe = gn], mn = void 0; Xe && Xe._endsWithIsolInit && (mn = de.get(Xe._end)) != null; )
              for (var Zt = Lt + 1; Zt < Re.length; Zt++)
                if (Re[Zt]._start === mn) {
                  Bn.push(Xe = Re[Zt]);
                  break;
                }
            for (var Sn = [], Ei = 0; Ei < Bn.length; Ei++)
              for (var ci = Bn[Ei], Ki = ci._start; Ki <= ci._end; Ki++)
                Sn.push(Ki);
            for (var bu = W[Sn[0]], k = G.level, ne = Sn[0] - 1; ne >= 0; ne--)
              if (!(fe[ne] & c)) {
                k = W[ne];
                break;
              }
            var ge = Sn[Sn.length - 1], be = W[ge], me = G.level;
            if (!(fe[ge] & r)) {
              for (var We = ge + 1; We <= G.end; We++)
                if (!(fe[We] & c)) {
                  me = W[We];
                  break;
                }
            }
            Yt.push({
              _seqIndices: Sn,
              _sosType: Math.max(k, bu) % 2 ? I : S,
              _eosType: Math.max(me, be) % 2 ? I : S
            });
          }
        }
        for (var Ze = 0; Ze < Yt.length; Ze++) {
          var et = Yt[Ze], Be = et._seqIndices, ct = et._sosType, lt = et._eosType, it = W[Be[0]] & 1 ? I : S;
          if (L.get(q))
            for (var Gt = 0; Gt < Be.length; Gt++) {
              var Nn = Be[Gt];
              if (fe[Nn] & q) {
                for (var an = ct, Zn = Gt - 1; Zn >= 0; Zn--)
                  if (!(fe[Be[Zn]] & c)) {
                    an = fe[Be[Zn]];
                    break;
                  }
                B(Nn, an & (r | le) ? O : an);
              }
            }
          if (L.get(E))
            for (var Ut = 0; Ut < Be.length; Ut++) {
              var ht = Be[Ut];
              if (fe[ht] & E)
                for (var gr = Ut - 1; gr >= -1; gr--) {
                  var Vt = gr === -1 ? ct : fe[Be[gr]];
                  if (Vt & a) {
                    Vt === z && B(ht, D);
                    break;
                  }
                }
            }
          if (L.get(z))
            for (var xi = 0; xi < Be.length; xi++) {
              var Ua = Be[xi];
              fe[Ua] & z && B(Ua, I);
            }
          if (L.get(M) || L.get(F))
            for (var Si = 1; Si < Be.length - 1; Si++) {
              var Vr = Be[Si];
              if (fe[Vr] & (M | F)) {
                for (var $t = 0, Ci = 0, Wr = Si - 1; Wr >= 0 && ($t = fe[Be[Wr]], !!($t & c)); Wr--)
                  ;
                for (var On = Si + 1; On < Be.length && (Ci = fe[Be[On]], !!(Ci & c)); On++)
                  ;
                $t === Ci && (fe[Vr] === M ? $t === E : $t & (E | D)) && B(Vr, $t);
              }
            }
          if (L.get(E))
            for (var $n = 0; $n < Be.length; $n++) {
              var yu = Be[$n];
              if (fe[yu] & E) {
                for (var qr = $n - 1; qr >= 0 && fe[Be[qr]] & (T | c); qr--)
                  B(Be[qr], E);
                for ($n++; $n < Be.length && fe[Be[$n]] & (T | c | E); $n++)
                  fe[Be[$n]] !== E && B(Be[$n], E);
              }
            }
          if (L.get(T) || L.get(M) || L.get(F))
            for (var Fa = 0; Fa < Be.length; Fa++) {
              var Nd = Be[Fa];
              if (fe[Nd] & (T | M | F)) {
                B(Nd, O);
                for (var tc = Fa - 1; tc >= 0 && fe[Be[tc]] & c; tc--)
                  B(Be[tc], O);
                for (var nc = Fa + 1; nc < Be.length && fe[Be[nc]] & c; nc++)
                  B(Be[nc], O);
              }
            }
          if (L.get(E))
            for (var vu = 0, Od = ct; vu < Be.length; vu++) {
              var Qd = Be[vu], Eu = fe[Qd];
              Eu & E ? Od === S && B(Qd, S) : Eu & a && (Od = Eu);
            }
          if (L.get(o)) {
            var ka = I | E | D, Gd = ka | S, ic = [];
            {
              for (var ks = [], Ns = 0; Ns < Be.length; Ns++)
                if (fe[Be[Ns]] & o) {
                  var Na = se[Be[Ns]], zd = void 0;
                  if (y(Na) !== null)
                    if (ks.length < 63)
                      ks.push({ char: Na, seqIndex: Ns });
                    else
                      break;
                  else if ((zd = v(Na)) !== null)
                    for (var Oa = ks.length - 1; Oa >= 0; Oa--) {
                      var xu = ks[Oa].char;
                      if (xu === zd || xu === v(x(Na)) || y(x(xu)) === Na) {
                        ic.push([ks[Oa].seqIndex, Ns]), ks.length = Oa;
                        break;
                      }
                    }
                }
              ic.sort(function(ei, Ii) {
                return ei[0] - Ii[0];
              });
            }
            for (var Su = 0; Su < ic.length; Su++) {
              for (var Hd = ic[Su], rc = Hd[0], Cu = Hd[1], Vd = !1, Mi = 0, Mu = rc + 1; Mu < Cu; Mu++) {
                var Wd = Be[Mu];
                if (fe[Wd] & Gd) {
                  Vd = !0;
                  var qd = fe[Wd] & ka ? I : S;
                  if (qd === it) {
                    Mi = qd;
                    break;
                  }
                }
              }
              if (Vd && !Mi) {
                Mi = ct;
                for (var Iu = rc - 1; Iu >= 0; Iu--) {
                  var Xd = Be[Iu];
                  if (fe[Xd] & Gd) {
                    var Yd = fe[Xd] & ka ? I : S;
                    Yd !== it ? Mi = Yd : Mi = it;
                    break;
                  }
                }
              }
              if (Mi) {
                if (fe[Be[rc]] = fe[Be[Cu]] = Mi, Mi !== it) {
                  for (var Qa = rc + 1; Qa < Be.length; Qa++)
                    if (!(fe[Be[Qa]] & c)) {
                      f(se[Be[Qa]]) & q && (fe[Be[Qa]] = Mi);
                      break;
                    }
                }
                if (Mi !== it) {
                  for (var Ga = Cu + 1; Ga < Be.length; Ga++)
                    if (!(fe[Be[Ga]] & c)) {
                      f(se[Be[Ga]]) & q && (fe[Be[Ga]] = Mi);
                      break;
                    }
                }
              }
            }
            for (var mr = 0; mr < Be.length; mr++)
              if (fe[Be[mr]] & o) {
                for (var jd = mr, wu = mr, Tu = ct, za = mr - 1; za >= 0; za--)
                  if (fe[Be[za]] & c)
                    jd = za;
                  else {
                    Tu = fe[Be[za]] & ka ? I : S;
                    break;
                  }
                for (var Jd = lt, Ha = mr + 1; Ha < Be.length; Ha++)
                  if (fe[Be[Ha]] & (o | c))
                    wu = Ha;
                  else {
                    Jd = fe[Be[Ha]] & ka ? I : S;
                    break;
                  }
                for (var Bu = jd; Bu <= wu; Bu++)
                  fe[Be[Bu]] = Tu === Jd ? Tu : it;
                mr = wu;
              }
          }
        }
        for (var li = G.start; li <= G.end; li++) {
          var Ab = W[li], sc = fe[li];
          if (Ab & 1 ? sc & (S | E | D) && W[li]++ : sc & I ? W[li]++ : sc & (D | E) && (W[li] += 2), sc & c && (W[li] = li === 0 ? G.level : W[li - 1]), li === G.end || f(se[li]) & (R | C))
            for (var ac = li; ac >= 0 && f(se[ac]) & l; ac--)
              W[ac] = G.level;
        }
      }
      return {
        levels: W,
        paragraphs: Ae
      };
      function Kd(ei, Ii) {
        for (var ti = ei; ti < se.length; ti++) {
          var _r = fe[ti];
          if (_r & (I | z))
            return 1;
          if (_r & (C | S) || Ii && _r === le)
            return 0;
          if (_r & r) {
            var Zd = gb(ti);
            ti = Zd === -1 ? se.length : Zd;
          }
        }
        return 0;
      }
      function gb(ei) {
        for (var Ii = 1, ti = ei + 1; ti < se.length; ti++) {
          var _r = fe[ti];
          if (_r & C)
            break;
          if (_r & le) {
            if (--Ii === 0)
              return ti;
          } else
            _r & r && Ii++;
        }
        return -1;
      }
    }
    var he = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", _e;
    function U() {
      if (!_e) {
        var se = m(he, !0), K = se.map, ve = se.reverseMap;
        ve.forEach(function(fe, oe) {
          K.set(oe, fe);
        }), _e = K;
      }
    }
    function ye(se) {
      return U(), _e.get(se) || null;
    }
    function ie(se, K, ve, fe) {
      var oe = se.length;
      ve = Math.max(0, ve == null ? 0 : +ve), fe = Math.min(oe - 1, fe == null ? oe - 1 : +fe);
      for (var L = /* @__PURE__ */ new Map(), B = ve; B <= fe; B++)
        if (K[B] & 1) {
          var W = ye(se[B]);
          W !== null && L.set(B, W);
        }
      return L;
    }
    function re(se, K, ve, fe) {
      var oe = se.length;
      ve = Math.max(0, ve == null ? 0 : +ve), fe = Math.min(oe - 1, fe == null ? oe - 1 : +fe);
      var L = [];
      return K.paragraphs.forEach(function(B) {
        var W = Math.max(ve, B.start), de = Math.min(fe, B.end);
        if (W < de) {
          for (var Ae = K.levels.slice(W, de + 1), G = de; G >= W && f(se[G]) & l; G--)
            Ae[G] = B.level;
          for (var Ce = B.level, Se = 1 / 0, De = 0; De < Ae.length; De++) {
            var Q = Ae[De];
            Q > Ce && (Ce = Q), Q < Se && (Se = Q | 1);
          }
          for (var Me = Ce; Me >= Se; Me--)
            for (var pe = 0; pe < Ae.length; pe++)
              if (Ae[pe] >= Me) {
                for (var Le = pe; pe + 1 < Ae.length && Ae[pe + 1] >= Me; )
                  pe++;
                pe > Le && L.push([Le + W, pe + W]);
              }
        }
      }), L;
    }
    function te(se, K, ve, fe) {
      var oe = Ie(se, K, ve, fe), L = [].concat(se);
      return oe.forEach(function(B, W) {
        L[W] = (K.levels[B] & 1 ? ye(se[B]) : null) || se[B];
      }), L.join("");
    }
    function Ie(se, K, ve, fe) {
      for (var oe = re(se, K, ve, fe), L = [], B = 0; B < se.length; B++)
        L[B] = B;
      return oe.forEach(function(W) {
        for (var de = W[0], Ae = W[1], G = L.slice(de, Ae + 1), Ce = G.length; Ce--; )
          L[Ae - Ce] = G[Ce];
      }), L;
    }
    return e.closingToOpeningBracket = v, e.getBidiCharType = f, e.getBidiCharTypeName = d, e.getCanonicalBracket = x, e.getEmbeddingLevels = Z, e.getMirroredCharacter = ye, e.getMirroredCharactersMap = ie, e.getReorderSegments = re, e.getReorderedIndices = Ie, e.getReorderedString = te, e.openingToClosingBracket = y, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const sb = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function kf(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(n, i) {
    let r = tt[i];
    return r ? kf(r) : n;
  }
  return s.replace(e, t);
}
const Rn = [];
for (let s = 0; s < 256; s++)
  Rn[s] = (s < 16 ? "0" : "") + s.toString(16);
function kB() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Rn[s & 255] + Rn[s >> 8 & 255] + Rn[s >> 16 & 255] + Rn[s >> 24 & 255] + "-" + Rn[e & 255] + Rn[e >> 8 & 255] + "-" + Rn[e >> 16 & 15 | 64] + Rn[e >> 24 & 255] + "-" + Rn[t & 63 | 128] + Rn[t >> 8 & 255] + "-" + Rn[t >> 16 & 255] + Rn[t >> 24 & 255] + Rn[n & 255] + Rn[n >> 8 & 255] + Rn[n >> 16 & 255] + Rn[n >> 24 & 255]).toUpperCase();
}
const as = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let n = arguments[e];
    if (n)
      for (let i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (s[i] = n[i]);
  }
  return s;
}, NB = Date.now(), Gg = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new Map();
let OB = 1e10;
function Nf(s, e) {
  const t = HB(e);
  let n = Gg.get(s);
  if (n || Gg.set(s, n = /* @__PURE__ */ Object.create(null)), n[t])
    return new n[t]();
  const i = `_onBeforeCompile${t}`, r = function(l, u) {
    s.onBeforeCompile.call(this, l, u);
    const h = this.customProgramCacheKey() + "|" + l.vertexShader + "|" + l.fragmentShader;
    let f = zg[h];
    if (!f) {
      const d = QB(this, l, e, t);
      f = zg[h] = d;
    }
    l.vertexShader = f.vertexShader, l.fragmentShader = f.fragmentShader, as(l.uniforms, this.uniforms), e.timeUniform && (l.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - NB;
      }
    }), this[i] && this[i](l);
  }, a = function() {
    return o(e.chained ? s : s.clone());
  }, o = function(l) {
    const u = Object.create(l, c);
    return Object.defineProperty(u, "baseMaterial", { value: s }), Object.defineProperty(u, "id", { value: OB++ }), u.uuid = kB(), u.uniforms = as({}, l.uniforms, e.uniforms), u.defines = as({}, l.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = as({}, l.extensions, e.extensions), u._listeners = void 0, u;
  }, c = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return r;
      },
      set(l) {
        this[i] = l;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(l) {
        return s.copy.call(this, l), !s.isShaderMaterial && !s.isDerivedMaterial && (as(this.extensions, l.extensions), as(this.defines, l.defines), as(this.uniforms, Vl.clone(l.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const l = new s.constructor();
        return o(l).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._depthMaterial;
        return l || (l = this._depthMaterial = Nf(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Wo({ depthPacking: Ql }),
          e
        ), l.defines.IS_DEPTH_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let l = this._distanceMaterial;
        return l || (l = this._distanceMaterial = Nf(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new Xl(),
          e
        ), l.defines.IS_DISTANCE_MATERIAL = "", l.uniforms = this.uniforms), l;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: l, _distanceMaterial: u } = this;
        l && l.dispose(), u && u.dispose(), s.dispose.call(this);
      }
    }
  };
  return n[t] = a, new a();
}
function QB(s, { vertexShader: e, fragmentShader: t }, n, i) {
  let {
    vertexDefs: r,
    vertexMainIntro: a,
    vertexMainOutro: o,
    vertexTransform: c,
    fragmentDefs: l,
    fragmentMainIntro: u,
    fragmentMainOutro: h,
    fragmentColorTransform: f,
    customRewriter: d,
    timeUniform: A
  } = n;
  if (r = r || "", a = a || "", o = o || "", l = l || "", u = u || "", h = h || "", (c || d) && (e = kf(e)), (f || d) && (t = t.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), t = kf(t)), d) {
    let m = d({ vertexShader: e, fragmentShader: t });
    e = m.vertexShader, t = m.fragmentShader;
  }
  if (f) {
    let m = [];
    t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (p) => (m.push(p), "")
    ), h = `${f}
${m.join(`
`)}
${h}`;
  }
  if (A) {
    const m = `
uniform float ${A};
`;
    r = m + r, l = m + l;
  }
  return c && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, r = `${r}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, a = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (m, p, g, _) => /\battribute\s+vec[23]\s+$/.test(_.substr(0, g)) ? p : `troika_${p}_${i}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = Hg(e, i, r, a, o), t = Hg(t, i, l, u, h), {
    vertexShader: e,
    fragmentShader: t
  };
}
function Hg(s, e, t, n, i) {
  return (n || i || t) && (s = s.replace(
    sb,
    `
${t}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`), s;
}
function GB(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let zB = 0;
const Vg = /* @__PURE__ */ new Map();
function HB(s) {
  const e = JSON.stringify(s, GB);
  let t = Vg.get(e);
  return t == null && Vg.set(e, t = ++zB), t;
}
function VB(s, e, t) {
  const {
    defaultFontURL: n
  } = t, i = /* @__PURE__ */ Object.create(null), r = 1 / 0, a = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, o = "[^\\S\\u00A0]", c = new RegExp(`${o}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function l(_, b) {
    function y() {
      const v = (x) => {
        console.error(`Failure loading font ${_}${_ === n ? "" : "; trying fallback"}`, x), _ !== n && (_ = n, y());
      };
      try {
        const x = new XMLHttpRequest();
        x.open("get", _, !0), x.responseType = "arraybuffer", x.onload = function() {
          if (x.status >= 400)
            v(new Error(x.statusText));
          else if (x.status > 0)
            try {
              const S = s(x.response);
              b(S);
            } catch (S) {
              v(S);
            }
        }, x.onerror = v, x.send();
      } catch (x) {
        v(x);
      }
    }
    y();
  }
  function u(_, b) {
    _ || (_ = n);
    let y = i[_];
    y ? y.pending ? y.pending.push(b) : b(y) : (i[_] = { pending: [b] }, l(_, (v) => {
      let x = i[_].pending;
      i[_] = v, x.forEach((S) => S(v));
    }));
  }
  function h({
    text: _ = "",
    font: b = n,
    sdfGlyphSize: y = 64,
    fontSize: v = 1,
    letterSpacing: x = 0,
    lineHeight: S = "normal",
    maxWidth: I = r,
    direction: E,
    textAlign: M = "left",
    textIndent: T = 0,
    whiteSpace: D = "normal",
    overflowWrap: F = "normal",
    anchorX: C = 0,
    anchorY: R = 0,
    includeCaretPositions: O = !1,
    chunkedBoundsSize: V = 8192,
    colorRanges: q = null
  }, z, X = !1) {
    const w = m(), N = { fontLoad: 0, typesetting: 0 };
    _.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), _ = _.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), v = +v, x = +x, I = +I, S = S || "normal", T = +T, u(b, (H) => {
      const j = isFinite(I);
      let $ = null, ce = null, ee = null, le = null, Z = null, he = null, _e = null, U = 0, ye = 0, ie = D !== "nowrap";
      const { ascender: re, descender: te, unitsPerEm: Ie, lineGap: se, capHeight: K, xHeight: ve } = H;
      N.fontLoad = m() - w;
      const fe = m(), oe = v / Ie;
      S === "normal" && (S = (re - te + se) / Ie), S = S * v;
      const L = (S - (re - te) * oe) / 2, B = -(re * oe + L), W = Math.min(S, (re - te) * oe), de = (re + te) / 2 * oe - W / 2;
      let Ae = T, G = new p();
      const Ce = [G];
      H.forEachGlyph(_, v, x, (Q, Me, pe) => {
        const Le = _.charAt(pe), Fe = Q.advanceWidth * oe, Ge = G.count;
        let Ue;
        if ("isEmpty" in Q || (Q.isWhitespace = !!Le && new RegExp(o).test(Le), Q.canBreakAfter = !!Le && c.test(Le), Q.isEmpty = Q.xMin === Q.xMax || Q.yMin === Q.yMax || a.test(Le)), !Q.isWhitespace && !Q.isEmpty && ye++, ie && j && !Q.isWhitespace && Me + Fe + Ae > I && Ge) {
          if (G.glyphAt(Ge - 1).glyphObj.canBreakAfter)
            Ue = new p(), Ae = -Me;
          else
            for (let Ye = Ge; Ye--; )
              if (Ye === 0 && F === "break-word") {
                Ue = new p(), Ae = -Me;
                break;
              } else if (G.glyphAt(Ye).glyphObj.canBreakAfter) {
                Ue = G.splitAt(Ye + 1);
                const J = Ue.glyphAt(0).x;
                Ae -= J;
                for (let ke = Ue.count; ke--; )
                  Ue.glyphAt(ke).x -= J;
                break;
              }
          Ue && (G.isSoftWrapped = !0, G = Ue, Ce.push(G), U = I);
        }
        let we = G.glyphAt(G.count);
        we.glyphObj = Q, we.x = Me + Ae, we.width = Fe, we.charIndex = pe, Le === `
` && (G = new p(), Ce.push(G), Ae = -(Me + Fe + x * v) + T);
      }), Ce.forEach((Q) => {
        for (let Me = Q.count; Me--; ) {
          let { glyphObj: pe, x: Le, width: Fe } = Q.glyphAt(Me);
          if (!pe.isWhitespace) {
            Q.width = Le + Fe, Q.width > U && (U = Q.width);
            return;
          }
        }
      });
      let Se = 0, De = 0;
      if (C && (typeof C == "number" ? Se = -C : typeof C == "string" && (Se = -U * (C === "left" ? 0 : C === "center" ? 0.5 : C === "right" ? 1 : d(C)))), R) {
        if (typeof R == "number")
          De = -R;
        else if (typeof R == "string") {
          let Q = Ce.length * S;
          De = R === "top" ? 0 : R === "top-baseline" ? -B : R === "top-cap" ? -B - K * oe : R === "top-ex" ? -B - ve * oe : R === "middle" ? Q / 2 : R === "bottom" ? Q : R === "bottom-baseline" ? Q - L + te * oe : d(R) * Q;
        }
      }
      if (!X) {
        const Q = e.getEmbeddingLevels(_, E);
        $ = new Uint16Array(ye), ce = new Float32Array(ye * 2), ee = {}, he = [r, r, -r, -r], _e = [];
        let Me = B;
        O && (Z = new Float32Array(_.length * 3)), q && (le = new Uint8Array(ye * 3));
        let pe = 0, Le = -1, Fe = -1, Ge, Ue;
        if (Ce.forEach((we, Ye) => {
          let { count: J, width: ke } = we;
          if (J > 0) {
            let Te = 0;
            for (let yt = J; yt-- && we.glyphAt(yt).glyphObj.isWhitespace; )
              Te++;
            let Ee = 0, Re = 0;
            if (M === "center")
              Ee = (U - ke) / 2;
            else if (M === "right")
              Ee = U - ke;
            else if (M === "justify" && we.isSoftWrapped) {
              let yt = 0;
              for (let nt = J - Te; nt--; )
                we.glyphAt(nt).glyphObj.isWhitespace && yt++;
              Re = (U - ke) / yt;
            }
            if (Re || Ee) {
              let yt = 0;
              for (let nt = 0; nt < J; nt++) {
                let kt = we.glyphAt(nt);
                const Yt = kt.glyphObj;
                kt.x += Ee + yt, Re !== 0 && Yt.isWhitespace && nt < J - Te && (yt += Re, kt.width += Re);
              }
            }
            const Xe = e.getReorderSegments(
              _,
              Q,
              we.glyphAt(0).charIndex,
              we.glyphAt(we.count - 1).charIndex
            );
            for (let yt = 0; yt < Xe.length; yt++) {
              const [nt, kt] = Xe[yt];
              let Yt = 1 / 0, Lt = -1 / 0;
              for (let gn = 0; gn < J; gn++)
                if (we.glyphAt(gn).charIndex >= nt) {
                  let Bn = gn, mn = gn;
                  for (; mn < J; mn++) {
                    let Zt = we.glyphAt(mn);
                    if (Zt.charIndex > kt)
                      break;
                    mn < J - Te && (Yt = Math.min(Yt, Zt.x), Lt = Math.max(Lt, Zt.x + Zt.width));
                  }
                  for (let Zt = Bn; Zt < mn; Zt++) {
                    const Sn = we.glyphAt(Zt);
                    Sn.x = Lt - (Sn.x + Sn.width - Yt);
                  }
                  break;
                }
            }
            let Ke;
            const Xt = (yt) => Ke = yt;
            for (let yt = 0; yt < J; yt++) {
              let nt = we.glyphAt(yt);
              Ke = nt.glyphObj;
              const kt = Ke.index, Yt = Q.levels[nt.charIndex] & 1;
              if (Yt) {
                const Lt = e.getMirroredCharacter(_[nt.charIndex]);
                Lt && H.forEachGlyph(Lt, 0, 0, Xt);
              }
              if (O) {
                const { charIndex: Lt } = nt, gn = nt.x + Se, Bn = nt.x + nt.width + Se;
                Z[Lt * 3] = Yt ? Bn : gn, Z[Lt * 3 + 1] = Yt ? gn : Bn, Z[Lt * 3 + 2] = Me + de + De;
                const mn = Lt - Le;
                mn > 1 && A(Z, Le, mn), Le = Lt;
              }
              if (q) {
                const { charIndex: Lt } = nt;
                for (; Lt > Fe; )
                  Fe++, q.hasOwnProperty(Fe) && (Ue = q[Fe]);
              }
              if (!Ke.isWhitespace && !Ke.isEmpty) {
                const Lt = pe++;
                ee[kt] || (ee[kt] = {
                  path: Ke.path,
                  pathBounds: [Ke.xMin, Ke.yMin, Ke.xMax, Ke.yMax]
                });
                const gn = nt.x + Se, Bn = Me + De;
                ce[Lt * 2] = gn, ce[Lt * 2 + 1] = Bn;
                const mn = gn + Ke.xMin * oe, Zt = Bn + Ke.yMin * oe, Sn = gn + Ke.xMax * oe, Ei = Bn + Ke.yMax * oe;
                mn < he[0] && (he[0] = mn), Zt < he[1] && (he[1] = Zt), Sn > he[2] && (he[2] = Sn), Ei > he[3] && (he[3] = Ei), Lt % V === 0 && (Ge = { start: Lt, end: Lt, rect: [r, r, -r, -r] }, _e.push(Ge)), Ge.end++;
                const ci = Ge.rect;
                if (mn < ci[0] && (ci[0] = mn), Zt < ci[1] && (ci[1] = Zt), Sn > ci[2] && (ci[2] = Sn), Ei > ci[3] && (ci[3] = Ei), $[Lt] = kt, q) {
                  const Ki = Lt * 3;
                  le[Ki] = Ue >> 16 & 255, le[Ki + 1] = Ue >> 8 & 255, le[Ki + 2] = Ue & 255;
                }
              }
            }
          }
          Me -= S;
        }), Z) {
          const we = _.length - Le;
          we > 1 && A(Z, Le, we);
        }
      }
      N.typesetting = m() - fe, z({
        glyphIds: $,
        //font indices for each glyph
        glyphPositions: ce,
        //x,y of each glyph's origin in layout
        glyphData: ee,
        //dict holding data about each glyph appearing in the text
        caretPositions: Z,
        //startX,endX,bottomY caret positions for each char
        caretHeight: W,
        //height of cursor from bottom to top
        glyphColors: le,
        //color for each glyph, if color ranges supplied
        chunkedBounds: _e,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: v,
        //calculated em height
        unitsPerEm: Ie,
        //font units per em
        ascender: re * oe,
        //font ascender
        descender: te * oe,
        //font descender
        capHeight: K * oe,
        //font cap-height
        xHeight: ve * oe,
        //font x-height
        lineHeight: S,
        //computed line height
        topBaseline: B,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          Se,
          De - Ce.length * S,
          Se + U,
          De
        ],
        visibleBounds: he,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: N
      });
    });
  }
  function f(_, b) {
    h(_, (y) => {
      const [v, x, S, I] = y.blockBounds;
      b({
        width: S - v,
        height: I - x
      });
    }, { metricsOnly: !0 });
  }
  function d(_) {
    let b = _.match(/^([\d.]+)%$/), y = b ? parseFloat(b[1]) : NaN;
    return isNaN(y) ? 0 : y / 100;
  }
  function A(_, b, y) {
    const v = _[b * 3], x = _[b * 3 + 1], S = _[b * 3 + 2], I = (x - v) / y;
    for (let E = 0; E < y; E++) {
      const M = (b + E) * 3;
      _[M] = v + I * E, _[M + 1] = v + I * (E + 1), _[M + 2] = S;
    }
  }
  function m() {
    return (self.performance || Date).now();
  }
  function p() {
    this.data = [];
  }
  const g = ["glyphObj", "x", "width", "charIndex"];
  return p.prototype = {
    width: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / g.length);
    },
    glyphAt(_) {
      let b = p.flyweight;
      return b.data = this.data, b.index = _, b;
    },
    splitAt(_) {
      let b = new p();
      return b.data = this.data.splice(_ * g.length), b;
    }
  }, p.flyweight = g.reduce((_, b, y, v) => (Object.defineProperty(_, b, {
    get() {
      return this.data[this.index * g.length + y];
    },
    set(x) {
      this.data[this.index * g.length + y] = x;
    }
  }), _), { data: null, index: 0 }), {
    typeset: h,
    measure: f,
    loadFont: u
  };
}
const Es = () => (self.performance || Date).now(), _u = /* @__PURE__ */ rb();
let Wg;
function WB(s, e, t, n, i, r, a, o, c, l, u = !0) {
  return u ? XB(s, e, t, n, i, r, a, o, c, l).then(
    null,
    (h) => (Wg || (console.warn("WebGL SDF generation failed, falling back to JS", h), Wg = !0), Xg(s, e, t, n, i, r, a, o, c, l))
  ) : Xg(s, e, t, n, i, r, a, o, c, l);
}
const ml = [], qB = 5;
let Of = 0;
function ab() {
  const s = Es();
  for (; ml.length && Es() - s < qB; )
    ml.shift()();
  Of = ml.length ? setTimeout(ab, 0) : 0;
}
const XB = (...s) => new Promise((e, t) => {
  ml.push(() => {
    const n = Es();
    try {
      _u.webgl.generateIntoCanvas(...s), e({ timing: Es() - n });
    } catch (i) {
      t(i);
    }
  }), Of || (Of = setTimeout(ab, 0));
}), YB = 4, jB = 2e3, qg = {};
let JB = 0;
function Xg(s, e, t, n, i, r, a, o, c, l) {
  const u = "TroikaTextSDFGenerator_JS_" + JB++ % YB;
  let h = qg[u];
  return h || (h = qg[u] = {
    workerModule: ec({
      name: u,
      workerId: u,
      dependencies: [
        rb,
        Es
      ],
      init(f, d) {
        const A = f().javascript.generate;
        return function(...m) {
          const p = d();
          return {
            textureData: A(...m),
            timing: d() - p
          };
        };
      },
      getTransferables(f) {
        return [f.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, t, n, i, r).then(({ textureData: f, timing: d }) => {
    const A = Es(), m = new Uint8Array(f.length * 4);
    for (let p = 0; p < f.length; p++)
      m[p * 4 + l] = f[p];
    return _u.webglUtils.renderImageData(a, m, o, c, s, e, 1 << 3 - l), d += Es() - A, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      PB(u);
    }, jB)), { timing: d };
  });
}
function KB(s) {
  s._warm || (_u.webgl.isSupported(s), s._warm = !0);
}
const ZB = _u.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function $B() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(i) {
      var r = e._bin, a = new Uint8Array(i);
      if (r.readASCII(a, 0, 4) == "ttcf") {
        var o = 4;
        r.readUshort(a, o), o += 2, r.readUshort(a, o), o += 2;
        var c = r.readUint(a, o);
        o += 4;
        for (var l = [], u = 0; u < c; u++) {
          var h = r.readUint(a, o);
          o += 4, l.push(e._readFont(a, h));
        }
        return l;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(i, r) {
      var a = e._bin, o = r;
      a.readFixed(i, r), r += 4;
      var c = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2;
      for (var l = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], u = { _data: i, _offset: o }, h = {}, f = 0; f < c; f++) {
        var d = a.readASCII(i, r, 4);
        r += 4, a.readUint(i, r), r += 4;
        var A = a.readUint(i, r);
        r += 4;
        var m = a.readUint(i, r);
        r += 4, h[d] = { offset: A, length: m };
      }
      for (f = 0; f < l.length; f++) {
        var p = l[f];
        h[p] && (u[p.trim()] = e[p.trim()].parse(i, h[p].offset, h[p].length, u));
      }
      return u;
    }, _tabOffset: function(i, r, a) {
      for (var o = e._bin, c = o.readUshort(i, a + 4), l = a + 12, u = 0; u < c; u++) {
        var h = o.readASCII(i, l, 4);
        l += 4, o.readUint(i, l), l += 4;
        var f = o.readUint(i, l);
        if (l += 4, o.readUint(i, l), l += 4, h == r)
          return f;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, r) {
      return (i[r] << 8 | i[r + 1]) + (i[r + 2] << 8 | i[r + 3]) / 65540;
    }, readF2dot14: function(i, r) {
      return e._bin.readShort(i, r) / 16384;
    }, readInt: function(i, r) {
      return e._bin._view(i).getInt32(r);
    }, readInt8: function(i, r) {
      return e._bin._view(i).getInt8(r);
    }, readShort: function(i, r) {
      return e._bin._view(i).getInt16(r);
    }, readUshort: function(i, r) {
      return e._bin._view(i).getUint16(r);
    }, readUshorts: function(i, r, a) {
      for (var o = [], c = 0; c < a; c++)
        o.push(e._bin.readUshort(i, r + 2 * c));
      return o;
    }, readUint: function(i, r) {
      return e._bin._view(i).getUint32(r);
    }, readUint64: function(i, r) {
      return 4294967296 * e._bin.readUint(i, r) + e._bin.readUint(i, r + 4);
    }, readASCII: function(i, r, a) {
      for (var o = "", c = 0; c < a; c++)
        o += String.fromCharCode(i[r + c]);
      return o;
    }, readUnicode: function(i, r, a) {
      for (var o = "", c = 0; c < a; c++) {
        var l = i[r++] << 8 | i[r++];
        o += String.fromCharCode(l);
      }
      return o;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, r, a) {
      var o = e._bin._tdec;
      return o && r == 0 && a == i.length ? o.decode(i) : e._bin.readASCII(i, r, a);
    }, readBytes: function(i, r, a) {
      for (var o = [], c = 0; c < a; c++)
        o.push(i[r + c]);
      return o;
    }, readASCIIArray: function(i, r, a) {
      for (var o = [], c = 0; c < a; c++)
        o.push(String.fromCharCode(i[r + c]));
      return o;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, r, a, o, c) {
      var l = e._bin, u = {}, h = r;
      l.readFixed(i, r), r += 4;
      var f = l.readUshort(i, r);
      r += 2;
      var d = l.readUshort(i, r);
      r += 2;
      var A = l.readUshort(i, r);
      return r += 2, u.scriptList = e._lctf.readScriptList(i, h + f), u.featureList = e._lctf.readFeatureList(i, h + d), u.lookupList = e._lctf.readLookupList(i, h + A, c), u;
    }, e._lctf.readLookupList = function(i, r, a) {
      var o = e._bin, c = r, l = [], u = o.readUshort(i, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var f = o.readUshort(i, r);
        r += 2;
        var d = e._lctf.readLookupTable(i, c + f, a);
        l.push(d);
      }
      return l;
    }, e._lctf.readLookupTable = function(i, r, a) {
      var o = e._bin, c = r, l = { tabs: [] };
      l.ltype = o.readUshort(i, r), r += 2, l.flag = o.readUshort(i, r), r += 2;
      var u = o.readUshort(i, r);
      r += 2;
      for (var h = l.ltype, f = 0; f < u; f++) {
        var d = o.readUshort(i, r);
        r += 2;
        var A = a(i, h, c + d, l);
        l.tabs.push(A);
      }
      return l;
    }, e._lctf.numOfOnes = function(i) {
      for (var r = 0, a = 0; a < 32; a++)
        i >>> a & 1 && r++;
      return r;
    }, e._lctf.readClassDef = function(i, r) {
      var a = e._bin, o = [], c = a.readUshort(i, r);
      if (r += 2, c == 1) {
        var l = a.readUshort(i, r);
        r += 2;
        var u = a.readUshort(i, r);
        r += 2;
        for (var h = 0; h < u; h++)
          o.push(l + h), o.push(l + h), o.push(a.readUshort(i, r)), r += 2;
      }
      if (c == 2) {
        var f = a.readUshort(i, r);
        for (r += 2, h = 0; h < f; h++)
          o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2, o.push(a.readUshort(i, r)), r += 2;
      }
      return o;
    }, e._lctf.getInterval = function(i, r) {
      for (var a = 0; a < i.length; a += 3) {
        var o = i[a], c = i[a + 1];
        if (i[a + 2], o <= r && r <= c)
          return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, r) {
      var a = e._bin, o = {};
      o.fmt = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      return r += 2, o.fmt == 1 && (o.tab = a.readUshorts(i, r, c)), o.fmt == 2 && (o.tab = a.readUshorts(i, r, 3 * c)), o;
    }, e._lctf.coverageIndex = function(i, r) {
      var a = i.tab;
      if (i.fmt == 1)
        return a.indexOf(r);
      if (i.fmt == 2) {
        var o = e._lctf.getInterval(a, r);
        if (o != -1)
          return a[o + 2] + (r - a[o]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, r) {
      var a = e._bin, o = r, c = [], l = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < l; u++) {
        var h = a.readASCII(i, r, 4);
        r += 4;
        var f = a.readUshort(i, r);
        r += 2;
        var d = e._lctf.readFeatureTable(i, o + f);
        d.tag = h.trim(), c.push(d);
      }
      return c;
    }, e._lctf.readFeatureTable = function(i, r) {
      var a = e._bin, o = r, c = {}, l = a.readUshort(i, r);
      r += 2, l > 0 && (c.featureParams = o + l);
      var u = a.readUshort(i, r);
      r += 2, c.tab = [];
      for (var h = 0; h < u; h++)
        c.tab.push(a.readUshort(i, r + 2 * h));
      return c;
    }, e._lctf.readScriptList = function(i, r) {
      var a = e._bin, o = r, c = {}, l = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < l; u++) {
        var h = a.readASCII(i, r, 4);
        r += 4;
        var f = a.readUshort(i, r);
        r += 2, c[h.trim()] = e._lctf.readScriptTable(i, o + f);
      }
      return c;
    }, e._lctf.readScriptTable = function(i, r) {
      var a = e._bin, o = r, c = {}, l = a.readUshort(i, r);
      r += 2, c.default = e._lctf.readLangSysTable(i, o + l);
      var u = a.readUshort(i, r);
      r += 2;
      for (var h = 0; h < u; h++) {
        var f = a.readASCII(i, r, 4);
        r += 4;
        var d = a.readUshort(i, r);
        r += 2, c[f.trim()] = e._lctf.readLangSysTable(i, o + d);
      }
      return c;
    }, e._lctf.readLangSysTable = function(i, r) {
      var a = e._bin, o = {};
      a.readUshort(i, r), r += 2, o.reqFeature = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      return r += 2, o.features = a.readUshorts(i, r, c), o;
    }, e.CFF = {}, e.CFF.parse = function(i, r, a) {
      var o = e._bin;
      (i = new Uint8Array(i.buffer, r, a))[r = 0], i[++r], i[++r], i[++r], r++;
      var c = [];
      r = e.CFF.readIndex(i, r, c);
      for (var l = [], u = 0; u < c.length - 1; u++)
        l.push(o.readASCII(i, r + c[u], c[u + 1] - c[u]));
      r += c[c.length - 1];
      var h = [];
      r = e.CFF.readIndex(i, r, h);
      var f = [];
      for (u = 0; u < h.length - 1; u++)
        f.push(e.CFF.readDict(i, r + h[u], r + h[u + 1]));
      r += h[h.length - 1];
      var d = f[0], A = [];
      r = e.CFF.readIndex(i, r, A);
      var m = [];
      for (u = 0; u < A.length - 1; u++)
        m.push(o.readASCII(i, r + A[u], A[u + 1] - A[u]));
      if (r += A[A.length - 1], e.CFF.readSubrs(i, r, d), d.CharStrings) {
        r = d.CharStrings, A = [], r = e.CFF.readIndex(i, r, A);
        var p = [];
        for (u = 0; u < A.length - 1; u++)
          p.push(o.readBytes(i, r + A[u], A[u + 1] - A[u]));
        d.CharStrings = p;
      }
      if (d.ROS) {
        r = d.FDArray;
        var g = [];
        for (r = e.CFF.readIndex(i, r, g), d.FDArray = [], u = 0; u < g.length - 1; u++) {
          var _ = e.CFF.readDict(i, r + g[u], r + g[u + 1]);
          e.CFF._readFDict(i, _, m), d.FDArray.push(_);
        }
        r += g[g.length - 1], r = d.FDSelect, d.FDSelect = [];
        var b = i[r];
        if (r++, b != 3)
          throw b;
        var y = o.readUshort(i, r);
        for (r += 2, u = 0; u < y + 1; u++)
          d.FDSelect.push(o.readUshort(i, r), i[r + 2]), r += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(i, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(i, d.charset, d.CharStrings.length)), e.CFF._readFDict(i, d, m), d;
    }, e.CFF._readFDict = function(i, r, a) {
      var o;
      for (var c in r.Private && (o = r.Private[1], r.Private = e.CFF.readDict(i, o, o + r.Private[0]), r.Private.Subrs && e.CFF.readSubrs(i, o + r.Private.Subrs, r.Private)), r)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (r[c] = a[r[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, r, a) {
      var o = e._bin, c = [];
      r = e.CFF.readIndex(i, r, c);
      var l, u = c.length;
      l = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, a.Bias = l, a.Subrs = [];
      for (var h = 0; h < c.length - 1; h++)
        a.Subrs.push(o.readBytes(i, r + c[h], c[h + 1] - c[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, r) {
      for (var a = 0; a < i.charset.length; a++)
        if (i.charset[a] == r)
          return a;
      return -1;
    }, e.CFF.glyphBySE = function(i, r) {
      return r < 0 || r > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[r]);
    }, e.CFF.readEncoding = function(i, r, a) {
      e._bin;
      var o = [".notdef"], c = i[r];
      if (r++, c != 0)
        throw "error: unknown encoding format: " + c;
      var l = i[r];
      r++;
      for (var u = 0; u < l; u++)
        o.push(i[r + u]);
      return o;
    }, e.CFF.readCharset = function(i, r, a) {
      var o = e._bin, c = [".notdef"], l = i[r];
      if (r++, l == 0)
        for (var u = 0; u < a; u++) {
          var h = o.readUshort(i, r);
          r += 2, c.push(h);
        }
      else {
        if (l != 1 && l != 2)
          throw "error: format: " + l;
        for (; c.length < a; ) {
          h = o.readUshort(i, r), r += 2;
          var f = 0;
          for (l == 1 ? (f = i[r], r++) : (f = o.readUshort(i, r), r += 2), u = 0; u <= f; u++)
            c.push(h), h++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(i, r, a) {
      var o = e._bin, c = o.readUshort(i, r) + 1, l = i[r += 2];
      if (r++, l == 1)
        for (var u = 0; u < c; u++)
          a.push(i[r + u]);
      else if (l == 2)
        for (u = 0; u < c; u++)
          a.push(o.readUshort(i, r + 2 * u));
      else if (l == 3)
        for (u = 0; u < c; u++)
          a.push(16777215 & o.readUint(i, r + 3 * u - 1));
      else if (c != 1)
        throw "unsupported offset size: " + l + ", count: " + c;
      return (r += c * l) - 1;
    }, e.CFF.getCharString = function(i, r, a) {
      var o = e._bin, c = i[r], l = i[r + 1];
      i[r + 2], i[r + 3], i[r + 4];
      var u = 1, h = null, f = null;
      c <= 20 && (h = c, u = 1), c == 12 && (h = 100 * c + l, u = 2), 21 <= c && c <= 27 && (h = c, u = 1), c == 28 && (f = o.readShort(i, r + 1), u = 3), 29 <= c && c <= 31 && (h = c, u = 1), 32 <= c && c <= 246 && (f = c - 139, u = 1), 247 <= c && c <= 250 && (f = 256 * (c - 247) + l + 108, u = 2), 251 <= c && c <= 254 && (f = 256 * -(c - 251) - l - 108, u = 2), c == 255 && (f = o.readInt(i, r + 1) / 65535, u = 5), a.val = f ?? "o" + h, a.size = u;
    }, e.CFF.readCharString = function(i, r, a) {
      for (var o = r + a, c = e._bin, l = []; r < o; ) {
        var u = i[r], h = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var f = 1, d = null, A = null;
        u <= 20 && (d = u, f = 1), u == 12 && (d = 100 * u + h, f = 2), u != 19 && u != 20 || (d = u, f = 2), 21 <= u && u <= 27 && (d = u, f = 1), u == 28 && (A = c.readShort(i, r + 1), f = 3), 29 <= u && u <= 31 && (d = u, f = 1), 32 <= u && u <= 246 && (A = u - 139, f = 1), 247 <= u && u <= 250 && (A = 256 * (u - 247) + h + 108, f = 2), 251 <= u && u <= 254 && (A = 256 * -(u - 251) - h - 108, f = 2), u == 255 && (A = c.readInt(i, r + 1) / 65535, f = 5), l.push(A ?? "o" + d), r += f;
      }
      return l;
    }, e.CFF.readDict = function(i, r, a) {
      for (var o = e._bin, c = {}, l = []; r < a; ) {
        var u = i[r], h = i[r + 1];
        i[r + 2], i[r + 3], i[r + 4];
        var f = 1, d = null, A = null;
        if (u == 28 && (A = o.readShort(i, r + 1), f = 3), u == 29 && (A = o.readInt(i, r + 1), f = 5), 32 <= u && u <= 246 && (A = u - 139, f = 1), 247 <= u && u <= 250 && (A = 256 * (u - 247) + h + 108, f = 2), 251 <= u && u <= 254 && (A = 256 * -(u - 251) - h - 108, f = 2), u == 255)
          throw A = o.readInt(i, r + 1) / 65535, f = 5, "unknown number";
        if (u == 30) {
          var m = [];
          for (f = 1; ; ) {
            var p = i[r + f];
            f++;
            var g = p >> 4, _ = 15 & p;
            if (g != 15 && m.push(g), _ != 15 && m.push(_), _ == 15)
              break;
          }
          for (var b = "", y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], v = 0; v < m.length; v++)
            b += y[m[v]];
          A = parseFloat(b);
        }
        u <= 21 && (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], f = 1, u == 12 && (d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f = 2)), d != null ? (c[d] = l.length == 1 ? l[0] : l, l = []) : l.push(A), r += f;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(i, r, a) {
      i = new Uint8Array(i.buffer, r, a), r = 0;
      var o = e._bin, c = {};
      o.readUshort(i, r), r += 2;
      var l = o.readUshort(i, r);
      r += 2;
      var u = [];
      c.tables = [];
      for (var h = 0; h < l; h++) {
        var f = o.readUshort(i, r);
        r += 2;
        var d = o.readUshort(i, r);
        r += 2;
        var A = o.readUint(i, r);
        r += 4;
        var m = "p" + f + "e" + d, p = u.indexOf(A);
        if (p == -1) {
          var g;
          p = c.tables.length, u.push(A);
          var _ = o.readUshort(i, A);
          _ == 0 ? g = e.cmap.parse0(i, A) : _ == 4 ? g = e.cmap.parse4(i, A) : _ == 6 ? g = e.cmap.parse6(i, A) : _ == 12 ? g = e.cmap.parse12(i, A) : console.debug("unknown format: " + _, f, d, A), c.tables.push(g);
        }
        if (c[m] != null)
          throw "multiple tables for one platform+encoding";
        c[m] = p;
      }
      return c;
    }, e.cmap.parse0 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2, o.map = [];
      for (var l = 0; l < c - 6; l++)
        o.map.push(i[r + l]);
      return o;
    }, e.cmap.parse4 = function(i, r) {
      var a = e._bin, o = r, c = {};
      c.format = a.readUshort(i, r), r += 2;
      var l = a.readUshort(i, r);
      r += 2, a.readUshort(i, r), r += 2;
      var u = a.readUshort(i, r);
      r += 2;
      var h = u / 2;
      c.searchRange = a.readUshort(i, r), r += 2, c.entrySelector = a.readUshort(i, r), r += 2, c.rangeShift = a.readUshort(i, r), r += 2, c.endCount = a.readUshorts(i, r, h), r += 2 * h, r += 2, c.startCount = a.readUshorts(i, r, h), r += 2 * h, c.idDelta = [];
      for (var f = 0; f < h; f++)
        c.idDelta.push(a.readShort(i, r)), r += 2;
      for (c.idRangeOffset = a.readUshorts(i, r, h), r += 2 * h, c.glyphIdArray = []; r < o + l; )
        c.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return c;
    }, e.cmap.parse6 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, a.readUshort(i, r), r += 2, o.firstCode = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      r += 2, o.glyphIdArray = [];
      for (var l = 0; l < c; l++)
        o.glyphIdArray.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.cmap.parse12 = function(i, r) {
      var a = e._bin, o = {};
      o.format = a.readUshort(i, r), r += 2, r += 2, a.readUint(i, r), r += 4, a.readUint(i, r), r += 4;
      var c = a.readUint(i, r);
      r += 4, o.groups = [];
      for (var l = 0; l < c; l++) {
        var u = r + 12 * l, h = a.readUint(i, u + 0), f = a.readUint(i, u + 4), d = a.readUint(i, u + 8);
        o.groups.push([h, f, d]);
      }
      return o;
    }, e.glyf = {}, e.glyf.parse = function(i, r, a, o) {
      for (var c = [], l = 0; l < o.maxp.numGlyphs; l++)
        c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(i, r) {
      var a = e._bin, o = i._data, c = e._tabOffset(o, "glyf", i._offset) + i.loca[r];
      if (i.loca[r] == i.loca[r + 1])
        return null;
      var l = {};
      if (l.noc = a.readShort(o, c), c += 2, l.xMin = a.readShort(o, c), c += 2, l.yMin = a.readShort(o, c), c += 2, l.xMax = a.readShort(o, c), c += 2, l.yMax = a.readShort(o, c), c += 2, l.xMin >= l.xMax || l.yMin >= l.yMax)
        return null;
      if (l.noc > 0) {
        l.endPts = [];
        for (var u = 0; u < l.noc; u++)
          l.endPts.push(a.readUshort(o, c)), c += 2;
        var h = a.readUshort(o, c);
        if (c += 2, o.length - c < h)
          return null;
        l.instructions = a.readBytes(o, c, h), c += h;
        var f = l.endPts[l.noc - 1] + 1;
        for (l.flags = [], u = 0; u < f; u++) {
          var d = o[c];
          if (c++, l.flags.push(d), (8 & d) != 0) {
            var A = o[c];
            c++;
            for (var m = 0; m < A; m++)
              l.flags.push(d), u++;
          }
        }
        for (l.xs = [], u = 0; u < f; u++) {
          var p = (2 & l.flags[u]) != 0, g = (16 & l.flags[u]) != 0;
          p ? (l.xs.push(g ? o[c] : -o[c]), c++) : g ? l.xs.push(0) : (l.xs.push(a.readShort(o, c)), c += 2);
        }
        for (l.ys = [], u = 0; u < f; u++)
          p = (4 & l.flags[u]) != 0, g = (32 & l.flags[u]) != 0, p ? (l.ys.push(g ? o[c] : -o[c]), c++) : g ? l.ys.push(0) : (l.ys.push(a.readShort(o, c)), c += 2);
        var _ = 0, b = 0;
        for (u = 0; u < f; u++)
          _ += l.xs[u], b += l.ys[u], l.xs[u] = _, l.ys[u] = b;
      } else {
        var y;
        l.parts = [];
        do {
          y = a.readUshort(o, c), c += 2;
          var v = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (l.parts.push(v), v.glyphIndex = a.readUshort(o, c), c += 2, 1 & y) {
            var x = a.readShort(o, c);
            c += 2;
            var S = a.readShort(o, c);
            c += 2;
          } else
            x = a.readInt8(o, c), c++, S = a.readInt8(o, c), c++;
          2 & y ? (v.m.tx = x, v.m.ty = S) : (v.p1 = x, v.p2 = S), 8 & y ? (v.m.a = v.m.d = a.readF2dot14(o, c), c += 2) : 64 & y ? (v.m.a = a.readF2dot14(o, c), c += 2, v.m.d = a.readF2dot14(o, c), c += 2) : 128 & y && (v.m.a = a.readF2dot14(o, c), c += 2, v.m.b = a.readF2dot14(o, c), c += 2, v.m.c = a.readF2dot14(o, c), c += 2, v.m.d = a.readF2dot14(o, c), c += 2);
        } while (32 & y);
        if (256 & y) {
          var I = a.readUshort(o, c);
          for (c += 2, l.instr = [], u = 0; u < I; u++)
            l.instr.push(o[c]), c++;
        }
      }
      return l;
    }, e.GPOS = {}, e.GPOS.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GPOS.subt);
    }, e.GPOS.subt = function(i, r, a, o) {
      var c = e._bin, l = a, u = {};
      if (u.fmt = c.readUshort(i, a), a += 2, r == 1 || r == 2 || r == 3 || r == 7 || r == 8 && u.fmt <= 2) {
        var h = c.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, h + l);
      }
      if (r == 1 && u.fmt == 1) {
        var f = c.readUshort(i, a);
        a += 2;
        var d = e._lctf.numOfOnes(f);
        f != 0 && (u.pos = e.GPOS.readValueRecord(i, a, f));
      } else if (r == 2 && u.fmt >= 1 && u.fmt <= 2) {
        f = c.readUshort(i, a), a += 2;
        var A = c.readUshort(i, a);
        a += 2, d = e._lctf.numOfOnes(f);
        var m = e._lctf.numOfOnes(A);
        if (u.fmt == 1) {
          u.pairsets = [];
          var p = c.readUshort(i, a);
          a += 2;
          for (var g = 0; g < p; g++) {
            var _ = l + c.readUshort(i, a);
            a += 2;
            var b = c.readUshort(i, _);
            _ += 2;
            for (var y = [], v = 0; v < b; v++) {
              var x = c.readUshort(i, _);
              _ += 2, f != 0 && (D = e.GPOS.readValueRecord(i, _, f), _ += 2 * d), A != 0 && (F = e.GPOS.readValueRecord(i, _, A), _ += 2 * m), y.push({ gid2: x, val1: D, val2: F });
            }
            u.pairsets.push(y);
          }
        }
        if (u.fmt == 2) {
          var S = c.readUshort(i, a);
          a += 2;
          var I = c.readUshort(i, a);
          a += 2;
          var E = c.readUshort(i, a);
          a += 2;
          var M = c.readUshort(i, a);
          for (a += 2, u.classDef1 = e._lctf.readClassDef(i, l + S), u.classDef2 = e._lctf.readClassDef(i, l + I), u.matrix = [], g = 0; g < E; g++) {
            var T = [];
            for (v = 0; v < M; v++) {
              var D = null, F = null;
              f != 0 && (D = e.GPOS.readValueRecord(i, a, f), a += 2 * d), A != 0 && (F = e.GPOS.readValueRecord(i, a, A), a += 2 * m), T.push({ val1: D, val2: F });
            }
            u.matrix.push(T);
          }
        }
      } else {
        if (r == 9 && u.fmt == 1) {
          var C = c.readUshort(i, a);
          a += 2;
          var R = c.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = C;
          else if (o.ltype != C)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, o.ltype, l + R);
        }
        console.debug("unsupported GPOS table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GPOS.readValueRecord = function(i, r, a) {
      var o = e._bin, c = [];
      return c.push(1 & a ? o.readShort(i, r) : 0), r += 1 & a ? 2 : 0, c.push(2 & a ? o.readShort(i, r) : 0), r += 2 & a ? 2 : 0, c.push(4 & a ? o.readShort(i, r) : 0), r += 4 & a ? 2 : 0, c.push(8 & a ? o.readShort(i, r) : 0), r += 8 & a ? 2 : 0, c;
    }, e.GSUB = {}, e.GSUB.parse = function(i, r, a, o) {
      return e._lctf.parse(i, r, a, o, e.GSUB.subt);
    }, e.GSUB.subt = function(i, r, a, o) {
      var c = e._bin, l = a, u = {};
      if (u.fmt = c.readUshort(i, a), a += 2, r != 1 && r != 4 && r != 5 && r != 6)
        return null;
      if (r == 1 || r == 4 || r == 5 && u.fmt <= 2 || r == 6 && u.fmt <= 2) {
        var h = c.readUshort(i, a);
        a += 2, u.coverage = e._lctf.readCoverage(i, l + h);
      }
      if (r == 1 && u.fmt >= 1 && u.fmt <= 2) {
        if (u.fmt == 1)
          u.delta = c.readShort(i, a), a += 2;
        else if (u.fmt == 2) {
          var f = c.readUshort(i, a);
          a += 2, u.newg = c.readUshorts(i, a, f), a += 2 * u.newg.length;
        }
      } else if (r == 4) {
        u.vals = [], f = c.readUshort(i, a), a += 2;
        for (var d = 0; d < f; d++) {
          var A = c.readUshort(i, a);
          a += 2, u.vals.push(e.GSUB.readLigatureSet(i, l + A));
        }
      } else if (r == 5 && u.fmt == 2) {
        if (u.fmt == 2) {
          var m = c.readUshort(i, a);
          a += 2, u.cDef = e._lctf.readClassDef(i, l + m), u.scset = [];
          var p = c.readUshort(i, a);
          for (a += 2, d = 0; d < p; d++) {
            var g = c.readUshort(i, a);
            a += 2, u.scset.push(g == 0 ? null : e.GSUB.readSubClassSet(i, l + g));
          }
        }
      } else if (r == 6 && u.fmt == 3) {
        if (u.fmt == 3) {
          for (d = 0; d < 3; d++) {
            f = c.readUshort(i, a), a += 2;
            for (var _ = [], b = 0; b < f; b++)
              _.push(e._lctf.readCoverage(i, l + c.readUshort(i, a + 2 * b)));
            a += 2 * f, d == 0 && (u.backCvg = _), d == 1 && (u.inptCvg = _), d == 2 && (u.ahedCvg = _);
          }
          f = c.readUshort(i, a), a += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(i, a, f);
        }
      } else {
        if (r == 7 && u.fmt == 1) {
          var y = c.readUshort(i, a);
          a += 2;
          var v = c.readUint(i, a);
          if (a += 4, o.ltype == 9)
            o.ltype = y;
          else if (o.ltype != y)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, o.ltype, l + v);
        }
        console.debug("unsupported GSUB table LookupType", r, "format", u.fmt);
      }
      return u;
    }, e.GSUB.readSubClassSet = function(i, r) {
      var a = e._bin.readUshort, o = r, c = [], l = a(i, r);
      r += 2;
      for (var u = 0; u < l; u++) {
        var h = a(i, r);
        r += 2, c.push(e.GSUB.readSubClassRule(i, o + h));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(i, r) {
      var a = e._bin.readUshort, o = {}, c = a(i, r), l = a(i, r += 2);
      r += 2, o.input = [];
      for (var u = 0; u < c - 1; u++)
        o.input.push(a(i, r)), r += 2;
      return o.substLookupRecords = e.GSUB.readSubstLookupRecords(i, r, l), o;
    }, e.GSUB.readSubstLookupRecords = function(i, r, a) {
      for (var o = e._bin.readUshort, c = [], l = 0; l < a; l++)
        c.push(o(i, r), o(i, r + 2)), r += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(i, r) {
      var a = e._bin, o = r, c = [], l = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < l; u++) {
        var h = a.readUshort(i, r);
        r += 2, c.push(e.GSUB.readChainSubClassRule(i, o + h));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(i, r) {
      for (var a = e._bin, o = {}, c = ["backtrack", "input", "lookahead"], l = 0; l < c.length; l++) {
        var u = a.readUshort(i, r);
        r += 2, l == 1 && u--, o[c[l]] = a.readUshorts(i, r, u), r += 2 * o[c[l]].length;
      }
      return u = a.readUshort(i, r), r += 2, o.subst = a.readUshorts(i, r, 2 * u), r += 2 * o.subst.length, o;
    }, e.GSUB.readLigatureSet = function(i, r) {
      var a = e._bin, o = r, c = [], l = a.readUshort(i, r);
      r += 2;
      for (var u = 0; u < l; u++) {
        var h = a.readUshort(i, r);
        r += 2, c.push(e.GSUB.readLigature(i, o + h));
      }
      return c;
    }, e.GSUB.readLigature = function(i, r) {
      var a = e._bin, o = { chain: [] };
      o.nglyph = a.readUshort(i, r), r += 2;
      var c = a.readUshort(i, r);
      r += 2;
      for (var l = 0; l < c - 1; l++)
        o.chain.push(a.readUshort(i, r)), r += 2;
      return o;
    }, e.head = {}, e.head.parse = function(i, r, a) {
      var o = e._bin, c = {};
      return o.readFixed(i, r), r += 4, c.fontRevision = o.readFixed(i, r), r += 4, o.readUint(i, r), r += 4, o.readUint(i, r), r += 4, c.flags = o.readUshort(i, r), r += 2, c.unitsPerEm = o.readUshort(i, r), r += 2, c.created = o.readUint64(i, r), r += 8, c.modified = o.readUint64(i, r), r += 8, c.xMin = o.readShort(i, r), r += 2, c.yMin = o.readShort(i, r), r += 2, c.xMax = o.readShort(i, r), r += 2, c.yMax = o.readShort(i, r), r += 2, c.macStyle = o.readUshort(i, r), r += 2, c.lowestRecPPEM = o.readUshort(i, r), r += 2, c.fontDirectionHint = o.readShort(i, r), r += 2, c.indexToLocFormat = o.readShort(i, r), r += 2, c.glyphDataFormat = o.readShort(i, r), r += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(i, r, a) {
      var o = e._bin, c = {};
      return o.readFixed(i, r), r += 4, c.ascender = o.readShort(i, r), r += 2, c.descender = o.readShort(i, r), r += 2, c.lineGap = o.readShort(i, r), r += 2, c.advanceWidthMax = o.readUshort(i, r), r += 2, c.minLeftSideBearing = o.readShort(i, r), r += 2, c.minRightSideBearing = o.readShort(i, r), r += 2, c.xMaxExtent = o.readShort(i, r), r += 2, c.caretSlopeRise = o.readShort(i, r), r += 2, c.caretSlopeRun = o.readShort(i, r), r += 2, c.caretOffset = o.readShort(i, r), r += 2, r += 8, c.metricDataFormat = o.readShort(i, r), r += 2, c.numberOfHMetrics = o.readUshort(i, r), r += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(i, r, a, o) {
      for (var c = e._bin, l = { aWidth: [], lsBearing: [] }, u = 0, h = 0, f = 0; f < o.maxp.numGlyphs; f++)
        f < o.hhea.numberOfHMetrics && (u = c.readUshort(i, r), r += 2, h = c.readShort(i, r), r += 2), l.aWidth.push(u), l.lsBearing.push(h);
      return l;
    }, e.kern = {}, e.kern.parse = function(i, r, a, o) {
      var c = e._bin, l = c.readUshort(i, r);
      if (r += 2, l == 1)
        return e.kern.parseV1(i, r - 2, a, o);
      var u = c.readUshort(i, r);
      r += 2;
      for (var h = { glyph1: [], rval: [] }, f = 0; f < u; f++) {
        r += 2, a = c.readUshort(i, r), r += 2;
        var d = c.readUshort(i, r);
        r += 2;
        var A = d >>> 8;
        if ((A &= 15) != 0)
          throw "unknown kern table format: " + A;
        r = e.kern.readFormat0(i, r, h);
      }
      return h;
    }, e.kern.parseV1 = function(i, r, a, o) {
      var c = e._bin;
      c.readFixed(i, r), r += 4;
      var l = c.readUint(i, r);
      r += 4;
      for (var u = { glyph1: [], rval: [] }, h = 0; h < l; h++) {
        c.readUint(i, r), r += 4;
        var f = c.readUshort(i, r);
        r += 2, c.readUshort(i, r), r += 2;
        var d = f >>> 8;
        if ((d &= 15) != 0)
          throw "unknown kern table format: " + d;
        r = e.kern.readFormat0(i, r, u);
      }
      return u;
    }, e.kern.readFormat0 = function(i, r, a) {
      var o = e._bin, c = -1, l = o.readUshort(i, r);
      r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2, o.readUshort(i, r), r += 2;
      for (var u = 0; u < l; u++) {
        var h = o.readUshort(i, r);
        r += 2;
        var f = o.readUshort(i, r);
        r += 2;
        var d = o.readShort(i, r);
        r += 2, h != c && (a.glyph1.push(h), a.rval.push({ glyph2: [], vals: [] }));
        var A = a.rval[a.rval.length - 1];
        A.glyph2.push(f), A.vals.push(d), c = h;
      }
      return r;
    }, e.loca = {}, e.loca.parse = function(i, r, a, o) {
      var c = e._bin, l = [], u = o.head.indexToLocFormat, h = o.maxp.numGlyphs + 1;
      if (u == 0)
        for (var f = 0; f < h; f++)
          l.push(c.readUshort(i, r + (f << 1)) << 1);
      if (u == 1)
        for (f = 0; f < h; f++)
          l.push(c.readUint(i, r + (f << 2)));
      return l;
    }, e.maxp = {}, e.maxp.parse = function(i, r, a) {
      var o = e._bin, c = {}, l = o.readUint(i, r);
      return r += 4, c.numGlyphs = o.readUshort(i, r), r += 2, l == 65536 && (c.maxPoints = o.readUshort(i, r), r += 2, c.maxContours = o.readUshort(i, r), r += 2, c.maxCompositePoints = o.readUshort(i, r), r += 2, c.maxCompositeContours = o.readUshort(i, r), r += 2, c.maxZones = o.readUshort(i, r), r += 2, c.maxTwilightPoints = o.readUshort(i, r), r += 2, c.maxStorage = o.readUshort(i, r), r += 2, c.maxFunctionDefs = o.readUshort(i, r), r += 2, c.maxInstructionDefs = o.readUshort(i, r), r += 2, c.maxStackElements = o.readUshort(i, r), r += 2, c.maxSizeOfInstructions = o.readUshort(i, r), r += 2, c.maxComponentElements = o.readUshort(i, r), r += 2, c.maxComponentDepth = o.readUshort(i, r), r += 2), c;
    }, e.name = {}, e.name.parse = function(i, r, a) {
      var o = e._bin, c = {};
      o.readUshort(i, r), r += 2;
      var l = o.readUshort(i, r);
      r += 2, o.readUshort(i, r);
      for (var u, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f = r += 2, d = 0; d < l; d++) {
        var A = o.readUshort(i, r);
        r += 2;
        var m = o.readUshort(i, r);
        r += 2;
        var p = o.readUshort(i, r);
        r += 2;
        var g = o.readUshort(i, r);
        r += 2;
        var _ = o.readUshort(i, r);
        r += 2;
        var b = o.readUshort(i, r);
        r += 2;
        var y, v = h[g], x = f + 12 * l + b;
        if (A == 0)
          y = o.readUnicode(i, x, _ / 2);
        else if (A == 3 && m == 0)
          y = o.readUnicode(i, x, _ / 2);
        else if (m == 0)
          y = o.readASCII(i, x, _);
        else if (m == 1)
          y = o.readUnicode(i, x, _ / 2);
        else if (m == 3)
          y = o.readUnicode(i, x, _ / 2);
        else {
          if (A != 1)
            throw "unknown encoding " + m + ", platformID: " + A;
          y = o.readASCII(i, x, _), console.debug("reading unknown MAC encoding " + m + " as ASCII");
        }
        var S = "p" + A + "," + p.toString(16);
        c[S] == null && (c[S] = {}), c[S][v !== void 0 ? v : g] = y, c[S]._lang = p;
      }
      for (var I in c)
        if (c[I].postScriptName != null && c[I]._lang == 1033)
          return c[I];
      for (var I in c)
        if (c[I].postScriptName != null && c[I]._lang == 0)
          return c[I];
      for (var I in c)
        if (c[I].postScriptName != null && c[I]._lang == 3084)
          return c[I];
      for (var I in c)
        if (c[I].postScriptName != null)
          return c[I];
      for (var I in c) {
        u = I;
        break;
      }
      return console.debug("returning name table with languageID " + c[u]._lang), c[u];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, r, a) {
      var o = e._bin.readUshort(i, r);
      r += 2;
      var c = {};
      if (o == 0)
        e["OS/2"].version0(i, r, c);
      else if (o == 1)
        e["OS/2"].version1(i, r, c);
      else if (o == 2 || o == 3 || o == 4)
        e["OS/2"].version2(i, r, c);
      else {
        if (o != 5)
          throw "unknown OS/2 table version: " + o;
        e["OS/2"].version5(i, r, c);
      }
      return c;
    }, e["OS/2"].version0 = function(i, r, a) {
      var o = e._bin;
      return a.xAvgCharWidth = o.readShort(i, r), r += 2, a.usWeightClass = o.readUshort(i, r), r += 2, a.usWidthClass = o.readUshort(i, r), r += 2, a.fsType = o.readUshort(i, r), r += 2, a.ySubscriptXSize = o.readShort(i, r), r += 2, a.ySubscriptYSize = o.readShort(i, r), r += 2, a.ySubscriptXOffset = o.readShort(i, r), r += 2, a.ySubscriptYOffset = o.readShort(i, r), r += 2, a.ySuperscriptXSize = o.readShort(i, r), r += 2, a.ySuperscriptYSize = o.readShort(i, r), r += 2, a.ySuperscriptXOffset = o.readShort(i, r), r += 2, a.ySuperscriptYOffset = o.readShort(i, r), r += 2, a.yStrikeoutSize = o.readShort(i, r), r += 2, a.yStrikeoutPosition = o.readShort(i, r), r += 2, a.sFamilyClass = o.readShort(i, r), r += 2, a.panose = o.readBytes(i, r, 10), r += 10, a.ulUnicodeRange1 = o.readUint(i, r), r += 4, a.ulUnicodeRange2 = o.readUint(i, r), r += 4, a.ulUnicodeRange3 = o.readUint(i, r), r += 4, a.ulUnicodeRange4 = o.readUint(i, r), r += 4, a.achVendID = [o.readInt8(i, r), o.readInt8(i, r + 1), o.readInt8(i, r + 2), o.readInt8(i, r + 3)], r += 4, a.fsSelection = o.readUshort(i, r), r += 2, a.usFirstCharIndex = o.readUshort(i, r), r += 2, a.usLastCharIndex = o.readUshort(i, r), r += 2, a.sTypoAscender = o.readShort(i, r), r += 2, a.sTypoDescender = o.readShort(i, r), r += 2, a.sTypoLineGap = o.readShort(i, r), r += 2, a.usWinAscent = o.readUshort(i, r), r += 2, a.usWinDescent = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version1 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version0(i, r, a), a.ulCodePageRange1 = o.readUint(i, r), r += 4, a.ulCodePageRange2 = o.readUint(i, r), r += 4;
    }, e["OS/2"].version2 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version1(i, r, a), a.sxHeight = o.readShort(i, r), r += 2, a.sCapHeight = o.readShort(i, r), r += 2, a.usDefault = o.readUshort(i, r), r += 2, a.usBreak = o.readUshort(i, r), r += 2, a.usMaxContext = o.readUshort(i, r), r += 2;
    }, e["OS/2"].version5 = function(i, r, a) {
      var o = e._bin;
      return r = e["OS/2"].version2(i, r, a), a.usLowerOpticalPointSize = o.readUshort(i, r), r += 2, a.usUpperOpticalPointSize = o.readUshort(i, r), r += 2;
    }, e.post = {}, e.post.parse = function(i, r, a) {
      var o = e._bin, c = {};
      return c.version = o.readFixed(i, r), r += 4, c.italicAngle = o.readFixed(i, r), r += 4, c.underlinePosition = o.readShort(i, r), r += 2, c.underlineThickness = o.readShort(i, r), r += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, r) {
      var a = i.cmap, o = -1;
      if (a.p0e4 != null ? o = a.p0e4 : a.p3e1 != null ? o = a.p3e1 : a.p1e0 != null ? o = a.p1e0 : a.p0e3 != null && (o = a.p0e3), o == -1)
        throw "no familiar platform and encoding!";
      var c = a.tables[o];
      if (c.format == 0)
        return r >= c.map.length ? 0 : c.map[r];
      if (c.format == 4) {
        for (var l = -1, u = 0; u < c.endCount.length; u++)
          if (r <= c.endCount[u]) {
            l = u;
            break;
          }
        return l == -1 || c.startCount[l] > r ? 0 : 65535 & (c.idRangeOffset[l] != 0 ? c.glyphIdArray[r - c.startCount[l] + (c.idRangeOffset[l] >> 1) - (c.idRangeOffset.length - l)] : r + c.idDelta[l]);
      }
      if (c.format == 12) {
        if (r > c.groups[c.groups.length - 1][1])
          return 0;
        for (u = 0; u < c.groups.length; u++) {
          var h = c.groups[u];
          if (h[0] <= r && r <= h[1])
            return h[2] + (r - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(i, r) {
      var a = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[r]) {
        var o = i.SVG.entries[r];
        return o == null ? a : (typeof o == "string" && (o = e.SVG.toPath(o), i.SVG.entries[r] = o), o);
      }
      if (i.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, l = i.CFF, u = i.CFF.Private;
        if (l.ROS) {
          for (var h = 0; l.FDSelect[h + 2] <= r; )
            h += 2;
          u = l.FDArray[l.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[r], c, l, u, a);
      } else
        i.glyf && e.U._drawGlyf(r, i, a);
      return a;
    }, e.U._drawGlyf = function(i, r, a) {
      var o = r.glyf[i];
      o == null && (o = r.glyf[i] = e.glyf._parseGlyf(r, i)), o != null && (o.noc > -1 ? e.U._simpleGlyph(o, a) : e.U._compoGlyph(o, r, a));
    }, e.U._simpleGlyph = function(i, r) {
      for (var a = 0; a < i.noc; a++) {
        for (var o = a == 0 ? 0 : i.endPts[a - 1] + 1, c = i.endPts[a], l = o; l <= c; l++) {
          var u = l == o ? c : l - 1, h = l == c ? o : l + 1, f = 1 & i.flags[l], d = 1 & i.flags[u], A = 1 & i.flags[h], m = i.xs[l], p = i.ys[l];
          if (l == o)
            if (f) {
              if (!d) {
                e.U.P.moveTo(r, m, p);
                continue;
              }
              e.U.P.moveTo(r, i.xs[u], i.ys[u]);
            } else
              d ? e.U.P.moveTo(r, i.xs[u], i.ys[u]) : e.U.P.moveTo(r, (i.xs[u] + m) / 2, (i.ys[u] + p) / 2);
          f ? d && e.U.P.lineTo(r, m, p) : A ? e.U.P.qcurveTo(r, m, p, i.xs[h], i.ys[h]) : e.U.P.qcurveTo(r, m, p, (m + i.xs[h]) / 2, (p + i.ys[h]) / 2);
        }
        e.U.P.closePath(r);
      }
    }, e.U._compoGlyph = function(i, r, a) {
      for (var o = 0; o < i.parts.length; o++) {
        var c = { cmds: [], crds: [] }, l = i.parts[o];
        e.U._drawGlyf(l.glyphIndex, r, c);
        for (var u = l.m, h = 0; h < c.crds.length; h += 2) {
          var f = c.crds[h], d = c.crds[h + 1];
          a.crds.push(f * u.a + d * u.b + u.tx), a.crds.push(f * u.c + d * u.d + u.ty);
        }
        for (h = 0; h < c.cmds.length; h++)
          a.cmds.push(c.cmds[h]);
      }
    }, e.U._getGlyphClass = function(i, r) {
      var a = e._lctf.getInterval(r, i);
      return a == -1 ? 0 : r[a + 2];
    }, e.U.getPairAdjustment = function(i, r, a) {
      var o = !1;
      if (i.GPOS)
        for (var c = i.GPOS, l = c.lookupList, u = c.featureList, h = [], f = 0; f < u.length; f++) {
          var d = u[f];
          if (d.tag == "kern") {
            o = !0;
            for (var A = 0; A < d.tab.length; A++)
              if (!h[d.tab[A]]) {
                h[d.tab[A]] = !0;
                for (var m = l[d.tab[A]], p = 0; p < m.tabs.length; p++)
                  if (m.tabs[p] != null) {
                    var g, _ = m.tabs[p];
                    if ((!_.coverage || (g = e._lctf.coverageIndex(_.coverage, r)) != -1) && m.ltype != 1) {
                      if (m.ltype == 2) {
                        var b = null;
                        if (_.fmt == 1) {
                          var y = _.pairsets[g];
                          for (f = 0; f < y.length; f++)
                            y[f].gid2 == a && (b = y[f]);
                        } else if (_.fmt == 2) {
                          var v = e.U._getGlyphClass(r, _.classDef1), x = e.U._getGlyphClass(a, _.classDef2);
                          b = _.matrix[v][x];
                        }
                        if (b) {
                          var S = 0;
                          return b.val1 && b.val1[2] && (S += b.val1[2]), b.val2 && b.val2[0] && (S += b.val2[0]), S;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (i.kern && !o) {
        var I = i.kern.glyph1.indexOf(r);
        if (I != -1) {
          var E = i.kern.rval[I].glyph2.indexOf(a);
          if (E != -1)
            return i.kern.rval[I].vals[E];
        }
      }
      return 0;
    }, e.U._applySubs = function(i, r, a, o) {
      for (var c = i.length - r - 1, l = 0; l < a.tabs.length; l++)
        if (a.tabs[l] != null) {
          var u, h = a.tabs[l];
          if (!h.coverage || (u = e._lctf.coverageIndex(h.coverage, i[r])) != -1) {
            if (a.ltype == 1)
              i[r], h.fmt == 1 ? i[r] = i[r] + h.delta : i[r] = h.newg[u];
            else if (a.ltype == 4)
              for (var f = h.vals[u], d = 0; d < f.length; d++) {
                var A = f[d], m = A.chain.length;
                if (!(m > c)) {
                  for (var p = !0, g = 0, _ = 0; _ < m; _++) {
                    for (; i[r + g + (1 + _)] == -1; )
                      g++;
                    A.chain[_] != i[r + g + (1 + _)] && (p = !1);
                  }
                  if (p) {
                    for (i[r] = A.nglyph, _ = 0; _ < m + g; _++)
                      i[r + _ + 1] = -1;
                    break;
                  }
                }
              }
            else if (a.ltype == 5 && h.fmt == 2)
              for (var b = e._lctf.getInterval(h.cDef, i[r]), y = h.cDef[b + 2], v = h.scset[y], x = 0; x < v.length; x++) {
                var S = v[x], I = S.input;
                if (!(I.length > c)) {
                  for (p = !0, _ = 0; _ < I.length; _++) {
                    var E = e._lctf.getInterval(h.cDef, i[r + 1 + _]);
                    if (b == -1 && h.cDef[E + 2] != I[_]) {
                      p = !1;
                      break;
                    }
                  }
                  if (p) {
                    var M = S.substLookupRecords;
                    for (d = 0; d < M.length; d += 2)
                      M[d], M[d + 1];
                  }
                }
              }
            else if (a.ltype == 6 && h.fmt == 3) {
              if (!e.U._glsCovered(i, h.backCvg, r - h.backCvg.length) || !e.U._glsCovered(i, h.inptCvg, r) || !e.U._glsCovered(i, h.ahedCvg, r + h.inptCvg.length))
                continue;
              var T = h.lookupRec;
              for (x = 0; x < T.length; x += 2) {
                b = T[x];
                var D = o[T[x + 1]];
                e.U._applySubs(i, r + b, D, o);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, r, a) {
      for (var o = 0; o < r.length; o++)
        if (e._lctf.coverageIndex(r[o], i[a + o]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, r, a) {
      for (var o = { cmds: [], crds: [] }, c = 0, l = 0; l < r.length; l++) {
        var u = r[l];
        if (u != -1) {
          for (var h = l < r.length - 1 && r[l + 1] != -1 ? r[l + 1] : 0, f = e.U.glyphToPath(i, u), d = 0; d < f.crds.length; d += 2)
            o.crds.push(f.crds[d] + c), o.crds.push(f.crds[d + 1]);
          for (a && o.cmds.push(a), d = 0; d < f.cmds.length; d++)
            o.cmds.push(f.cmds[d]);
          a && o.cmds.push("X"), c += i.hmtx.aWidth[u], l < r.length - 1 && (c += e.U.getPairAdjustment(i, u, h));
        }
      }
      return o;
    }, e.U.P = {}, e.U.P.moveTo = function(i, r, a) {
      i.cmds.push("M"), i.crds.push(r, a);
    }, e.U.P.lineTo = function(i, r, a) {
      i.cmds.push("L"), i.crds.push(r, a);
    }, e.U.P.curveTo = function(i, r, a, o, c, l, u) {
      i.cmds.push("C"), i.crds.push(r, a, o, c, l, u);
    }, e.U.P.qcurveTo = function(i, r, a, o, c) {
      i.cmds.push("Q"), i.crds.push(r, a, o, c);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, r, a, o, c) {
      for (var l = r.stack, u = r.nStems, h = r.haveWidth, f = r.width, d = r.open, A = 0, m = r.x, p = r.y, g = 0, _ = 0, b = 0, y = 0, v = 0, x = 0, S = 0, I = 0, E = 0, M = 0, T = { val: 0, size: 0 }; A < i.length; ) {
        e.CFF.getCharString(i, A, T);
        var D = T.val;
        if (A += T.size, D == "o1" || D == "o18")
          l.length % 2 != 0 && !h && (f = l.shift() + o.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (D == "o3" || D == "o23")
          l.length % 2 != 0 && !h && (f = l.shift() + o.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0;
        else if (D == "o4")
          l.length > 1 && !h && (f = l.shift() + o.nominalWidthX, h = !0), d && e.U.P.closePath(c), p += l.pop(), e.U.P.moveTo(c, m, p), d = !0;
        else if (D == "o5")
          for (; l.length > 0; )
            m += l.shift(), p += l.shift(), e.U.P.lineTo(c, m, p);
        else if (D == "o6" || D == "o7")
          for (var F = l.length, C = D == "o6", R = 0; R < F; R++) {
            var O = l.shift();
            C ? m += O : p += O, C = !C, e.U.P.lineTo(c, m, p);
          }
        else if (D == "o8" || D == "o24") {
          F = l.length;
          for (var V = 0; V + 6 <= F; )
            g = m + l.shift(), _ = p + l.shift(), b = g + l.shift(), y = _ + l.shift(), m = b + l.shift(), p = y + l.shift(), e.U.P.curveTo(c, g, _, b, y, m, p), V += 6;
          D == "o24" && (m += l.shift(), p += l.shift(), e.U.P.lineTo(c, m, p));
        } else {
          if (D == "o11")
            break;
          if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237")
            D == "o1234" && (_ = p, b = (g = m + l.shift()) + l.shift(), M = y = _ + l.shift(), x = y, I = p, m = (S = (v = (E = b + l.shift()) + l.shift()) + l.shift()) + l.shift(), e.U.P.curveTo(c, g, _, b, y, E, M), e.U.P.curveTo(c, v, x, S, I, m, p)), D == "o1235" && (g = m + l.shift(), _ = p + l.shift(), b = g + l.shift(), y = _ + l.shift(), E = b + l.shift(), M = y + l.shift(), v = E + l.shift(), x = M + l.shift(), S = v + l.shift(), I = x + l.shift(), m = S + l.shift(), p = I + l.shift(), l.shift(), e.U.P.curveTo(c, g, _, b, y, E, M), e.U.P.curveTo(c, v, x, S, I, m, p)), D == "o1236" && (g = m + l.shift(), _ = p + l.shift(), b = g + l.shift(), M = y = _ + l.shift(), x = y, S = (v = (E = b + l.shift()) + l.shift()) + l.shift(), I = x + l.shift(), m = S + l.shift(), e.U.P.curveTo(c, g, _, b, y, E, M), e.U.P.curveTo(c, v, x, S, I, m, p)), D == "o1237" && (g = m + l.shift(), _ = p + l.shift(), b = g + l.shift(), y = _ + l.shift(), E = b + l.shift(), M = y + l.shift(), v = E + l.shift(), x = M + l.shift(), S = v + l.shift(), I = x + l.shift(), Math.abs(S - m) > Math.abs(I - p) ? m = S + l.shift() : p = I + l.shift(), e.U.P.curveTo(c, g, _, b, y, E, M), e.U.P.curveTo(c, v, x, S, I, m, p));
          else if (D == "o14") {
            if (l.length > 0 && !h && (f = l.shift() + a.nominalWidthX, h = !0), l.length == 4) {
              var q = l.shift(), z = l.shift(), X = l.shift(), w = l.shift(), N = e.CFF.glyphBySE(a, X), H = e.CFF.glyphBySE(a, w);
              e.U._drawCFF(a.CharStrings[N], r, a, o, c), r.x = q, r.y = z, e.U._drawCFF(a.CharStrings[H], r, a, o, c);
            }
            d && (e.U.P.closePath(c), d = !1);
          } else if (D == "o19" || D == "o20")
            l.length % 2 != 0 && !h && (f = l.shift() + o.nominalWidthX), u += l.length >> 1, l.length = 0, h = !0, A += u + 7 >> 3;
          else if (D == "o21")
            l.length > 2 && !h && (f = l.shift() + o.nominalWidthX, h = !0), p += l.pop(), m += l.pop(), d && e.U.P.closePath(c), e.U.P.moveTo(c, m, p), d = !0;
          else if (D == "o22")
            l.length > 1 && !h && (f = l.shift() + o.nominalWidthX, h = !0), m += l.pop(), d && e.U.P.closePath(c), e.U.P.moveTo(c, m, p), d = !0;
          else if (D == "o25") {
            for (; l.length > 6; )
              m += l.shift(), p += l.shift(), e.U.P.lineTo(c, m, p);
            g = m + l.shift(), _ = p + l.shift(), b = g + l.shift(), y = _ + l.shift(), m = b + l.shift(), p = y + l.shift(), e.U.P.curveTo(c, g, _, b, y, m, p);
          } else if (D == "o26")
            for (l.length % 2 && (m += l.shift()); l.length > 0; )
              g = m, _ = p + l.shift(), m = b = g + l.shift(), p = (y = _ + l.shift()) + l.shift(), e.U.P.curveTo(c, g, _, b, y, m, p);
          else if (D == "o27")
            for (l.length % 2 && (p += l.shift()); l.length > 0; )
              _ = p, b = (g = m + l.shift()) + l.shift(), y = _ + l.shift(), m = b + l.shift(), p = y, e.U.P.curveTo(c, g, _, b, y, m, p);
          else if (D == "o10" || D == "o29") {
            var j = D == "o10" ? o : a;
            if (l.length == 0)
              console.debug("error: empty stack");
            else {
              var $ = l.pop(), ce = j.Subrs[$ + j.Bias];
              r.x = m, r.y = p, r.nStems = u, r.haveWidth = h, r.width = f, r.open = d, e.U._drawCFF(ce, r, a, o, c), m = r.x, p = r.y, u = r.nStems, h = r.haveWidth, f = r.width, d = r.open;
            }
          } else if (D == "o30" || D == "o31") {
            var ee = l.length, le = (V = 0, D == "o31");
            for (V += ee - (F = -3 & ee); V < F; )
              le ? (_ = p, b = (g = m + l.shift()) + l.shift(), p = (y = _ + l.shift()) + l.shift(), F - V == 5 ? (m = b + l.shift(), V++) : m = b, le = !1) : (g = m, _ = p + l.shift(), b = g + l.shift(), y = _ + l.shift(), m = b + l.shift(), F - V == 5 ? (p = y + l.shift(), V++) : p = y, le = !0), e.U.P.curveTo(c, g, _, b, y, m, p), V += 4;
          } else {
            if ((D + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + D, i), D;
            l.push(D);
          }
        }
      }
      r.x = m, r.y = p, r.nStems = u, r.haveWidth = h, r.width = f, r.open = d;
    };
    var t = e, n = { Typr: t };
    return s.Typr = t, s.default = n, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function eR() {
  return function(s) {
    var e = Uint8Array, t = Uint16Array, n = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), r = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o = function(D, F) {
      for (var C = new t(31), R = 0; R < 31; ++R)
        C[R] = F += 1 << D[R - 1];
      var O = new n(C[30]);
      for (R = 1; R < 30; ++R)
        for (var V = C[R]; V < C[R + 1]; ++V)
          O[V] = V - C[R] << 5 | R;
      return [C, O];
    }, c = o(i, 2), l = c[0], u = c[1];
    l[28] = 258, u[258] = 28;
    for (var h = o(r, 0)[0], f = new t(32768), d = 0; d < 32768; ++d) {
      var A = (43690 & d) >>> 1 | (21845 & d) << 1;
      A = (61680 & (A = (52428 & A) >>> 2 | (13107 & A) << 2)) >>> 4 | (3855 & A) << 4, f[d] = ((65280 & A) >>> 8 | (255 & A) << 8) >>> 1;
    }
    var m = function(D, F, C) {
      for (var R = D.length, O = 0, V = new t(F); O < R; ++O)
        ++V[D[O] - 1];
      var q, z = new t(F);
      for (O = 0; O < F; ++O)
        z[O] = z[O - 1] + V[O - 1] << 1;
      if (C) {
        q = new t(1 << F);
        var X = 15 - F;
        for (O = 0; O < R; ++O)
          if (D[O])
            for (var w = O << 4 | D[O], N = F - D[O], H = z[D[O] - 1]++ << N, j = H | (1 << N) - 1; H <= j; ++H)
              q[f[H] >>> X] = w;
      } else
        for (q = new t(R), O = 0; O < R; ++O)
          D[O] && (q[O] = f[z[D[O] - 1]++] >>> 15 - D[O]);
      return q;
    }, p = new e(288);
    for (d = 0; d < 144; ++d)
      p[d] = 8;
    for (d = 144; d < 256; ++d)
      p[d] = 9;
    for (d = 256; d < 280; ++d)
      p[d] = 7;
    for (d = 280; d < 288; ++d)
      p[d] = 8;
    var g = new e(32);
    for (d = 0; d < 32; ++d)
      g[d] = 5;
    var _ = m(p, 9, 1), b = m(g, 5, 1), y = function(D) {
      for (var F = D[0], C = 1; C < D.length; ++C)
        D[C] > F && (F = D[C]);
      return F;
    }, v = function(D, F, C) {
      var R = F / 8 | 0;
      return (D[R] | D[R + 1] << 8) >> (7 & F) & C;
    }, x = function(D, F) {
      var C = F / 8 | 0;
      return (D[C] | D[C + 1] << 8 | D[C + 2] << 16) >> (7 & F);
    }, S = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], I = function(D, F, C) {
      var R = new Error(F || S[D]);
      if (R.code = D, Error.captureStackTrace && Error.captureStackTrace(R, I), !C)
        throw R;
      return R;
    }, E = function(D, F, C) {
      var R = D.length;
      if (!R || C && !C.l && R < 5)
        return F || new e(0);
      var O = !F || C, V = !C || C.i;
      C || (C = {}), F || (F = new e(3 * R));
      var q, z = function(Le) {
        var Fe = F.length;
        if (Le > Fe) {
          var Ge = new e(Math.max(2 * Fe, Le));
          Ge.set(F), F = Ge;
        }
      }, X = C.f || 0, w = C.p || 0, N = C.b || 0, H = C.l, j = C.d, $ = C.m, ce = C.n, ee = 8 * R;
      do {
        if (!H) {
          C.f = X = v(D, w, 1);
          var le = v(D, w + 1, 3);
          if (w += 3, !le) {
            var Z = D[(ve = ((q = w) / 8 | 0) + (7 & q && 1) + 4) - 4] | D[ve - 3] << 8, he = ve + Z;
            if (he > R) {
              V && I(0);
              break;
            }
            O && z(N + Z), F.set(D.subarray(ve, he), N), C.b = N += Z, C.p = w = 8 * he;
            continue;
          }
          if (le == 1)
            H = _, j = b, $ = 9, ce = 5;
          else if (le == 2) {
            var _e = v(D, w, 31) + 257, U = v(D, w + 10, 15) + 4, ye = _e + v(D, w + 5, 31) + 1;
            w += 14;
            for (var ie = new e(ye), re = new e(19), te = 0; te < U; ++te)
              re[a[te]] = v(D, w + 3 * te, 7);
            w += 3 * U;
            var Ie = y(re), se = (1 << Ie) - 1, K = m(re, Ie, 1);
            for (te = 0; te < ye; ) {
              var ve, fe = K[v(D, w, se)];
              if (w += 15 & fe, (ve = fe >>> 4) < 16)
                ie[te++] = ve;
              else {
                var oe = 0, L = 0;
                for (ve == 16 ? (L = 3 + v(D, w, 3), w += 2, oe = ie[te - 1]) : ve == 17 ? (L = 3 + v(D, w, 7), w += 3) : ve == 18 && (L = 11 + v(D, w, 127), w += 7); L--; )
                  ie[te++] = oe;
              }
            }
            var B = ie.subarray(0, _e), W = ie.subarray(_e);
            $ = y(B), ce = y(W), H = m(B, $, 1), j = m(W, ce, 1);
          } else
            I(1);
          if (w > ee) {
            V && I(0);
            break;
          }
        }
        O && z(N + 131072);
        for (var de = (1 << $) - 1, Ae = (1 << ce) - 1, G = w; ; G = w) {
          var Ce = (oe = H[x(D, w) & de]) >>> 4;
          if ((w += 15 & oe) > ee) {
            V && I(0);
            break;
          }
          if (oe || I(2), Ce < 256)
            F[N++] = Ce;
          else {
            if (Ce == 256) {
              G = w, H = null;
              break;
            }
            var Se = Ce - 254;
            if (Ce > 264) {
              var De = i[te = Ce - 257];
              Se = v(D, w, (1 << De) - 1) + l[te], w += De;
            }
            var Q = j[x(D, w) & Ae], Me = Q >>> 4;
            if (Q || I(3), w += 15 & Q, W = h[Me], Me > 3 && (De = r[Me], W += x(D, w) & (1 << De) - 1, w += De), w > ee) {
              V && I(0);
              break;
            }
            O && z(N + 131072);
            for (var pe = N + Se; N < pe; N += 4)
              F[N] = F[N - W], F[N + 1] = F[N + 1 - W], F[N + 2] = F[N + 2 - W], F[N + 3] = F[N + 3 - W];
            N = pe;
          }
        }
        C.l = H, C.p = G, C.b = N, H && (X = 1, C.m = $, C.d = j, C.n = ce);
      } while (!X);
      return N == F.length ? F : function(Le, Fe, Ge) {
        (Fe == null || Fe < 0) && (Fe = 0), (Ge == null || Ge > Le.length) && (Ge = Le.length);
        var Ue = new (Le instanceof t ? t : Le instanceof n ? n : e)(Ge - Fe);
        return Ue.set(Le.subarray(Fe, Ge)), Ue;
      }(F, 0, N);
    }, M = new e(0), T = typeof TextDecoder < "u" && new TextDecoder();
    try {
      T.decode(M, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(D) {
      var F = new DataView(D), C = 0;
      function R() {
        var _e = F.getUint16(C);
        return C += 2, _e;
      }
      function O() {
        var _e = F.getUint32(C);
        return C += 4, _e;
      }
      function V(_e) {
        Z.setUint16(he, _e), he += 2;
      }
      function q(_e) {
        Z.setUint32(he, _e), he += 4;
      }
      for (var z = { signature: O(), flavor: O(), length: O(), numTables: R(), reserved: R(), totalSfntSize: O(), majorVersion: R(), minorVersion: R(), metaOffset: O(), metaLength: O(), metaOrigLength: O(), privOffset: O(), privLength: O() }, X = 0; Math.pow(2, X) <= z.numTables; )
        X++;
      X--;
      for (var w = 16 * Math.pow(2, X), N = 16 * z.numTables - w, H = 12, j = [], $ = 0; $ < z.numTables; $++)
        j.push({ tag: O(), offset: O(), compLength: O(), origLength: O(), origChecksum: O() }), H += 16;
      var ce, ee = new Uint8Array(12 + 16 * j.length + j.reduce(function(_e, U) {
        return _e + U.origLength + 4;
      }, 0)), le = ee.buffer, Z = new DataView(le), he = 0;
      return q(z.flavor), V(z.numTables), V(w), V(X), V(N), j.forEach(function(_e) {
        q(_e.tag), q(_e.origChecksum), q(H), q(_e.origLength), _e.outOffset = H, (H += _e.origLength) % 4 != 0 && (H += 4 - H % 4);
      }), j.forEach(function(_e) {
        var U, ye = D.slice(_e.offset, _e.offset + _e.compLength);
        if (_e.compLength != _e.origLength) {
          var ie = new Uint8Array(_e.origLength);
          U = new Uint8Array(ye, 2), E(U, ie);
        } else
          ie = new Uint8Array(ye);
        ee.set(ie, _e.outOffset);
        var re = 0;
        (H = _e.outOffset + _e.origLength) % 4 != 0 && (re = 4 - H % 4), ee.set(new Uint8Array(re).buffer, _e.outOffset + _e.origLength), ce = H + re;
      }), le.slice(0, ce);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function tR(s, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, n = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, r = 2, a = 4, o = 8, c = 16, l = 32;
  let u;
  function h(v) {
    if (!u) {
      const x = {
        R: r,
        L: i,
        D: a,
        C: c,
        U: l,
        T: o
      };
      u = /* @__PURE__ */ new Map();
      for (let S in n) {
        let I = 0;
        n[S].split(",").forEach((E) => {
          let [M, T] = E.split("+");
          M = parseInt(M, 36), T = T ? parseInt(T, 36) : 0, u.set(I += M, x[S]);
          for (let D = T; D--; )
            u.set(++I, x[S]);
        });
      }
    }
    return u.get(v) || l;
  }
  const f = 1, d = 2, A = 3, m = 4, p = [null, "isol", "init", "fina", "medi"];
  function g(v) {
    const x = new Uint8Array(v.length);
    let S = l, I = f, E = -1;
    for (let M = 0; M < v.length; M++) {
      const T = v.codePointAt(M);
      let D = h(T) | 0, F = f;
      D & o || (S & (i | a | c) ? D & (r | a | c) ? (F = A, (I === f || I === A) && x[E]++) : D & (i | l) && (I === d || I === m) && x[E]-- : S & (r | l) && (I === d || I === m) && x[E]--, I = x[M] = F, S = D, E = M, T > 65535 && M++);
    }
    return x;
  }
  function _(v, x) {
    const S = [];
    for (let E = 0; E < x.length; E++) {
      const M = x.codePointAt(E);
      M > 65535 && E++, S.push(s.U.codeToGlyph(v, M));
    }
    const I = v.GSUB;
    if (I) {
      const { lookupList: E, featureList: M } = I;
      let T;
      const D = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, F = [];
      M.forEach((C) => {
        if (D.test(C.tag))
          for (let R = 0; R < C.tab.length; R++) {
            if (F[C.tab[R]])
              continue;
            F[C.tab[R]] = !0;
            const O = E[C.tab[R]], V = /^(isol|init|fina|medi)$/.test(C.tag);
            V && !T && (T = g(x));
            for (let q = 0; q < S.length; q++)
              (!T || !V || p[T[q]] === C.tag) && s.U._applySubs(S, q, O, E);
          }
      });
    }
    return S;
  }
  function b(...v) {
    for (let x = 0; x < v.length; x++)
      if (typeof v[x] == "number")
        return v[x];
  }
  function y(v) {
    const x = /* @__PURE__ */ Object.create(null), S = v["OS/2"], I = v.hhea, E = v.head.unitsPerEm, M = b(S && S.sTypoAscender, I && I.ascender, E), T = {
      unitsPerEm: E,
      ascender: M,
      descender: b(S && S.sTypoDescender, I && I.descender, 0),
      capHeight: b(S && S.sCapHeight, M),
      xHeight: b(S && S.sxHeight, M),
      lineGap: b(S && S.sTypoLineGap, I && I.lineGap),
      forEachGlyph(D, F, C, R) {
        let O = 0;
        const V = 1 / T.unitsPerEm * F, q = _(v, D);
        let z = 0, X = -1;
        return q.forEach((w, N) => {
          if (w !== -1) {
            let H = x[w];
            if (!H) {
              const { cmds: j, crds: $ } = s.U.glyphToPath(v, w);
              let ce = "", ee = 0;
              for (let U = 0, ye = j.length; U < ye; U++) {
                const ie = t[j[U]];
                ce += j[U];
                for (let re = 1; re <= ie; re++)
                  ce += (re > 1 ? "," : "") + $[ee++];
              }
              let le, Z, he, _e;
              if ($.length) {
                le = Z = 1 / 0, he = _e = -1 / 0;
                for (let U = 0, ye = $.length; U < ye; U += 2) {
                  let ie = $[U], re = $[U + 1];
                  ie < le && (le = ie), re < Z && (Z = re), ie > he && (he = ie), re > _e && (_e = re);
                }
              } else
                le = he = Z = _e = 0;
              H = x[w] = {
                index: w,
                advanceWidth: v.hmtx.aWidth[w],
                xMin: le,
                yMin: Z,
                xMax: he,
                yMax: _e,
                path: ce,
                pathCommandCount: j.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            X !== -1 && (O += s.U.getPairAdjustment(v, X, w) * V), R.call(null, H, O, z), H.advanceWidth && (O += H.advanceWidth * V), C && (O += C * F), X = w;
          }
          z += D.codePointAt(z) > 65535 ? 2 : 1;
        }), O;
      }
    };
    return T;
  }
  return function(x) {
    const S = new Uint8Array(x, 0, 4), I = s._bin.readASCII(S, 0, 4);
    if (I === "wOFF")
      x = e(x);
    else if (I === "wOF2")
      throw new Error("woff2 fonts not supported");
    return y(s.parse(x)[0]);
  };
}
const nR = /* @__PURE__ */ ec({
  name: "Typr Font Parser",
  dependencies: [$B, eR, tR],
  init(s, e, t) {
    const n = s(), i = e();
    return t(n, i);
  }
}), da = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, iR = /* @__PURE__ */ new Pe();
function ca() {
  return (self.performance || Date).now();
}
const Yg = /* @__PURE__ */ Object.create(null);
function ob(s, e) {
  s = aR({}, s);
  const t = ca();
  if (s.font = oR(s.font || da.defaultFontURL), s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || da.sdfGlyphSize, s.colorRanges != null) {
    let h = {};
    for (let f in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(f)) {
        let d = s.colorRanges[f];
        typeof d != "number" && (d = iR.set(d).getHex()), h[f] = d;
      }
    s.colorRanges = h;
  }
  Object.freeze(s);
  const { textureWidth: n, sdfExponent: i } = da, { sdfGlyphSize: r } = s, a = n / r * 4;
  let o = Yg[r];
  if (!o) {
    const h = document.createElement("canvas");
    h.width = n, h.height = r * 256 / a, o = Yg[r] = {
      glyphCount: 0,
      sdfGlyphSize: r,
      sdfCanvas: h,
      sdfTexture: new Jt(
        h,
        void 0,
        void 0,
        void 0,
        wt,
        wt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, o.sdfTexture.generateMipmaps = !1, rR(o);
  }
  const { sdfTexture: c, sdfCanvas: l } = o;
  let u = o.glyphsByFont.get(s.font);
  u || o.glyphsByFont.set(s.font, u = /* @__PURE__ */ new Map()), lR(s).then((h) => {
    const { glyphIds: f, glyphPositions: d, fontSize: A, unitsPerEm: m, timings: p } = h, g = [], _ = new Float32Array(f.length * 4), b = A / m;
    let y = 0, v = 0;
    const x = ca();
    f.forEach((T, D) => {
      let F = u.get(T);
      if (!F) {
        const { path: V, pathBounds: q } = h.glyphData[T], z = Math.max(q[2] - q[0], q[3] - q[1]) / r * (da.sdfMargin * r + 0.5), X = o.glyphCount++, w = [
          q[0] - z,
          q[1] - z,
          q[2] + z,
          q[3] + z
        ];
        u.set(T, F = { path: V, atlasIndex: X, sdfViewBox: w }), g.push(F);
      }
      const { sdfViewBox: C } = F, R = d[v++], O = d[v++];
      _[y++] = R + C[0] * b, _[y++] = O + C[1] * b, _[y++] = R + C[2] * b, _[y++] = O + C[3] * b, f[D] = F.atlasIndex;
    }), p.quads = (p.quads || 0) + (ca() - x);
    const S = ca();
    p.sdf = {};
    const I = l.height, E = Math.ceil(o.glyphCount / a), M = Math.pow(2, Math.ceil(Math.log2(E * r)));
    M > I && (console.info(`Increasing SDF texture size ${I}->${M}`), ZB(l, n, M), c.dispose()), Promise.all(g.map(
      (T) => cb(T, o, s.gpuAccelerateSDF).then(({ timing: D }) => {
        p.sdf[T.atlasIndex] = D;
      })
    )).then(() => {
      g.length && !o.contextLost && (lb(o), c.needsUpdate = !0), p.sdfTotal = ca() - S, p.total = ca() - t, e(Object.freeze({
        parameters: s,
        sdfTexture: c,
        sdfGlyphSize: r,
        sdfExponent: i,
        glyphBounds: _,
        glyphAtlasIndices: f,
        glyphColors: h.glyphColors,
        caretPositions: h.caretPositions,
        caretHeight: h.caretHeight,
        chunkedBounds: h.chunkedBounds,
        ascender: h.ascender,
        descender: h.descender,
        lineHeight: h.lineHeight,
        capHeight: h.capHeight,
        xHeight: h.xHeight,
        topBaseline: h.topBaseline,
        blockBounds: h.blockBounds,
        visibleBounds: h.visibleBounds,
        timings: h.timings
      }));
    });
  }), Promise.resolve().then(() => {
    o.contextLost || KB(l);
  });
}
function cb({ path: s, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: n, sdfCanvas: i, contextLost: r }, a) {
  if (r)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: o, sdfExponent: c } = da, l = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), h = u % (o / n) * n, f = Math.floor(u / (o / n)) * n, d = e % 4;
  return WB(n, n, s, t, l, c, i, h, f, d, a);
}
function rR(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), s.contextLost = !1;
    const n = [];
    s.glyphsByFont.forEach((i) => {
      i.forEach((r) => {
        n.push(cb(r, s, !0));
      });
    }), Promise.all(n).then(() => {
      lb(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function sR({ font: s, characters: e, sdfGlyphSize: t }, n) {
  let i = Array.isArray(e) ? e.join(`
`) : "" + e;
  ob({ font: s, sdfGlyphSize: t, text: i }, n);
}
function aR(s, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (s[t] = e[t]);
  return s;
}
let rl;
function oR(s) {
  return rl || (rl = typeof document > "u" ? {} : document.createElement("a")), rl.href = s, rl.href;
}
function lb(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = s, { width: n, height: i } = e, r = s.sdfCanvas.getContext("webgl");
    let a = t.image.data;
    (!a || a.length !== n * i * 4) && (a = new Uint8Array(n * i * 4), t.image = { width: n, height: i, data: a }, t.flipY = !1, t.isDataTexture = !0), r.readPixels(0, 0, n, i, r.RGBA, r.UNSIGNED_BYTE, a);
  }
}
const cR = /* @__PURE__ */ ec({
  name: "Typesetter",
  dependencies: [
    da,
    nR,
    VB,
    FB
  ],
  init(s, e, t, n) {
    const { defaultFontURL: i } = s;
    return t(e, n(), { defaultFontURL: i });
  }
}), lR = /* @__PURE__ */ ec({
  name: "Typesetter",
  dependencies: [
    cR
  ],
  init(s) {
    return function(e) {
      return new Promise((t) => {
        s.typeset(e, t);
      });
    };
  },
  getTransferables(s) {
    const e = [
      s.glyphPositions.buffer,
      s.glyphIds.buffer
    ];
    return s.caretPositions && e.push(s.caretPositions.buffer), s.glyphColors && e.push(s.glyphColors.buffer), e;
  }
}), jg = {};
function uR(s) {
  let e = jg[s];
  if (!e) {
    const t = new ji(1, 1, s, s), n = t.clone(), i = t.attributes, r = n.attributes, a = new ot(), o = i.uv.count;
    for (let c = 0; c < o; c++)
      r.position.array[c * 3] *= -1, r.normal.array[c * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((c) => {
      a.setAttribute(
        c,
        new je(
          [...i[c].array, ...r[c].array],
          i[c].itemSize
        )
      );
    }), a.setIndex([...t.index.array, ...n.index.array.map((c) => c + o)]), a.translate(0.5, 0.5, 0), e = jg[s] = a;
  }
  return e;
}
const hR = "aTroikaGlyphBounds", Jg = "aTroikaGlyphIndex", fR = "aTroikaGlyphColor";
class dR extends Ed {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new yn(), this.boundingBox = new bn();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === Fn ? t / 2 : 0, e === Mn ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = uR(e);
      ["position", "normal", "uv"].forEach((n) => {
        this.attributes[n] = t.attributes[n].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, t, n, i, r) {
    Qh(this, hR, e, 4), Qh(this, Jg, t, 1), Qh(this, fR, r, 3), this._blockBounds = n, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: n } = this;
      if (t) {
        const { PI: i, floor: r, min: a, max: o, sin: c, cos: l } = Math, u = i / 2, h = i * 2, f = Math.abs(t), d = e[0] / f, A = e[2] / f, m = r((d + u) / h) !== r((A + u) / h) ? -f : a(c(d) * f, c(A) * f), p = r((d - u) / h) !== r((A - u) / h) ? f : o(c(d) * f, c(A) * f), g = r((d + i) / h) !== r((A + i) / h) ? f * 2 : o(f - l(d) * f, f - l(A) * f);
        n.min.set(m, e[1], t < 0 ? -g : 0), n.max.set(p, e[3], t < 0 ? 0 : g);
      } else
        n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
      n.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let t = this.getAttribute(Jg).count, n = this._chunkedBounds;
    if (n)
      for (let i = n.length; i--; ) {
        t = n[i].end;
        let r = n[i].rect;
        if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function Qh(s, e, t, n) {
  const i = s.getAttribute(e);
  t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (s.setAttribute(e, new Nr(t, n)), delete s._maxInstanceCount, s.dispose()) : i && s.deleteAttribute(e);
}
const pR = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, AR = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, gR = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, mR = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function _R(s) {
  const e = Nf(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new xe() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Dt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Dt(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new xe() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Pe() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new ft() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: pR,
    vertexTransform: AR,
    fragmentDefs: gR,
    fragmentColorTransform: mR,
    customRewriter({ vertexShader: t, fragmentShader: n }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(n) && (n = n.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        sb,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: n };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Fd = /* @__PURE__ */ new In({
  color: 16777215,
  side: Mn,
  transparent: !0
}), Kg = 8421504, Zg = /* @__PURE__ */ new Je(), sl = /* @__PURE__ */ new P(), Gh = /* @__PURE__ */ new P(), co = [], bR = /* @__PURE__ */ new P(), zh = "+x+y";
function $g(s) {
  return Array.isArray(s) ? s[0] : s;
}
let ub = () => {
  const s = new Ne(
    new ji(1, 1),
    Fd
  );
  return ub = () => s, s;
}, hb = () => {
  const s = new Ne(
    new ji(1, 1, 32, 1),
    Fd
  );
  return hb = () => s, s;
};
const yR = { type: "syncstart" }, vR = { type: "synccomplete" }, fb = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], ER = fb.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class db extends Ne {
  constructor() {
    const e = new dR();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Kg, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = zh, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(yR), ob({
      text: this.text,
      font: this.font,
      fontSize: this.fontSize || 0.1,
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const n = this._queuedSyncs;
      n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        n.forEach((i) => i && i());
      })), this.dispatchEvent(vR), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, t, n, i, r, a) {
    this.sync(), r.isTroikaTextMaterial && this._prepareForRender(r), r._hadOwnSide = r.hasOwnProperty("side"), this.geometry.setSide(r._actualSide = r.side), r.side = mi;
  }
  onAfterRender(e, t, n, i, r, a) {
    r._hadOwnSide ? r.side = r._actualSide : delete r.side;
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Fd.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = _R(t), t.addEventListener("dispose", function n() {
      t.removeEventListener("dispose", n), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let n = e._outlineMtl;
      return n || (n = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), n.isTextOutlineMaterial = !0, n.depthWrite = !1, n.map = null, e.addEventListener("dispose", function i() {
        e.removeEventListener("dispose", i), n.dispose();
      })), [
        n,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return $g(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return $g(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, n = e.uniforms, i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: o, blockBounds: c } = i;
      n.uTroikaSDFTexture.value = o, n.uTroikaSDFTextureSize.value.set(o.image.width, o.image.height), n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, n.uTroikaSDFExponent.value = i.sdfExponent, n.uTroikaTotalBounds.value.fromArray(c), n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
      let l = 0, u = 0, h = 0, f, d, A, m = 0, p = 0;
      if (t) {
        let { outlineWidth: _, outlineOffsetX: b, outlineOffsetY: y, outlineBlur: v, outlineOpacity: x } = this;
        l = this._parsePercent(_) || 0, u = Math.max(0, this._parsePercent(v) || 0), f = x, m = this._parsePercent(b) || 0, p = this._parsePercent(y) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (A = this.strokeColor, n.uTroikaStrokeColor.value.set(A ?? Kg), d = this.strokeOpacity, d == null && (d = 1)), f = this.fillOpacity;
      n.uTroikaDistanceOffset.value = l, n.uTroikaPositionOffset.value.set(m, p), n.uTroikaBlurRadius.value = u, n.uTroikaStrokeWidth.value = h, n.uTroikaStrokeOpacity.value = d, n.uTroikaFillOpacity.value = f ?? 1, n.uTroikaCurveRadius.value = this.curveRadius || 0;
      let g = this.clipRect;
      if (g && Array.isArray(g) && g.length === 4)
        n.uTroikaClipRect.value.fromArray(g);
      else {
        const _ = (this.fontSize || 0.1) * 100;
        n.uTroikaClipRect.value.set(
          c[0] - _,
          c[1] - _,
          c[2] + _,
          c[3] + _
        );
      }
      this.geometry.applyClipRect(n.uTroikaClipRect.value);
    }
    n.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const r = t ? this.outlineColor || 0 : this.color;
    if (r == null)
      delete e.color;
    else {
      const o = e.hasOwnProperty("color") ? e.color : e.color = new Pe();
      (r !== o._input || typeof r == "object") && o.set(o._input = r);
    }
    let a = this.orientation || zh;
    if (a !== e._orientation) {
      let o = n.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let c = a !== zh && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, l, u, h, f] = c;
        sl.set(0, 0, 0)[u] = l === "-" ? 1 : -1, Gh.set(0, 0, 0)[f] = h === "-" ? -1 : 1, Zg.lookAt(bR, sl.cross(Gh), Gh), o.setFromMatrix4(Zg);
      } else
        o.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), n = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, t = new xe()) {
    t.copy(e);
    const n = this.curveRadius;
    return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, t = new xe()) {
    return sl.copy(e), this.localPositionToTextCoords(this.worldToLocal(sl), t);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, t) {
    const { textRenderInfo: n, curveRadius: i } = this;
    if (n) {
      const r = n.blockBounds, a = i ? hb() : ub(), o = a.geometry, { position: c, uv: l } = o.attributes;
      for (let u = 0; u < l.count; u++) {
        let h = r[0] + l.getX(u) * (r[2] - r[0]);
        const f = r[1] + l.getY(u) * (r[3] - r[1]);
        let d = 0;
        i && (d = i - Math.cos(h / i) * i, h = Math.sin(h / i) * i), c.setXYZ(u, h, f, d);
      }
      o.boundingSphere = this.geometry.boundingSphere, o.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, co.length = 0, a.raycast(e, co);
      for (let u = 0; u < co.length; u++)
        co[u].object = this, t.push(co[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, ER.forEach((n) => {
      this[n] = e[n];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
fb.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(db.prototype, s, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const xR = (s) => ({ ref: s & /*ref*/
8 }), em = (s) => ({ ref: (
  /*ref*/
  s[3]
) });
function SR(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    em
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      520) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          xR
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        em
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function CR(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[3]
    ) },
    /*$$restProps*/
    s[6],
    { font: (
      /*font*/
      s[0]
    ) },
    { characters: (
      /*characters*/
      s[1]
    ) },
    { sdfGlyphSize: (
      /*sdfGlyphSize*/
      s[2]
    ) }
  ];
  let i = {
    $$slots: {
      default: [SR, ({ ref: r }) => ({ 3: r }), ({ ref: r }) => r ? 8 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[8](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps, font, characters, sdfGlyphSize*/
      79 ? Qt(n, [
        a & /*ref*/
        8 && { is: (
          /*ref*/
          r[3]
        ) },
        a & /*$$restProps*/
        64 && qt(
          /*$$restProps*/
          r[6]
        ),
        a & /*font*/
        1 && { font: (
          /*font*/
          r[0]
        ) },
        a & /*characters*/
        2 && { characters: (
          /*characters*/
          r[1]
        ) },
        a & /*sdfGlyphSize*/
        4 && { sdfGlyphSize: (
          /*sdfGlyphSize*/
          r[2]
        ) }
      ]) : {};
      a & /*$$scope, ref*/
      520 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
function MR(s, e, t) {
  const n = ["font", "characters", "sdfGlyphSize", "ref"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { font: c = void 0 } = e, { characters: l = void 0 } = e, { sdfGlyphSize: u = void 0 } = e;
  const h = new db(), { invalidate: f } = sn(), d = Db(), A = An();
  $e(s, A, (_) => t(4, r = _));
  const m = async () => {
    await Ll(), h.sync(() => {
      f(), d("sync");
    });
  }, p = Au();
  function g(_) {
    Mt[_ ? "unshift" : "push"](() => {
      r = _, A.set(r);
    });
  }
  return s.$$set = (_) => {
    e = Ve(Ve({}, e), Kt(_)), t(6, i = at(e, n)), "font" in _ && t(0, c = _.font), "characters" in _ && t(1, l = _.characters), "sdfGlyphSize" in _ && t(2, u = _.sdfGlyphSize), "$$scope" in _ && t(9, o = _.$$scope);
  }, s.$$.update = () => {
    i && m(), s.$$.dirty & /*font, characters, sdfGlyphSize*/
    7 && p(new Promise((_) => sR({ font: c, characters: l, sdfGlyphSize: u }, _)));
  }, [
    c,
    l,
    u,
    h,
    r,
    A,
    i,
    a,
    g,
    o
  ];
}
class IR extends St {
  constructor(e) {
    super(), Et(this, e, MR, CR, pt, {
      font: 0,
      characters: 1,
      sdfGlyphSize: 2,
      ref: 3
    });
  }
  get font() {
    return this.$$.ctx[0];
  }
  set font(e) {
    this.$$set({ font: e }), Y();
  }
  get characters() {
    return this.$$.ctx[1];
  }
  set characters(e) {
    this.$$set({ characters: e }), Y();
  }
  get sdfGlyphSize() {
    return this.$$.ctx[2];
  }
  set sdfGlyphSize(e) {
    this.$$set({ sdfGlyphSize: e }), Y();
  }
  get ref() {
    return this.$$.ctx[3];
  }
}
xt(IR, { font: {}, characters: {}, sdfGlyphSize: {} }, ["default"], ["ref"], !0);
function kd() {
  const s = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (e, t) => {
      if (t = t ?? "default", s.audioListeners.has(t)) {
        console.warn(`An AudioListener with the id "${t}" has already been added, aborting.`);
        return;
      }
      s.audioListeners.set(t, e);
    },
    removeAudioListener: (e) => {
      if (e = e ?? "default", !s.audioListeners.has(e)) {
        console.warn(`No AudioListener with the id "${e}" found, aborting.`);
        return;
      }
      s.audioListeners.delete(e);
    },
    getAudioListener: (e) => {
      if (e = e ?? "default", !s.audioListeners.has(e)) {
        console.warn(`No AudioListener with the id "${e}" found, aborting.`);
        return;
      }
      return s.audioListeners.get(e);
    }
  };
  return Ld("threlte-audio", s);
}
const wR = (s) => ({ ref: s & /*ref*/
1 }), tm = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function TR(s) {
  let e;
  const t = (
    /*#slots*/
    s[8].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[10],
    tm
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      1025) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[10],
        e ? gt(
          t,
          /*$$scope*/
          i[10],
          r,
          wR
        ) : _t(
          /*$$scope*/
          i[10]
        ),
        tm
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function BR(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [TR, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[9](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      1025 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[9](null), Qe(e, r);
    }
  };
}
function RR(s, e, t) {
  const n = ["id", "masterVolume", "ref", "audioContext", "resumeContext"];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { id: c = void 0 } = e, { masterVolume: l = void 0 } = e;
  const u = new d_(), h = u.context, f = async () => await u.context.resume(), { addAudioListener: d, removeAudioListener: A } = kd();
  d(u, c), Wt(() => {
    A(c);
  });
  const m = An();
  $e(s, m, (g) => t(1, r = g));
  function p(g) {
    Mt[g ? "unshift" : "push"](() => {
      r = g, m.set(r);
    });
  }
  return s.$$set = (g) => {
    e = Ve(Ve({}, e), Kt(g)), t(3, i = at(e, n)), "id" in g && t(4, c = g.id), "masterVolume" in g && t(5, l = g.masterVolume), "$$scope" in g && t(10, o = g.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*masterVolume*/
    32 && l !== void 0 && u.setMasterVolume(l);
  }, [
    u,
    r,
    m,
    i,
    c,
    l,
    h,
    f,
    a,
    p,
    o
  ];
}
class DR extends St {
  constructor(e) {
    super(), Et(this, e, RR, BR, pt, {
      id: 4,
      masterVolume: 5,
      ref: 0,
      audioContext: 6,
      resumeContext: 7
    });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get masterVolume() {
    return this.$$.ctx[5];
  }
  set masterVolume(e) {
    this.$$set({ masterVolume: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get audioContext() {
    return this.$$.ctx[6];
  }
  get resumeContext() {
    return this.$$.ctx[7];
  }
}
xt(DR, { id: {}, masterVolume: {} }, ["default"], ["ref", "audioContext", "resumeContext"], !0);
const pb = (s) => {
  const e = Ht(!1), t = Ht(!1), n = Ht(!1);
  let i = !1;
  const r = pu(h_), a = Ji(), o = async (p) => {
    var g;
    e.set(!1);
    try {
      if (typeof p == "string") {
        const _ = await r.load(p, {
          onProgress(b) {
            a("progress", b);
          }
        });
        s.setBuffer(_);
      } else
        p instanceof AudioBuffer ? s.setBuffer(p) : p instanceof HTMLMediaElement ? s.setMediaElementSource(p) : p instanceof AudioBufferSourceNode ? s.setNodeSource(p) : p instanceof MediaStream && s.setMediaStreamSource(p);
      e.set(!0), (g = s.source) != null && g.buffer ? a("load", s.source.buffer) : a("load");
    } catch (_) {
      a("error", _);
    }
  }, c = (p) => {
    s.setVolume(p ?? 1);
  }, l = (p) => {
    s.setPlaybackRate(p ?? 1);
  }, u = async (p) => {
    if (!e.current) {
      n.set(!0);
      return;
    }
    if (!(s.context.state !== "running" && (await s.context.resume(), i)))
      return s.play(p);
  }, h = () => s.pause(), f = () => s.source ? s.stop() : s, d = (p) => {
    t.set(p ?? !1);
  }, A = (p) => {
    s.source && s.source.detune && s.setDetune(p ?? 0);
  }, m = (p) => {
    s.setLoop(p ?? !1);
  };
  return Ft([e, t, n], ([p, g, _]) => {
    if (!p) {
      s.isPlaying && f();
      return;
    }
    (g || _) && u();
  }), Wt(() => {
    try {
      i = !0, f();
    } catch (p) {
      console.warn("Error while destroying audio", p);
    }
  }), {
    setVolume: c,
    setSrc: o,
    setPlaybackRate: l,
    setAutoPlay: d,
    setDetune: A,
    setLoop: m,
    play: u,
    pause: h,
    stop: f
  };
}, LR = (s) => ({ ref: s & /*ref*/
1 }), nm = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function PR(s) {
  let e;
  const t = (
    /*#slots*/
    s[14].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[16],
    nm
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      65537) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[16],
        e ? gt(
          t,
          /*$$scope*/
          i[16],
          r,
          LR
        ) : _t(
          /*$$scope*/
          i[16]
        ),
        nm
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function UR(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [PR, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[15](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      65537 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[15](null), Qe(e, r);
    }
  };
}
function FR(s, e, t) {
  const n = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { src: c } = e, { id: l = void 0 } = e, { volume: u = void 0 } = e, { playbackRate: h = void 0 } = e, { autoplay: f = void 0 } = e, { detune: d = void 0 } = e, { loop: A = void 0 } = e;
  const { getAudioListener: m } = kd(), p = m(l);
  if (!p)
    throw new Error(`No Audiolistener with id ${l} found.`);
  const g = new Sd(p), { pause: _, play: b, stop: y, setAutoPlay: v, setDetune: x, setLoop: S, setPlaybackRate: I, setSrc: E, setVolume: M } = pb(g), T = An();
  $e(s, T, (F) => t(1, r = F));
  function D(F) {
    Mt[F ? "unshift" : "push"](() => {
      r = F, T.set(r);
    });
  }
  return s.$$set = (F) => {
    e = Ve(Ve({}, e), Kt(F)), t(3, i = at(e, n)), "src" in F && t(4, c = F.src), "id" in F && t(5, l = F.id), "volume" in F && t(6, u = F.volume), "playbackRate" in F && t(7, h = F.playbackRate), "autoplay" in F && t(8, f = F.autoplay), "detune" in F && t(9, d = F.detune), "loop" in F && t(10, A = F.loop), "$$scope" in F && t(16, o = F.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*autoplay*/
    256 && v(f), s.$$.dirty & /*src*/
    16 && E(c), s.$$.dirty & /*volume*/
    64 && M(u), s.$$.dirty & /*playbackRate*/
    128 && I(h), s.$$.dirty & /*loop*/
    1024 && S(A), s.$$.dirty & /*detune*/
    512 && x(d);
  }, [
    g,
    r,
    T,
    i,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    _,
    b,
    y,
    a,
    D,
    o
  ];
}
class kR extends St {
  constructor(e) {
    super(), Et(this, e, FR, UR, pt, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      ref: 0,
      pause: 11,
      play: 12,
      stop: 13
    });
  }
  get src() {
    return this.$$.ctx[4];
  }
  set src(e) {
    this.$$set({ src: e }), Y();
  }
  get id() {
    return this.$$.ctx[5];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get volume() {
    return this.$$.ctx[6];
  }
  set volume(e) {
    this.$$set({ volume: e }), Y();
  }
  get playbackRate() {
    return this.$$.ctx[7];
  }
  set playbackRate(e) {
    this.$$set({ playbackRate: e }), Y();
  }
  get autoplay() {
    return this.$$.ctx[8];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), Y();
  }
  get detune() {
    return this.$$.ctx[9];
  }
  set detune(e) {
    this.$$set({ detune: e }), Y();
  }
  get loop() {
    return this.$$.ctx[10];
  }
  set loop(e) {
    this.$$set({ loop: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get pause() {
    return this.$$.ctx[11];
  }
  get play() {
    return this.$$.ctx[12];
  }
  get stop() {
    return this.$$.ctx[13];
  }
}
xt(kR, { src: {}, id: {}, volume: {}, playbackRate: {}, autoplay: {}, detune: {}, loop: {} }, ["default"], ["ref", "pause", "play", "stop"], !0);
const NR = (s) => ({ ref: s & /*ref*/
1 }), im = (s) => ({ ref: (
  /*ref*/
  s[0]
) });
function OR(s) {
  let e;
  const t = (
    /*#slots*/
    s[19].default
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[21],
    im
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope, ref*/
      2097153) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[21],
        e ? gt(
          t,
          /*$$scope*/
          i[21],
          r,
          NR
        ) : _t(
          /*$$scope*/
          i[21]
        ),
        im
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function QR(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    /*$$restProps*/
    s[3]
  ];
  let i = {
    $$slots: {
      default: [OR, ({ ref: r }) => ({ 0: r }), ({ ref: r }) => r ? 1 : 0]
    },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[20](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      9 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        a & /*$$restProps*/
        8 && qt(
          /*$$restProps*/
          r[3]
        )
      ]) : {};
      a & /*$$scope, ref*/
      2097153 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[20](null), Qe(e, r);
    }
  };
}
function GR(s, e, t) {
  const n = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let i = at(e, n), r, { $$slots: a = {}, $$scope: o } = e, { src: c } = e, { id: l = void 0 } = e, { volume: u = void 0 } = e, { playbackRate: h = void 0 } = e, { autoplay: f = void 0 } = e, { detune: d = void 0 } = e, { loop: A = void 0 } = e, { directionalCone: m = void 0 } = e, { refDistance: p = void 0 } = e, { rolloffFactor: g = void 0 } = e, { distanceModel: _ = void 0 } = e, { maxDistance: b = void 0 } = e;
  const { getAudioListener: y } = kd(), v = y(l);
  if (!v)
    throw new Error(`No Audiolistener with id ${l} found.`);
  const x = new p_(v), { pause: S, play: I, stop: E, setAutoPlay: M, setDetune: T, setLoop: D, setPlaybackRate: F, setSrc: C, setVolume: R } = pb(x), O = An();
  $e(s, O, (q) => t(1, r = q));
  function V(q) {
    Mt[q ? "unshift" : "push"](() => {
      r = q, O.set(r);
    });
  }
  return s.$$set = (q) => {
    e = Ve(Ve({}, e), Kt(q)), t(3, i = at(e, n)), "src" in q && t(4, c = q.src), "id" in q && t(5, l = q.id), "volume" in q && t(6, u = q.volume), "playbackRate" in q && t(7, h = q.playbackRate), "autoplay" in q && t(8, f = q.autoplay), "detune" in q && t(9, d = q.detune), "loop" in q && t(10, A = q.loop), "directionalCone" in q && t(11, m = q.directionalCone), "refDistance" in q && t(12, p = q.refDistance), "rolloffFactor" in q && t(13, g = q.rolloffFactor), "distanceModel" in q && t(14, _ = q.distanceModel), "maxDistance" in q && t(15, b = q.maxDistance), "$$scope" in q && t(21, o = q.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    63488 && (p !== void 0 && x.setRefDistance(p), g !== void 0 && x.setRolloffFactor(g), _ !== void 0 && x.setDistanceModel(_), b !== void 0 && x.setMaxDistance(b), m !== void 0 && x.setDirectionalCone(m.coneInnerAngle, m.coneOuterAngle, m.coneOuterGain)), s.$$.dirty & /*autoplay*/
    256 && M(f), s.$$.dirty & /*src*/
    16 && C(c), s.$$.dirty & /*volume*/
    64 && R(u), s.$$.dirty & /*playbackRate*/
    128 && F(h), s.$$.dirty & /*loop*/
    1024 && D(A), s.$$.dirty & /*detune*/
    512 && T(d);
  }, [
    x,
    r,
    O,
    i,
    c,
    l,
    u,
    h,
    f,
    d,
    A,
    m,
    p,
    g,
    _,
    b,
    S,
    I,
    E,
    a,
    V,
    o
  ];
}
class zR extends St {
  constructor(e) {
    super(), Et(this, e, GR, QR, pt, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      directionalCone: 11,
      refDistance: 12,
      rolloffFactor: 13,
      distanceModel: 14,
      maxDistance: 15,
      ref: 0,
      pause: 16,
      play: 17,
      stop: 18
    });
  }
  get src() {
    return this.$$.ctx[4];
  }
  set src(e) {
    this.$$set({ src: e }), Y();
  }
  get id() {
    return this.$$.ctx[5];
  }
  set id(e) {
    this.$$set({ id: e }), Y();
  }
  get volume() {
    return this.$$.ctx[6];
  }
  set volume(e) {
    this.$$set({ volume: e }), Y();
  }
  get playbackRate() {
    return this.$$.ctx[7];
  }
  set playbackRate(e) {
    this.$$set({ playbackRate: e }), Y();
  }
  get autoplay() {
    return this.$$.ctx[8];
  }
  set autoplay(e) {
    this.$$set({ autoplay: e }), Y();
  }
  get detune() {
    return this.$$.ctx[9];
  }
  set detune(e) {
    this.$$set({ detune: e }), Y();
  }
  get loop() {
    return this.$$.ctx[10];
  }
  set loop(e) {
    this.$$set({ loop: e }), Y();
  }
  get directionalCone() {
    return this.$$.ctx[11];
  }
  set directionalCone(e) {
    this.$$set({ directionalCone: e }), Y();
  }
  get refDistance() {
    return this.$$.ctx[12];
  }
  set refDistance(e) {
    this.$$set({ refDistance: e }), Y();
  }
  get rolloffFactor() {
    return this.$$.ctx[13];
  }
  set rolloffFactor(e) {
    this.$$set({ rolloffFactor: e }), Y();
  }
  get distanceModel() {
    return this.$$.ctx[14];
  }
  set distanceModel(e) {
    this.$$set({ distanceModel: e }), Y();
  }
  get maxDistance() {
    return this.$$.ctx[15];
  }
  set maxDistance(e) {
    this.$$set({ maxDistance: e }), Y();
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get pause() {
    return this.$$.ctx[16];
  }
  get play() {
    return this.$$.ctx[17];
  }
  get stop() {
    return this.$$.ctx[18];
  }
}
xt(zR, { src: {}, id: {}, volume: {}, playbackRate: {}, autoplay: {}, detune: {}, loop: {}, directionalCone: {}, refDistance: {}, rolloffFactor: {}, distanceModel: {}, maxDistance: {} }, ["default"], ["ref", "pause", "play", "stop"], !0);
const HR = (s) => {
  const e = b_(sn().camera);
  let t = 0, n = 0;
  const i = new ResizeObserver((r) => {
    for (const a of r)
      t = a.contentRect.width, n = a.contentRect.height;
  });
  return Ft(s.target, (r) => (r && i.observe(r), () => {
    r && i.unobserve(r);
  })), (r, a) => {
    a.pointer.update((o) => (o.set(r.offsetX / t * 2 - 1, -(r.offsetY / n) * 2 + 1), o)), a.raycaster.setFromCamera(a.pointer.current, e.current);
  };
}, VR = () => {
  const s = Wn("threlte-interactivity-context"), e = Ji();
  return {
    ...s,
    addInteractiveObject: (i) => {
      if (!s) {
        console.warn("No interactivity context found. Did you forget to implement interactivity()?");
        return;
      }
      i.userData._threlte_interactivity_dispatcher = e, !s.interactiveObjects.some((r) => r.uuid === i.uuid) && s.interactiveObjects.push(i);
    },
    removeInteractiveObject: (i) => {
      if (!s) {
        console.warn("No interactivity context found. Did you forget to implement interactivity()?");
        return;
      }
      s.interactiveObjects = s.interactiveObjects.filter((r) => r.uuid !== i.uuid), delete i.userData._threlte_interactivity_dispatcher;
    }
  };
}, WR = (s) => {
  const e = vi(), t = vt(!1);
  return Qr(() => {
    t.set(Object.keys(e.$$.callbacks).some((n) => s.includes(n)));
  }), {
    hasEventHandlers: t
  };
}, qR = [
  "click",
  "contextmenu",
  "dblclick",
  "wheel",
  "pointerup",
  "pointerdown",
  "pointerover",
  "pointerout",
  "pointerenter",
  "pointerleave",
  "pointermove",
  "pointermissed"
], XR = () => {
  Dd("interactivity", ({ ref: s }) => {
    if (!s.isObject3D)
      return;
    const { addInteractiveObject: e, removeInteractiveObject: t } = VR(), n = vt(s), { hasEventHandlers: i } = WR(qR);
    return Ft([i, n], ([r, a]) => {
      if (r)
        return e(a), () => t(a);
    }), {
      onRefChange(r) {
        n.set(r);
      }
    };
  });
}, al = (s) => s.userData._threlte_interactivity_dispatcher;
function Hh(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId;
}
const rm = [
  ["click", !1],
  ["contextmenu", !1],
  ["dblclick", !1],
  ["wheel", !1],
  ["pointerdown", !0],
  ["pointerup", !0],
  ["pointerleave", !0],
  ["pointerenter", !0],
  ["pointermove", !0],
  ["pointercancel", !0]
], YR = (s) => {
  function e(l) {
    const u = l.offsetX - s.initialClick[0], h = l.offsetY - s.initialClick[1];
    return Math.round(Math.sqrt(u * u + h * h));
  }
  function t(l) {
    for (const u of s.hovered.values())
      if (!l.length || !l.find((h) => h.object === u.object && h.index === u.index && h.instanceId === u.instanceId)) {
        const h = u.eventObject;
        s.hovered.delete(Hh(u));
        const f = al(h);
        if (f) {
          const d = { ...u, intersections: l };
          f("pointerout", d), f("pointerleave", d);
        }
      }
  }
  const n = b_(s.enabled), i = () => {
    const l = /* @__PURE__ */ new Set(), u = [];
    let h = s.interactiveObjects.flatMap((f) => n.current ? s.raycaster.intersectObject(f, !0) : []).sort((f, d) => f.distance - d.distance).filter((f) => {
      const d = Hh(f);
      return l.has(d) ? !1 : (l.add(d), !0);
    });
    s.filter && (h = s.filter(h, s));
    for (const f of h) {
      let d = f.object;
      for (; d; )
        al(d) && u.push({ ...f, eventObject: d }), d = d.parent;
    }
    return u;
  };
  function r(l, u) {
    for (const h of u) {
      const f = al(h);
      f && f("pointermissed", l);
    }
  }
  const a = (l) => l === "pointerleave" || l === "pointercancel" ? () => {
    s.pointerOverTarget.set(!1), t([]);
  } : l === "pointerenter" ? () => {
    s.pointerOverTarget.set(!0);
  } : (u) => {
    const h = l === "pointermove", f = l === "click" || l === "contextmenu" || l === "dblclick";
    s.compute(u, s);
    const d = i(), A = f ? e(u) : 0;
    l === "pointerdown" && (s.initialClick = [u.offsetX, u.offsetY], s.initialHits = d.map((p) => p.eventObject)), f && !d.length && A <= 2 && r(u, s.interactiveObjects), h && t(d);
    let m = !1;
    e:
      for (const p of d) {
        const g = {
          stopped: m,
          ...p,
          intersections: d,
          stopPropagation() {
            if (m = !0, g.stopped = !0, s.hovered.size && Array.from(s.hovered.values()).find((b) => b.eventObject === p.eventObject)) {
              const b = d.slice(0, d.indexOf(p));
              t([...b, p]);
            }
          },
          camera: s.raycaster.camera,
          delta: A,
          nativeEvent: u,
          pointer: s.pointer.current,
          ray: s.raycaster.ray
        }, _ = al(p.eventObject);
        if (!_)
          return;
        if (h) {
          if (_.hasEventListener("pointerover") || _.hasEventListener("pointerenter") || _.hasEventListener("pointerout") || _.hasEventListener("pointerleave")) {
            const b = Hh(g), y = s.hovered.get(b);
            y ? y.stopped && g.stopPropagation() : (s.hovered.set(b, g), _("pointerover", g), _("pointerenter", g));
          }
          _("pointermove", g);
        } else
          _.hasEventListener(l) ? (!f || s.initialHits.includes(p.eventObject)) && (r(u, s.interactiveObjects.filter((y) => !s.initialHits.includes(y))), _(l, g)) : f && s.initialHits.includes(p.eventObject) && r(u, s.interactiveObjects.filter((y) => !s.initialHits.includes(y)));
        if (m)
          break e;
      }
  }, o = (l) => {
    rm.forEach(([u]) => {
      l.removeEventListener(u, a(u));
    });
  }, c = (l) => {
    rm.forEach(([u, h]) => {
      l.addEventListener(u, a(u), { passive: h });
    });
  };
  Ft(s.target, (l) => (l && c(l), () => {
    l && o(l);
  }));
}, jR = (s) => {
  const e = {
    enabled: Ht((s == null ? void 0 : s.enabled) ?? !0),
    pointer: Ht(new xe()),
    pointerOverTarget: Ht(!1),
    lastEvent: void 0,
    raycaster: new Zo(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target: Ht((s == null ? void 0 : s.target) ?? sn().renderer.domElement),
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    compute: () => {
    },
    filter: s == null ? void 0 : s.filter
  };
  return e.compute = (s == null ? void 0 : s.compute) ?? HR(e), Jn("threlte-interactivity-context", e), XR(), YR(e), e;
}, JR = (s) => ({}), sm = (s) => ({ ref: (
  /*ref*/
  s[0]
) }), KR = (s) => ({}), am = (s) => ({ error: (
  /*error*/
  s[10]
) }), ZR = (s) => ({}), om = (s) => ({});
function $R(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].error
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    am
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          KR
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        am
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function eD(s) {
  let e, t;
  return e = new qe.Group({
    props: {
      name: "Scene",
      $$slots: { default: [iD] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment);
    },
    m(n, i) {
      Oe(e, n, i), t = !0;
    },
    p(n, i) {
      const r = {};
      i & /*$$scope*/
      512 && (r.$$scope = { dirty: i, ctx: n }), e.$set(r);
    },
    i(n) {
      t || (ae(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ue(e.$$.fragment, n), t = !1;
    },
    d(n) {
      Qe(e, n);
    }
  };
}
function tD(s) {
  let e, t, n, i, r, a;
  return e = new qe({
    props: { is: (
      /*gltf*/
      s[5].nodes.mixamorigHips
    ) }
  }), n = new qe.SkinnedMesh({
    props: {
      name: "Alpha_Joints",
      geometry: (
        /*gltf*/
        s[5].nodes.Alpha_Joints.geometry
      ),
      material: (
        /*gltf*/
        s[5].materials["Alpha_Joints_MAT.001"]
      ),
      skeleton: (
        /*gltf*/
        s[5].nodes.Alpha_Joints.skeleton
      )
    }
  }), r = new qe.SkinnedMesh({
    props: {
      name: "Alpha_Surface",
      geometry: (
        /*gltf*/
        s[5].nodes.Alpha_Surface.geometry
      ),
      material: (
        /*gltf*/
        s[5].materials["Alpha_Body_MAT.001"]
      ),
      skeleton: (
        /*gltf*/
        s[5].nodes.Alpha_Surface.skeleton
      )
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment), i = Pt(), ze(r.$$.fragment);
    },
    m(o, c) {
      Oe(e, o, c), st(o, t, c), Oe(n, o, c), st(o, i, c), Oe(r, o, c), a = !0;
    },
    p: si,
    i(o) {
      a || (ae(e.$$.fragment, o), ae(n.$$.fragment, o), ae(r.$$.fragment, o), a = !0);
    },
    o(o) {
      ue(e.$$.fragment, o), ue(n.$$.fragment, o), ue(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (rt(t), rt(i)), Qe(e, o), Qe(n, o), Qe(r, o);
    }
  };
}
function nD(s) {
  let e, t, n, i, r, a;
  return e = new qe({
    props: {
      is: (
        /*gltf*/
        s[5].nodes.mixamorigHips_1
      )
    }
  }), n = new qe.SkinnedMesh({
    props: {
      name: "Beta_Joints",
      geometry: (
        /*gltf*/
        s[5].nodes.Beta_Joints.geometry
      ),
      material: (
        /*gltf*/
        s[5].materials.Beta_Joints_MAT1
      ),
      skeleton: (
        /*gltf*/
        s[5].nodes.Beta_Joints.skeleton
      )
    }
  }), r = new qe.SkinnedMesh({
    props: {
      name: "Beta_Surface",
      geometry: (
        /*gltf*/
        s[5].nodes.Beta_Surface.geometry
      ),
      material: (
        /*gltf*/
        s[5].materials.Beta_HighLimbsGeoSG3
      ),
      skeleton: (
        /*gltf*/
        s[5].nodes.Beta_Surface.skeleton
      )
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment), i = Pt(), ze(r.$$.fragment);
    },
    m(o, c) {
      Oe(e, o, c), st(o, t, c), Oe(n, o, c), st(o, i, c), Oe(r, o, c), a = !0;
    },
    p: si,
    i(o) {
      a || (ae(e.$$.fragment, o), ae(n.$$.fragment, o), ae(r.$$.fragment, o), a = !0);
    },
    o(o) {
      ue(e.$$.fragment, o), ue(n.$$.fragment, o), ue(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (rt(t), rt(i)), Qe(e, o), Qe(n, o), Qe(r, o);
    }
  };
}
function iD(s) {
  let e, t, n, i;
  return e = new qe.Group({
    props: {
      name: "M",
      position: [0, 0, -0.59],
      rotation: [Math.PI / 2, 0, 0],
      scale: 0.01,
      $$slots: { default: [tD] },
      $$scope: { ctx: s }
    }
  }), n = new qe.Group({
    props: {
      name: "G",
      position: [0, 0, 0.59],
      rotation: [Math.PI / 2, 0, 3.11],
      scale: 0.01,
      $$slots: { default: [nD] },
      $$scope: { ctx: s }
    }
  }), {
    c() {
      ze(e.$$.fragment), t = Pt(), ze(n.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), st(r, t, a), Oe(n, r, a), i = !0;
    },
    p(r, a) {
      const o = {};
      a & /*$$scope*/
      512 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
      const c = {};
      a & /*$$scope*/
      512 && (c.$$scope = { dirty: a, ctx: r }), n.$set(c);
    },
    i(r) {
      i || (ae(e.$$.fragment, r), ae(n.$$.fragment, r), i = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), ue(n.$$.fragment, r), i = !1;
    },
    d(r) {
      r && rt(t), Qe(e, r), Qe(n, r);
    }
  };
}
function rD(s) {
  let e;
  const t = (
    /*#slots*/
    s[7].fallback
  ), n = At(
    t,
    s,
    /*$$scope*/
    s[9],
    om
  );
  return {
    c() {
      n && n.c();
    },
    m(i, r) {
      n && n.m(i, r), e = !0;
    },
    p(i, r) {
      n && n.p && (!e || r & /*$$scope*/
      512) && mt(
        n,
        t,
        i,
        /*$$scope*/
        i[9],
        e ? gt(
          t,
          /*$$scope*/
          i[9],
          r,
          ZR
        ) : _t(
          /*$$scope*/
          i[9]
        ),
        om
      );
    },
    i(i) {
      e || (ae(n, i), e = !0);
    },
    o(i) {
      ue(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function sD(s) {
  let e, t, n = {
    ctx: s,
    current: null,
    token: null,
    hasCatch: !0,
    pending: rD,
    then: eD,
    catch: $R,
    value: 5,
    error: 10,
    blocks: [, , ,]
  };
  Ub(
    /*gltf*/
    s[5],
    n
  );
  const i = (
    /*#slots*/
    s[7].default
  ), r = At(
    i,
    s,
    /*$$scope*/
    s[9],
    sm
  );
  return {
    c() {
      n.block.c(), e = Pt(), r && r.c();
    },
    m(a, o) {
      n.block.m(a, n.anchor = o), n.mount = () => e.parentNode, n.anchor = e, st(a, e, o), r && r.m(a, o), t = !0;
    },
    p(a, o) {
      s = a, Fb(n, s, o), r && r.p && (!t || o & /*$$scope*/
      512) && mt(
        r,
        i,
        s,
        /*$$scope*/
        s[9],
        t ? gt(
          i,
          /*$$scope*/
          s[9],
          o,
          JR
        ) : _t(
          /*$$scope*/
          s[9]
        ),
        sm
      );
    },
    i(a) {
      t || (ae(n.block), ae(r, a), t = !0);
    },
    o(a) {
      for (let o = 0; o < 3; o += 1) {
        const c = n.blocks[o];
        ue(c);
      }
      ue(r, a), t = !1;
    },
    d(a) {
      a && rt(e), n.block.d(a), n.token = null, n = null, r && r.d(a);
    }
  };
}
function aD(s) {
  let e, t;
  const n = [
    { is: (
      /*ref*/
      s[0]
    ) },
    { dispose: !1 },
    /*$$restProps*/
    s[4]
  ];
  let i = {
    $$slots: { default: [sD] },
    $$scope: { ctx: s }
  };
  for (let r = 0; r < n.length; r += 1)
    i = Ve(i, n[r]);
  return e = new qe({ props: i }), s[8](e), {
    c() {
      ze(e.$$.fragment);
    },
    m(r, a) {
      Oe(e, r, a), t = !0;
    },
    p(r, [a]) {
      const o = a & /*ref, $$restProps*/
      17 ? Qt(n, [
        a & /*ref*/
        1 && { is: (
          /*ref*/
          r[0]
        ) },
        n[1],
        a & /*$$restProps*/
        16 && qt(
          /*$$restProps*/
          r[4]
        )
      ]) : {};
      a & /*$$scope*/
      512 && (o.$$scope = { dirty: a, ctx: r }), e.$set(o);
    },
    i(r) {
      t || (ae(e.$$.fragment, r), t = !0);
    },
    o(r) {
      ue(e.$$.fragment, r), t = !1;
    },
    d(r) {
      s[8](null), Qe(e, r);
    }
  };
}
const oD = "https://zavx0z.github.io/view-port-threlte/src/assets/bots.glb";
function cD(s, e, t) {
  const n = ["ref", "actions"];
  let i = at(e, n), r, a = si, o = () => (a(), a = Go(d, (p) => t(6, r = p)), d), c;
  s.$$.on_destroy.push(() => a());
  let { $$slots: l = {}, $$scope: u } = e;
  const h = H_(oD);
  jR();
  const f = new Un(), { actions: d } = aw(h, f);
  o();
  const A = An();
  $e(s, A, (p) => t(2, c = p));
  function m(p) {
    Mt[p ? "unshift" : "push"](() => {
      c = p, A.set(c);
    });
  }
  return s.$$set = (p) => {
    e = Ve(Ve({}, e), Kt(p)), t(4, i = at(e, n)), "$$scope" in p && t(9, u = p.$$scope);
  }, s.$$.update = () => {
    s.$$.dirty & /*$actions*/
    64 && Object.entries(r).forEach(([p, g]) => {
      g == null || g.play();
    });
  }, [
    f,
    d,
    c,
    A,
    i,
    h,
    r,
    l,
    m,
    u
  ];
}
class lD extends St {
  constructor(e) {
    super(), Et(this, e, cD, aD, pt, { ref: 0, actions: 1 });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  get actions() {
    return this.$$.ctx[1];
  }
}
xt(lD, {}, ["fallback", "error", "default"], ["ref", "actions"], !0);
export {
  lD as B,
  NM as C,
  BT as G,
  i2 as O,
  St as S,
  qe as T,
  Eb as a,
  At as b,
  xt as c,
  Pt as d,
  Rr as e,
  Y as f,
  ze as g,
  Hi as h,
  Et as i,
  st as j,
  _t as k,
  gt as l,
  Oe as m,
  ue as n,
  rt as o,
  Qe as p,
  pT as q,
  si as r,
  pt as s,
  ae as t,
  mt as u
};
